.TH "IrcObject" 3 "Mon Jun 23 2014" "Version 0.1" "Social Bot Interface" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IrcObject \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <IrcObject\&.h>\fP
.PP
Inherited by \fBIrcChannel\fP, \fBIrcChannel\fP, \fBIrcConnection\fP, \fBIrcConnection\fP, \fBIrcNetwork\fP, \fBIrcNetwork\fP, \fBIrcParser\fP, \fBIrcParser\fP, \fBIrcUser\fP, and \fBIrcUser\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIrcObject\fP ()"
.br
.ti -1c
.RI "virtual \fB~IrcObject\fP ()=0"
.br
.ti -1c
.RI "\fBIrcObject\fP ()"
.br
.ti -1c
.RI "virtual \fB~IrcObject\fP ()=0"
.br
.ti -1c
.RI "void \fBAddReference\fP (\fBREFERENCE_DECL\fP)"
.br
.ti -1c
.RI "uint32_t \fBRefCount\fP ()"
.br
.ti -1c
.RI "void \fBRemoveReference\fP (\fBREFERENCE_DECL\fP)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBIrcEngine\fP * \fB_irc_engine\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBNO_CLASS_COPY\fP (\fBIrcObject\fP)"
.br
.ti -1c
.RI "\fBNO_CLASS_COPY\fP (\fBIrcObject\fP)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::atomic< uint32_t > \fB_refcount\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 40 of file IrcObject\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "IrcObject::IrcObject ()"

.PP
Definition at line 21 of file IrcObject\&.cc\&.
.PP
References Runtime::GetObjectFromModule(), IRC_MODULE_NAME, and runtime\&.
.PP
.nf
22 {
23         /* other engine accesses use the IRC_RUNTIME_MODULE macro; we don't here
24          * because we want a permanent assignment\&. */
25         if (( _irc_engine = static_cast<IrcEngine*>(runtime\&.GetObjectFromModule(IRC_MODULE_NAME))) == nullptr )
26         {
27                 throw std::runtime_error("The irc engine could not be acquired");
28         }
29 }
.fi
.SS "IrcObject::~IrcObject ()\fC [pure virtual]\fP"

.PP
Definition at line 33 of file IrcObject\&.cc\&.
.PP
Referenced by RemoveReference()\&.
.PP
.nf
34 {
35 }
.fi
.SS "IrcObject::IrcObject ()"

.SS "virtual IrcObject::~IrcObject ()\fC [pure virtual]\fP"

.SH "Member Function Documentation"
.PP 
.SS "void IrcObject::AddReference (\fBREFERENCE_DECL\fP)"
Increments the reference counter for this object\&. 
.PP
Definition at line 50 of file bak/IrcObject\&.cc\&.
.PP
References LOG\&.
.PP
.nf
53 {
54         // add 1 to the counter, but fetch the value previously stored
55         uint32_t        refs = _refcount\&.fetch_add(1);
56 
57         switch ( refs )
58         {
59         case UINT32_MAX:
60                 throw std::runtime_error("Integer overflow: AddReference has been called too many times");
61         default:
62                 // normal operation
63                 break;
64         }
65 
66         // refs is the value previously stored, must +1
67 #if defined(USING_DETAILED_REFERENCE_COUNTING)
68         LOG(LL_Debug) << "IrcObject " << this
69                 << " referenced (" << (refs + 1)
70                 << ") by " << function << "\n";
71 #else
72         LOG(LL_Debug) << "IrcObject " << this
73                 << " referenced (" << (refs + 1) 
74                 << ")\n";
75 #endif
76 }
.fi
.SS "IrcObject::NO_CLASS_COPY (\fBIrcObject\fP)\fC [private]\fP"

.SS "IrcObject::NO_CLASS_COPY (\fBIrcObject\fP)\fC [private]\fP"

.SS "uint32_t IrcObject::RefCount ()"
Retrieves the reference counter for this object\&. Note that the value returned is as it was at the time - by the time the caller reads it, another operation could have incremented this already!
.PP
\fBReturns:\fP
.RS 4
A non-atomic unsigned integer containing the current number of references this object has 
.RE
.PP

.PP
Definition at line 81 of file bak/IrcObject\&.cc\&.
.PP
.nf
82 {
83         return _refcount\&.load();
84 }
.fi
.SS "void IrcObject::RemoveReference (\fBREFERENCE_DECL\fP)"
Decrements the reference counter for this object\&. 
.PP
Definition at line 89 of file bak/IrcObject\&.cc\&.
.PP
References LOG, and ~IrcObject()\&.
.PP
.nf
92 {
93         // subtract 1 from the counter, but fetch the value previously stored
94         uint32_t        refs = _refcount\&.fetch_sub(1);
95 
96         switch ( refs )
97         {
98         case 0:
99                 /* Chances are, someone has called RemoveReference() instead of 
100                  * the relevant `PoolType->Free()` */
101                 throw std::runtime_error("Integer underflow; Dereference has been called too many times");
102 #if 0   // Code Removed: derived destructors are not executed
103         case 1:
104                 /* since all objects are a part of a memory pool (IrcObjectPool),
105                  * there is no 'deletion' - so this is now the same as just a
106                  * normal dereference!
107                  * We will, however, call the destructor here\&. In general, a
108                  * caller will execute `PoolType->Free()` on the object, which
109                  * does the dereference internally\&.  */
110                 this->~IrcObject();
111                 break;
112 #endif
113         default:
114                 // referenced object, normal operation
115                 break;
116         }
117 
118         // refs is the value previously stored, must -1
119 #if defined(USING_DETAILED_REFERENCE_COUNTING)
120         LOG(LL_Debug) << "IrcObject " << this
121                 << " dereferenced (" << (refs + 1) 
122                 << ") by " << function << "\n";
123 #else
124         LOG(LL_Debug) << "IrcObject " << this
125                 << " dereferenced (" << (refs + 1) 
126                 << ")\n";
127 #endif
128 }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBIrcEngine\fP * IrcObject::_irc_engine\fC [protected]\fP"

.PP
Definition at line 50 of file IrcObject\&.h\&.
.PP
Referenced by IrcConnection::AddChannel(), IrcChannel::AddNamesUser(), IrcChannel::AddUser(), IrcConnection::DeleteChannel(), IrcChannel::DeleteUser(), IrcConnection::EraseChannelList(), IrcChannel::EraseNameslist(), IrcConnection::EstablishConnection(), IrcConnection::GetChannel(), IrcChannel::GetUser(), IrcParser::Handle001(), IrcParser::Handle002(), IrcParser::Handle003(), IrcParser::Handle004(), IrcParser::Handle005(), IrcParser::Handle332(), IrcParser::Handle353(), IrcParser::Handle366(), IrcParser::HandleCap(), IrcParser::HandleInvite(), IrcParser::HandleJoin(), IrcParser::HandleKick(), IrcParser::HandleKill(), IrcParser::HandleNick(), IrcParser::HandlePart(), IrcParser::HandlePrivmsg(), IrcParser::HandleQuit(), IrcParser::HandleTopic(), IrcConnection::IrcConnection(), IrcParser::RunParser(), and IrcNetwork::Setup()\&.
.SS "std::atomic<uint32_t> IrcObject::_refcount\fC [private]\fP"
active reference counter for the derived object 
.PP
Definition at line 72 of file bak/IrcObject\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Social Bot Interface from the source code\&.
