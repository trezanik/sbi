.TH "IrcChannel" 3 "Mon Jun 23 2014" "Version 0.1" "Social Bot Interface" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IrcChannel \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <IrcChannel\&.h>\fP
.PP
Inherits \fBIrcObject\fP, and \fBIrcObject\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIrcChannel\fP (std::shared_ptr< \fBIrcConnection\fP > connection, const char *channel_name)"
.br
.ti -1c
.RI "\fB~IrcChannel\fP ()"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBAddNamesUser\fP (const char *name, const char *ident, const char *hostmask, const \fBmode_update\fP *modes)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBCleanup\fP ()"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBDeleteUser\fP (std::shared_ptr< \fBIrcUser\fP > user)"
.br
.ti -1c
.RI "std::shared_ptr< \fBIrcUser\fP > \fBGetUser\fP (const char *nickname)"
.br
.ti -1c
.RI "bool \fBIsActive\fP () const "
.br
.ti -1c
.RI "bool \fBIsAuthorized\fP (const char *nickname, const uint8_t mode) const "
.br
.ti -1c
.RI "bool \fBIsAuthorized\fP (const std::shared_ptr< \fBIrcUser\fP > user, const uint8_t mode) const "
.br
.ti -1c
.RI "std::string \fBName\fP () const "
.br
.ti -1c
.RI "uint32_t \fBNumberOfUsers\fP () const "
.br
.ti -1c
.RI "std::shared_ptr< \fBIrcConnection\fP > \fBOwner\fP ()"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBPopulateUserlist\fP ()"
.br
.ti -1c
.RI "std::string \fBTopic\fP () const "
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBUpdateTopic\fP (const char *topic)"
.br
.ti -1c
.RI "std::set< std::string > & \fBUsers\fP ()"
.br
.ti -1c
.RI "\fBIrcChannel\fP (\fBIrcConnection\fP *parent_connection, const char *channel_name)"
.br
.ti -1c
.RI "\fB~IrcChannel\fP ()"
.br
.ti -1c
.RI "bool \fBAddNamesUser\fP (const char *name, const char *ident, const char *hostmask, const \fBmode_update\fP *modes)"
.br
.ti -1c
.RI "bool \fBAddUser\fP (const char *name, const char *ident, const char *hostmask)"
.br
.ti -1c
.RI "void \fBCleanup\fP ()"
.br
.ti -1c
.RI "bool \fBDeleteUser\fP (\fBIrcUser\fP *user)"
.br
.ti -1c
.RI "\fBIrcUser\fP * \fBGetUser\fP (const char *nickname)"
.br
.ti -1c
.RI "bool \fBIsActive\fP () const "
.br
.ti -1c
.RI "bool \fBIsAuthorized\fP (const char *nickname, const uint8_t mode) const "
.br
.ti -1c
.RI "bool \fBIsAuthorized\fP (const \fBIrcUser\fP *user, const uint8_t mode) const "
.br
.ti -1c
.RI "std::string \fBName\fP () const "
.br
.ti -1c
.RI "uint32_t \fBNumberOfUsers\fP () const "
.br
.ti -1c
.RI "\fBIrcConnection\fP * \fBOwner\fP ()"
.br
.ti -1c
.RI "void \fBPopulateUserlist\fP ()"
.br
.ti -1c
.RI "std::string \fBTopic\fP () const "
.br
.ti -1c
.RI "void \fBUpdateTopic\fP (const char *topic)"
.br
.ti -1c
.RI "std::set< \fBIrcUser\fP * > & \fBUsers\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBNO_CLASS_ASSIGNMENT\fP (\fBIrcChannel\fP)"
.br
.ti -1c
.RI "\fBNO_CLASS_COPY\fP (\fBIrcChannel\fP)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBEraseNameslist\fP ()"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBEraseUserlist\fP ()"
.br
.ti -1c
.RI "\fBNO_CLASS_ASSIGNMENT\fP (\fBIrcChannel\fP)"
.br
.ti -1c
.RI "\fBNO_CLASS_COPY\fP (\fBIrcChannel\fP)"
.br
.ti -1c
.RI "void \fBEraseNameslist\fP ()"
.br
.ti -1c
.RI "void \fBEraseUserlist\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "uint32_t \fB_flags\fP"
.br
.ti -1c
.RI "uint16_t \fB_limit\fP"
.br
.ti -1c
.RI "std::string \fB_key\fP"
.br
.ti -1c
.RI "std::string \fB_name\fP"
.br
.ti -1c
.RI "std::string \fB_topic\fP"
.br
.ti -1c
.RI "std::weak_ptr< \fBIrcConnection\fP > \fB_owner\fP"
.br
.ti -1c
.RI "std::set< std::string > \fB_userlist\fP"
.br
.ti -1c
.RI "std::set< \fBIrcUser\fP * > \fB_nameslist\fP"
.br
.ti -1c
.RI "std::recursive_mutex \fB_mutex\fP"
.br
.ti -1c
.RI "\fBIrcConnection\fP * \fB_parent_connection\fP"
.br
.ti -1c
.RI "std::set< \fBIrcUser\fP * > \fB_userlist\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBIrcParser\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Definition at line 36 of file IrcChannel\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "IrcChannel::IrcChannel (std::shared_ptr< \fBIrcConnection\fP >connection, const char *channel_name)"
Constructs the channel\&. This is the only opportunity to set the name of it (why would you change it afterwards?)\&.
.PP
Should only be created (and therefore called) from the \fBIrcParser\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The \fBIrcConnection\fP this channel was created for 
.br
\fIchannel_name\fP The name of the channel for 
.RE
.PP

.PP
Definition at line 33 of file IrcChannel\&.cc\&.
.PP
.nf
36   : _flags(0), _limit(0), _owner(connection)
37 {
38         // userlist, nameslist, etc\&., start empty
39 
40         _name = channel_name;
41 }
.fi
.SS "IrcChannel::~IrcChannel ()"

.PP
Definition at line 45 of file IrcChannel\&.cc\&.
.PP
References Cleanup()\&.
.PP
.nf
46 {
47         Cleanup();
48 }
.fi
.SS "IrcChannel::IrcChannel (\fBIrcConnection\fP *parent_connection, const char *channel_name)"
Constructs the channel\&. This is the only opportunity to set the name of it (why would you change it afterwards?)\&.
.PP
Should only be created (and therefore called) from the \fBIrcParser\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIparent_connection\fP The connection this channel was created for 
.br
\fIchannel_name\fP The name of the channel for 
.RE
.PP

.PP
Definition at line 32 of file bak/IrcChannel\&.cc\&.
.PP
.nf
35   : _flags(0), _limit(0), _parent_connection(parent_connection)
36 {
37         // userlist, nameslist, etc\&., start empty
38 
39         _name = channel_name;
40 }
.fi
.SS "IrcChannel::~IrcChannel ()"

.SH "Member Function Documentation"
.PP 
.SS "bool IrcChannel::AddNamesUser (const char *name, const char *ident, const char *hostmask, const \fBmode_update\fP *modes)"
Adds the supplied user details into a new \fBIrcUser\fP class which is added to the receiving 353 NAMES list\&.
.PP
Identical to that of AddUser excepting the list the user is added to, and not calling a \fBUI\fP update
.PP
\fBParameters:\fP
.RS 4
\fIname\fP The users nickname 
.br
\fIident\fP The users ident 
.br
\fIhostmask\fP The users hostmask 
.br
\fImodes\fP The users channel modes 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the user is created and added to the list 
.PP
false on an invalid parameter or addition failure 
.RE
.PP

.SS "bool IrcChannel::AddNamesUser (const char *name, const char *ident, const char *hostmask, const \fBmode_update\fP *modes)"
Adds the supplied user details into a new \fBIrcUser\fP class which is added to the receiving 353 NAMES list\&.
.PP
Identical to that of AddUser excepting the list the user is added to, and not calling a \fBUI\fP update
.PP
\fBParameters:\fP
.RS 4
\fIname\fP The users nickname 
.br
\fIident\fP The users ident 
.br
\fIhostmask\fP The users hostmask 
.br
\fImodes\fP The users channel modes 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the user is created and added to the list 
.PP
false on an invalid parameter or addition failure 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
we must have a better method than this, this is awful\&. could always get CreateXx to return object, shouldn't affect lifetimes 
.RE
.PP

.PP
Definition at line 53 of file IrcChannel\&.cc\&.
.PP
References IrcObject::_irc_engine, _mutex, _nameslist, IrcEngine::CreateUser(), fg_red(), IrcPool::GetUser(), MissingParameter, Name(), OK, Owner(), and IrcEngine::Pools()\&.
.PP
Referenced by IrcParser::Handle353()\&.
.PP
.nf
59 {
60         IrcUser*        user;
61 
62         if ( name == nullptr )
63                 goto no_name;
64         if ( ident == nullptr )
65                 goto no_ident;
66         if ( hostmask == nullptr )
67                 goto no_hostmask;
68 
69         {
70                 std::lock_guard<std::recursive_mutex>   lock(_mutex);
71 
72                 _irc_engine->CreateUser(Owner()->Id(), Name()\&.c_str(), name, ident, hostmask);
73 
74                 if ( modes != nullptr )
75                 {
76                         // since we have the modes, update now
80                         _irc_engine->Pools()->GetUser(Owner()->Id(), Name()\&.c_str(), name)->Update(nullptr, nullptr, nullptr, modes);
81                 }
82 
83                 _nameslist\&.insert(user);
84 
85                 // no notification, this is a temporary holder
86         }
87 
88         return EIrcStatus::OK;
89 
90 no_name:
91         std::cerr << fg_red << "The supplied nickname was a nullptr\n";
92         return EIrcStatus::MissingParameter;
93 no_ident:
94         std::cerr << fg_red << "The supplied ident was a nullptr\n";
95         return EIrcStatus::MissingParameter;
96 no_hostmask:
97         std::cerr << fg_red << "The supplied hostmask was a nullptr\n";
98         return EIrcStatus::MissingParameter;
99 }
.fi
.SS "bool IrcChannel::AddUser (const char *name, const char *ident, const char *hostmask)"
Adds the supplied user details into a new \fBIrcUser\fP class which is added directly to the active userlist\&. Called primarily from receiving a 'JOIN' on an active channel\&.
.PP
Identical to that of AddNamesUser excepting the list the user is added to, and calling a \fBUI\fP update on completion\&.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP The users nickname 
.br
\fIident\fP The users ident 
.br
\fIhostmask\fP The users hostmask 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the user is created and added to the list 
.PP
false on an invalid parameter or addition failure 
.RE
.PP

.PP
Definition at line 100 of file bak/IrcChannel\&.cc\&.
.PP
References IrcObject::_irc_engine, _mutex, _userlist, IrcFactory::CreateIrcUser(), IrcEngine::Factory(), and fg_red()\&.
.PP
Referenced by IrcParser::HandleJoin()\&.
.PP
.nf
105 {
106         IrcUser*        user;
107 
108         if ( name == nullptr )
109                 goto no_name;
110         if ( ident == nullptr )
111                 goto no_ident;
112         if ( hostmask == nullptr )
113                 goto no_hostmask;
114 
115         {
116                 std::lock_guard<std::recursive_mutex>   lock(_mutex);
117 
118                 _irc_engine->Factory()->CreateIrcUser(this, name, ident, hostmask);
119 
120                 _userlist\&.insert(user);
121         }
122 
123         return true;
124 
125 no_name:
126         std::cerr << fg_red << "The supplied nickname was a nullptr\n";
127         return false;
128 no_ident:
129         std::cerr << fg_red << "The supplied ident was a nullptr\n";
130         return false;
131 no_hostmask:
132         std::cerr << fg_red << "The supplied hostmask was a nullptr\n";
133         return false;
134 }
.fi
.SS "void IrcChannel::Cleanup ()"

.PP
Definition at line 104 of file IrcChannel\&.cc\&.
.PP
References _mutex, EraseNameslist(), EraseUserlist(), and OK\&.
.PP
Referenced by ~IrcChannel()\&.
.PP
.nf
105 {
106         EIrcStatus      retval;
107 
108         std::lock_guard<std::recursive_mutex>   lock(_mutex);
109 
110         if (( retval = EraseNameslist()) != EIrcStatus::OK )
111                 return retval;
112         if (( retval = EraseUserlist()) != EIrcStatus::OK )
113                 return retval;
114 
115         return EIrcStatus::OK;
116 }
.fi
.SS "void IrcChannel::Cleanup ()"

.SS "\fBEIrcStatus\fP IrcChannel::DeleteUser (std::shared_ptr< \fBIrcUser\fP >user)"
Unlinks the supplied user from the userlist, if not already done (usually via ReleaseUser), and decrements its reference count\&.
.PP
Note this function does not get called on the userlist or names list cleanups, as they unlink and release the user directly\&.
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP The user to delete 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true if the user is unlinked and released 
.PP
false is returned if the user is a nullptr, or an integer underflow is triggered on the linked list\&. 
.RE
.PP

.PP
Definition at line 121 of file IrcChannel\&.cc\&.
.PP
References IrcObject::_irc_engine, fg_red(), ObjectPool< T >::FreeObject(), IrcPool::IrcUsers(), MissingParameter, ObjectFreeError, OK, and IrcEngine::Pools()\&.
.PP
Referenced by IrcParser::HandleKick(), and IrcParser::HandlePart()\&.
.PP
.nf
124 {
125         if ( user == nullptr )
126                 goto no_user;
127 
128         return _irc_engine->Pools()->IrcUsers()->FreeObject(user) ?
129                 EIrcStatus::OK : EIrcStatus::ObjectFreeError;
130         
131 no_user:
132         std::cerr << fg_red << "The supplied user was a nullptr\n";
133         return EIrcStatus::MissingParameter;
134 }
.fi
.SS "bool IrcChannel::DeleteUser (\fBIrcUser\fP *user)"
Unlinks the supplied user from the userlist, if not already done (usually via ReleaseUser), and decrements its reference count\&.
.PP
Note this function does not get called on the userlist or names list cleanups, as they unlink and release the user directly\&.
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP The user to delete 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true if the user is unlinked and released 
.PP
false is returned if the user is a nullptr, or an integer underflow is triggered on the linked list\&. 
.RE
.PP

.PP
Definition at line 151 of file bak/IrcChannel\&.cc\&.
.PP
References IrcObject::_irc_engine, _mutex, _userlist, IrcFactory::DeleteIrcObject(), IrcEngine::Factory(), and fg_red()\&.
.PP
.nf
154 {
155         if ( user == nullptr )
156                 goto no_user;
157 
158         {
159                 std::lock_guard<std::recursive_mutex>   lock(_mutex);
160 
161                 for ( auto u : _userlist )
162                 {
163                         if ( u == user )
164                         {
165                                 // users are created by a factory, needs matching delete
166                                 _irc_engine->Factory()->DeleteIrcObject(user);
167                                 _userlist\&.erase(u);
168                                 // must break out of the loop, iterator invalid
169                                 return true;
170                         }
171                 }
172         }
173 
174         std::cerr << fg_red << "The supplied user was not found in the userlist\n";
175         return false;
176 
177 no_user:
178         std::cerr << fg_red << "The supplied user was a nullptr\n";
179         return false;
180 }
.fi
.SS "void IrcChannel::EraseNameslist ()\fC [private]\fP"
Deletes all the \fBIrcUser\fP objects in the names list\&.
.PP
The protection mutex is recursive, so we can call this safely from other class functions so long as they're on the same thread\&. 
.SS "void IrcChannel::EraseNameslist ()\fC [private]\fP"
Deletes all the \fBIrcUser\fP objects in the names list\&.
.PP
The protection mutex is recursive, so we can call this safely from other class functions so long as they're on the same thread\&. 
.PP
Definition at line 139 of file IrcChannel\&.cc\&.
.PP
References IrcObject::_irc_engine, _mutex, _nameslist, ObjectPool< T >::FreeObject(), GetUser(), IrcPool::IrcUsers(), OK, and IrcEngine::Pools()\&.
.PP
Referenced by Cleanup()\&.
.PP
.nf
140 {
141         std::lock_guard<std::recursive_mutex>   lock(_mutex);
142 
143         for ( auto u : _nameslist )
144         {
145                 _irc_engine->Pools()->IrcUsers()->FreeObject(
146                         GetUser(u->Nickname()\&.c_str())
147                 );
148         }
149         _nameslist\&.clear();
150 
151         return EIrcStatus::OK;
152 }
.fi
.SS "void IrcChannel::EraseUserlist ()\fC [private]\fP"
Deletes all the \fBIrcUser\fP objects in the active userlist\&.
.PP
The protection mutex is recursive, so we can call this safely from other class functions so long as they're on the same thread\&. 
.SS "void IrcChannel::EraseUserlist ()\fC [private]\fP"
Deletes all the \fBIrcUser\fP objects in the active userlist\&.
.PP
The protection mutex is recursive, so we can call this safely from other class functions so long as they're on the same thread\&. 
.PP
Definition at line 157 of file IrcChannel\&.cc\&.
.PP
References _mutex, _userlist, and OK\&.
.PP
Referenced by Cleanup(), IrcParser::HandleKick(), IrcParser::HandlePart(), and PopulateUserlist()\&.
.PP
.nf
158 {
159         std::lock_guard<std::recursive_mutex>   lock(_mutex);
160 
161         _userlist\&.clear();
162 
163         return EIrcStatus::OK;
164 }
.fi
.SS "\fBIrcUser\fP * IrcChannel::GetUser (const char *nickname)"
Gets the \fBIrcUser\fP object from the specified connection, whose name matches nickname\&.
.PP
Will not generate an error if the specified user is not found, as this can be used for a simple search; raise your own error if this is undesired\&.
.PP
\fBWarning:\fP
.RS 4
Increments the reference counter for the user; you must call Dereference on it when finished using it, or pass it to a function that does!
.RE
.PP
\fBParameters:\fP
.RS 4
\fInickname\fP The name of the user to locate 
.RE
.PP
\fBReturns:\fP
.RS 4
If the user is not found, a nullptr is returned\&. 
.PP
A pointer to the \fBIrcUser\fP called nickname\&. 
.RE
.PP

.PP
Definition at line 169 of file IrcChannel\&.cc\&.
.PP
References IrcObject::_irc_engine, _name, IrcPool::GetUser(), Owner(), and IrcEngine::Pools()\&.
.PP
Referenced by EraseNameslist(), IrcParser::HandleKick(), IrcParser::HandleMode(), and IrcParser::HandlePart()\&.
.PP
.nf
172 {
173         return _irc_engine->Pools()->GetUser(Owner()->Id(), _name\&.c_str(), nickname);
174 }
.fi
.SS "\fBIrcUser\fP* IrcChannel::GetUser (const char *nickname)"
Gets the \fBIrcUser\fP object from the specified connection, whose name matches nickname\&.
.PP
Will not generate an error if the specified user is not found, as this can be used for a simple search; raise your own error if this is undesired\&.
.PP
\fBWarning:\fP
.RS 4
Increments the reference counter for the user; you must call Dereference on it when finished using it, or pass it to a function that does!
.RE
.PP
\fBParameters:\fP
.RS 4
\fInickname\fP The name of the user to locate 
.RE
.PP
\fBReturns:\fP
.RS 4
If the user is not found, a nullptr is returned\&. 
.PP
A pointer to the \fBIrcUser\fP called nickname\&. 
.RE
.PP

.SS "bool IrcChannel::IsActive () const"

.PP
Definition at line 179 of file IrcChannel\&.cc\&.
.PP
References _flags, _mutex, and CHANFLAG_ACTIVE\&.
.PP
.nf
180 {
181         std::lock_guard<std::recursive_mutex>   lock(_mutex);
182         return (_flags & CHANFLAG_ACTIVE);
183 }
.fi
.SS "bool IrcChannel::IsActive () const"

.SS "bool IrcChannel::IsAuthorized (const char *nickname, const uint8_tmode) const"
Looks up the \fBIrcUser\fP with a nickname of nickname, and checks if it is 'authorized' - its mode equal to or greater than that of mode\&.
.PP
\fBParameters:\fP
.RS 4
\fInickname\fP The nickname to lookup and check 
.br
\fImode\fP The mode to check 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the nickname was found and has sufficient access\&. 
.PP
false if the nickname isn't found, mode does not exist, or the user simply doesn't have the specified mode\&. 
.RE
.PP

.SS "bool IrcChannel::IsAuthorized (const std::shared_ptr< \fBIrcUser\fP >user, const uint8_tmode) const"
Checks if the \fBIrcUser\fP object user has its mode equal to or greater than that of mode\&.
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP The \fBIrcUser\fP object to check 
.br
\fImode\fP The mode to check 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the user object has sufficient access\&. 
.PP
false if the mode does not exist, or the user simply doesn't have the specified mode\&. 
.RE
.PP

.SS "bool IrcChannel::IsAuthorized (const char *nickname, const uint8_tmode) const"
Looks up the \fBIrcUser\fP with a nickname of nickname, and checks if it is 'authorized' - its mode equal to or greater than that of mode\&.
.PP
\fBParameters:\fP
.RS 4
\fInickname\fP The nickname to lookup and check 
.br
\fImode\fP The mode to check 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the nickname was found and has sufficient access\&. 
.PP
false if the nickname isn't found, mode does not exist, or the user simply doesn't have the specified mode\&. 
.RE
.PP

.SS "bool IrcChannel::IsAuthorized (const \fBIrcUser\fP *user, const uint8_tmode) const"
Checks if the \fBIrcUser\fP object user has its mode equal to or greater than that of mode\&.
.PP
\fBParameters:\fP
.RS 4
\fIuser\fP The \fBIrcUser\fP object to check 
.br
\fImode\fP The mode to check 
.RE
.PP
\fBReturns:\fP
.RS 4
true if the user object has sufficient access\&. 
.PP
false if the mode does not exist, or the user simply doesn't have the specified mode\&. 
.RE
.PP

.SS "std::string IrcChannel::Name () const"
Retrieves a copy\&. 
.PP
Definition at line 188 of file IrcChannel\&.cc\&.
.PP
References _mutex, and _name\&.
.PP
Referenced by AddNamesUser(), and IrcConnection::DeleteChannel()\&.
.PP
.nf
189 {
190         std::lock_guard<std::recursive_mutex>   lock(_mutex);
191         return _name;
192 }
.fi
.SS "std::string IrcChannel::Name () const"
Retrieves a copy\&. 
.SS "IrcChannel::NO_CLASS_ASSIGNMENT (\fBIrcChannel\fP)\fC [private]\fP"

.SS "IrcChannel::NO_CLASS_ASSIGNMENT (\fBIrcChannel\fP)\fC [private]\fP"

.SS "IrcChannel::NO_CLASS_COPY (\fBIrcChannel\fP)\fC [private]\fP"

.SS "IrcChannel::NO_CLASS_COPY (\fBIrcChannel\fP)\fC [private]\fP"

.SS "uint32_t IrcChannel::NumberOfUsers () const\fC [inline]\fP"

.PP
Definition at line 221 of file IrcChannel\&.h\&.
.PP
.nf
222         {
223                 return _userlist\&.size();
224         }
.fi
.SS "uint32_t IrcChannel::NumberOfUsers () const\fC [inline]\fP"

.PP
Definition at line 242 of file bak/IrcChannel\&.h\&.
.PP
.nf
243         {
244                 return _userlist\&.size();
245         }
.fi
.SS "\fBIrcConnection\fP * IrcChannel::Owner ()"

.PP
Definition at line 197 of file IrcChannel\&.cc\&.
.PP
References _mutex, and _owner\&.
.PP
Referenced by AddNamesUser(), and GetUser()\&.
.PP
.nf
198 {
199         std::lock_guard<std::recursive_mutex>   lock(_mutex);
200 
201         return _owner\&.lock();
202 }
.fi
.SS "\fBIrcConnection\fP* IrcChannel::Owner ()"

.SS "void IrcChannel::PopulateUserlist ()"

.PP
Definition at line 207 of file IrcChannel\&.cc\&.
.PP
References _mutex, _nameslist, _userlist, EraseUserlist(), and OK\&.
.PP
Referenced by IrcParser::Handle366()\&.
.PP
.nf
208 {
209         std::lock_guard<std::recursive_mutex>   lock(_mutex);
210 
211         // wipe out the existing userlist
212         EraseUserlist();
213         // replace it with the pre-built names list
214         for ( auto n : _nameslist )
215         {
216                 _userlist\&.insert(_userlist\&.begin(), n->Nickname());
217         }
218 
219         return EIrcStatus::OK;
220 }
.fi
.SS "void IrcChannel::PopulateUserlist ()"

.SS "std::string IrcChannel::Topic () const"

.PP
Definition at line 225 of file IrcChannel\&.cc\&.
.PP
References _mutex, and _topic\&.
.PP
.nf
226 {
227         std::lock_guard<std::recursive_mutex>   lock(_mutex);
228         return _topic;
229 }
.fi
.SS "std::string IrcChannel::Topic () const"

.SS "void IrcChannel::UpdateTopic (const char *topic)"
Sets the channel topic
.PP
\fBParameters:\fP
.RS 4
\fItopic\fP The new topic, complete with colour codes, special chars 
.RE
.PP

.PP
Definition at line 234 of file IrcChannel\&.cc\&.
.PP
References _mutex, _topic, and OK\&.
.PP
Referenced by IrcParser::Handle332(), and IrcParser::HandleTopic()\&.
.PP
.nf
237 {
238         std::lock_guard<std::recursive_mutex>   lock(_mutex);
239 
240         // we allow setting a null topic
241         _topic = topic;
242 
243         return EIrcStatus::OK;
244 }
.fi
.SS "void IrcChannel::UpdateTopic (const char *topic)"
Sets the channel topic
.PP
\fBParameters:\fP
.RS 4
\fItopic\fP The new topic, complete with colour codes, special chars 
.RE
.PP

.SS "std::set<std::string>& IrcChannel::Users ()\fC [inline]\fP"
should probably return the pool addresses rather than the strings\&.\&. 
.PP
Definition at line 263 of file IrcChannel\&.h\&.
.PP
.nf
264         {
265                 return _userlist;
266         }
.fi
.SS "std::set<\fBIrcUser\fP*>& IrcChannel::Users ()\fC [inline]\fP"

.PP
Definition at line 284 of file bak/IrcChannel\&.h\&.
.PP
.nf
285         {
286                 return _userlist;
287         }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "\fBIrcParser\fP\fC [friend]\fP"

.PP
Definition at line 39 of file IrcChannel\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "uint32_t IrcChannel::_flags\fC [private]\fP"
Channel flags 
.PP
Definition at line 44 of file IrcChannel\&.h\&.
.PP
Referenced by IrcParser::HandleJoin(), IrcParser::HandleKick(), IrcParser::HandlePart(), and IsActive()\&.
.SS "std::string IrcChannel::_key\fC [private]\fP"
Channel password, aka 'Key' 
.PP
Definition at line 46 of file IrcChannel\&.h\&.
.SS "uint16_t IrcChannel::_limit\fC [private]\fP"
User limit (max 65535 users in a channel seems fair/accurate?) 
.PP
Definition at line 45 of file IrcChannel\&.h\&.
.SS "std::recursive_mutex IrcChannel::_mutex\fC [mutable]\fP, \fC [private]\fP"
Synchronization lock; mutable to enable constness for retrieval functions 
.PP
Definition at line 57 of file IrcChannel\&.h\&.
.PP
Referenced by AddNamesUser(), AddUser(), Cleanup(), DeleteUser(), EraseNameslist(), EraseUserlist(), IsActive(), Name(), Owner(), PopulateUserlist(), Topic(), and UpdateTopic()\&.
.SS "std::string IrcChannel::_name\fC [private]\fP"
Channel name, including any prefixes 
.PP
Definition at line 47 of file IrcChannel\&.h\&.
.PP
Referenced by GetUser(), and Name()\&.
.SS "std::set< \fBIrcUser\fP * > IrcChannel::_nameslist\fC [private]\fP"
Channel userlist for receiving 353 NAMES entries 
.PP
Definition at line 54 of file IrcChannel\&.h\&.
.PP
Referenced by AddNamesUser(), EraseNameslist(), and PopulateUserlist()\&.
.SS "std::weak_ptr<\fBIrcConnection\fP> IrcChannel::_owner\fC [private]\fP"
Pointer to the owning connection 
.PP
Definition at line 49 of file IrcChannel\&.h\&.
.PP
Referenced by Owner()\&.
.SS "\fBIrcConnection\fP* IrcChannel::_parent_connection\fC [private]\fP"
Pointer to the owning connection 
.PP
Definition at line 48 of file bak/IrcChannel\&.h\&.
.SS "std::string IrcChannel::_topic\fC [private]\fP"
Channel topic (will contain colour codes) 
.PP
Definition at line 48 of file IrcChannel\&.h\&.
.PP
Referenced by Topic(), and UpdateTopic()\&.
.SS "std::set<\fBIrcUser\fP*> IrcChannel::_userlist\fC [private]\fP"
Active channel userlist 
.PP
Definition at line 51 of file bak/IrcChannel\&.h\&.
.SS "std::set<std::string> IrcChannel::_userlist\fC [private]\fP"
Active channel userlist 
.PP
Definition at line 52 of file IrcChannel\&.h\&.
.PP
Referenced by AddUser(), DeleteUser(), EraseUserlist(), and PopulateUserlist()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Social Bot Interface from the source code\&.
