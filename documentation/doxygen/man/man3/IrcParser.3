.TH "IrcParser" 3 "Mon Jun 23 2014" "Version 0.1" "Social Bot Interface" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IrcParser \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <IrcParser\&.h>\fP
.PP
Inherits \fBIrcObject\fP, and \fBIrcObject\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB~IrcParser\fP ()"
.br
.ti -1c
.RI "void \fBCleanup\fP ()"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBExtractIrcBufData\fP (const char *buffer, \fBircbuf_data\fP *data) const "
.br
.ti -1c
.RI "bool \fBHasChannelPrefix\fP (const std::shared_ptr< \fBIrcConnection\fP > connection, char *str) const "
.br
.ti -1c
.RI "bool \fBModeHasArgument\fP (const std::shared_ptr< \fBIrcConnection\fP > connection, bool is_set, char mode) const "
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBParseNextRecvQueueItem\fP (std::shared_ptr< \fBIrcConnection\fP > connection) const "
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBProcessNextSendQueueItem\fP (std::shared_ptr< \fBIrcConnection\fP > connection) const "
.br
.ti -1c
.RI "char * \fBParseParam\fP (char **data) const "
.br
.ti -1c
.RI "bool \fBParseParameters\fP (const char *buffer, uint32_t num_args,\&.\&.\&.) const "
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBSplitSender\fP (const char *buffer, \fBircbuf_sender\fP *sender) const "
.br
.ti -1c
.RI "void \fBTriggerSync\fP () const "
.br
.ti -1c
.RI "\fB~IrcParser\fP ()"
.br
.ti -1c
.RI "void \fBCleanup\fP ()"
.br
.ti -1c
.RI "bool \fBExtractIrcBufData\fP (const char *buffer, \fBircbuf_data\fP *data) const "
.br
.ti -1c
.RI "bool \fBHasChannelPrefix\fP (const \fBIrcConnection\fP *connection, char *str) const "
.br
.ti -1c
.RI "bool \fBModeHasArgument\fP (const \fBIrcConnection\fP *connection, bool is_set, char mode) const "
.br
.ti -1c
.RI "bool \fBParseNextRecvQueueItem\fP (\fBIrcConnection\fP *connection) const "
.br
.ti -1c
.RI "bool \fBProcessNextSendQueueItem\fP (\fBIrcConnection\fP *connection) const "
.br
.ti -1c
.RI "char * \fBParseParam\fP (char **data) const "
.br
.ti -1c
.RI "bool \fBParseParameters\fP (const char *buffer, uint32_t num_args,\&.\&.\&.) const "
.br
.ti -1c
.RI "bool \fBSplitSender\fP (const char *buffer, \fBircbuf_sender\fP *sender) const "
.br
.ti -1c
.RI "void \fBTriggerSync\fP () const "
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle001\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle002\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle003\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle004\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle005\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle331\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle332\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle333\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle353\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle366\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle372\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle375\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle376\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle432\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandle433\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandleCap\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandleInvite\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandleJoin\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandleKick\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandleKill\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandleMode\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandleNick\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandleNotice\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandlePart\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandlePong\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandlePrivmsg\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandleQuit\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBHandleTopic\fP (std::shared_ptr< \fBIrcConnection\fP > connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBParseConnectionQueues\fP (std::shared_ptr< \fBIrcConnection\fP > connection)"
.br
.ti -1c
.RI "\fBEIrcStatus\fP \fBRunParser\fP ()"
.br
.ti -1c
.RI "\fBIrcParser\fP ()"
.br
.ti -1c
.RI "bool \fBHandle001\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle002\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle003\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle004\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle005\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle331\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle332\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle333\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle353\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle366\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle372\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle375\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle376\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle432\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandle433\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandleCap\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandleInvite\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandleJoin\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandleKick\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandleKill\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandleMode\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandleNick\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandleNotice\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandlePart\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandlePong\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandlePrivmsg\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandleQuit\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "bool \fBHandleTopic\fP (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)"
.br
.ti -1c
.RI "uint32_t \fBParseConnectionQueues\fP (\fBIrcConnection\fP *connection)"
.br
.ti -1c
.RI "uint32_t \fBRunParser\fP ()"
.br
.ti -1c
.RI "\fBIrcParser\fP ()"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static uint32_t __stdcall \fBExecParser\fP (void *thisptr)"
.br
.ti -1c
.RI "static uint32_t __stdcall \fBExecParser\fP (void *thisptr)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBHANDLE\fP \fB_sync_event\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBIrcEngine\fP"
.br
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
All the connections queues are utilized by this class\&.
.PP
This class is NOT an \fBIrcListener\fP - it is independent, and is actually what triggers all the OnXxx methods for the listeners\&. The data must be parsed before we can notify them, after all\&.
.PP
A dedicated thread gets synchronized from an \fBIrcConnection\fP class when it gets data; the function then grabs the data from the connection queue, parses it, populates the last activity from the connection, and notifies all listeners as to the event\&.
.PP
None of the HandleXxx functions validate the input pointers, as they should be pre-validated (unless for some unknown reason you would try to call them yourself)\&.
.PP
This class has direct private access to most other objects; while this means we're strongly coupled, it enables us to update the objects at the time we're parsing the relevant data (there's no other appropriate time to do it) so it just makes it less complex without sacrificing too much in terms of maintenance of design\&. 
.PP
Definition at line 65 of file IrcParser\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "IrcParser::IrcParser ()\fC [private]\fP"

.PP
Definition at line 44 of file IrcParser\&.cc\&.
.PP
References fg_red()\&.
.PP
.nf
45 {
46 #if defined(_WIN32)
47 
48         _sync_event = CreateEvent(NULL, true, false, NULL);
49 
50         if ( _sync_event == nullptr )
51         {
52                 std::cerr << fg_red << "Failed to create the parser synchronization event; Win32 error " << GetLastError() << "\n";
53         }
54 
55 #elif defined(__linux__) || defined(BSD)
56 
57         if ( !sync_event_construct(&_sync_event) )
58         {
59                 // error already reported
60         }
61 
62 #endif
63 }
.fi
.SS "IrcParser::~IrcParser ()"

.PP
Definition at line 67 of file IrcParser\&.cc\&.
.PP
References Cleanup()\&.
.PP
.nf
68 {
69         Cleanup();
70 }
.fi
.SS "IrcParser::IrcParser ()\fC [private]\fP"

.SS "IrcParser::~IrcParser ()"

.SH "Member Function Documentation"
.PP 
.SS "void IrcParser::Cleanup ()"
Destroys the parsing thread and cleans up any other associated class data, such as the sync event\&.
.PP
Always called in the destructor\&. 
.SS "void IrcParser::Cleanup ()"
Destroys the parsing thread and cleans up any other associated class data, such as the sync event\&.
.PP
Always called in the destructor\&. 
.PP
Definition at line 75 of file IrcParser\&.cc\&.
.PP
References _sync_event, and fg_red()\&.
.PP
Referenced by IrcConnection::~IrcConnection(), and ~IrcParser()\&.
.PP
.nf
76 {
77 #if 0   // Code Removed: thread handling done by the Runtime
78 #if defined(_WIN32)
79 
80         if ( _thread != nullptr && _thread != INVALID_HANDLE_VALUE )
81         {
82                 DWORD   exit_code = 0;
83 
84                 /* give the thread 1 second to close if it's doing something */
85                 WaitForSingleObject(_thread, 1000);
86 
87                 if ( !GetExitCodeThread(_thread, &exit_code) || exit_code == STILL_ACTIVE )
88                 {
89                         /* tried to let the thread go peacefully - kill it */
90                         if ( !TerminateThread(_thread, EXIT_FAILURE) )
91                                 std::cerr << fg_red << "Failed to terminate the parser thread; Win32 error " << GetLastError();
92                 }
93 
94                 CloseHandle(_thread);
95                 _thread = nullptr;
96                 _thread_id = 0;
97         }
98 
99 #else
100 
101         /* copied from IrcConnection\&.cc::Cleanup() */
102         if ( _thread != 0 )
103         {
104                 s32             ret;
105                 timespec        wait_time;
106 
107                 wait_time\&.tv_sec = 1;
108 
109                 /* wait 1 second for the thread to finish up */
110                 ret = pthread_timedjoin_np(_thread, nullptr, &wait_time);
111 
112                 if ( ret == ETIMEDOUT )
113                 {
114                         /* tried to let the thread go peacefully - stop it */
115                         pthread_cancel(_thread);
116                         /* wait again */
117                         ret = pthread_timedjoin_np(_thread, nullptr, &wait_time);
118 
119                         if ( ret == ETIMEDOUT )
120                         {
121                                 generate_error_var_arg(EC_FunctionFailed, "Thread %d has been forcibly killed after failing to finish on request", _thread);
122 
123                                 /* second timeout, even after cancelling\&. Just
124                                  * kill it and live with any resource leaks */
125                                 pthread_kill(_thread, SIGKILL);
126                         }
127                         else if ( ret != 0 )
128                         {
129                                 generate_error_var_arg(EC_FunctionFailed, "Received errno %d after waiting for thread %d to finish", ret, _thread);
130                         }
131                 }
132 
133                 _thread = 0;
134         }
135 #endif
136 #endif  // Code Removed
137 
138 #if defined(_WIN32)
139 
140         if ( _sync_event != nullptr )
141                 CloseHandle(_sync_event);
142 
143 #elif defined(__linux__) || defined(BSD)
144 
145         if ( _sync_event\&.flag < 2 )
146         {
147                 if ( !sync_event_destroy(&_sync_event) )
148                 {
149                         /* small resource leak on failure */
150                 }
151         }
152 
153 #endif
154 }
.fi
.SS "static uint32_t __stdcall IrcParser::ExecParser (void *thisptr)\fC [static]\fP, \fC [private]\fP"
Used for creating a thread for the \fBRunParser()\fP function\&. Since we reside in a C++ class, this is necessary to be able to have it called via a new thread\&.
.PP
\fBWarning:\fP
.RS 4
Do not call manually; the internal functions and other classes will do all necessary preparation, and call Runtime::CreateThread, which in turn will execute this function\&. As a result, no safety checks are performed\&.
.RE
.PP
Runtime::CreateThread is a friend in order to call this function\&.
.PP
\fBParameters:\fP
.RS 4
\fIthisptr\fP A pointer to the \fBIrcParser\fP class 
.RE
.PP
\fBReturns:\fP
.RS 4
Always returns 0\&. Whatever happens in the called function stays unique and separate\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
Runtime::CreateThread, \fBIrcConnection::ExecEstablishConnection\fP 
.RE
.PP

.SS "uint32_t __stdcall IrcParser::ExecParser (void *thisptr)\fC [static]\fP, \fC [private]\fP"
Used for creating a thread for the \fBRunParser()\fP function\&. Since we reside in a C++ class, this is necessary to be able to have it called via a new thread\&.
.PP
\fBWarning:\fP
.RS 4
Do not call manually; the internal functions and other classes will do all necessary preparation, and call Runtime::CreateThread, which in turn will execute this function\&. As a result, no safety checks are performed\&.
.RE
.PP
Runtime::CreateThread is a friend in order to call this function\&.
.PP
\fBParameters:\fP
.RS 4
\fIthisptr\fP A pointer to the \fBIrcParser\fP class 
.RE
.PP
\fBReturns:\fP
.RS 4
Always returns 0\&. Whatever happens in the called function stays unique and separate\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
Runtime::CreateThread, \fBIrcConnection::ExecEstablishConnection\fP 
.RE
.PP

.PP
Definition at line 2531 of file IrcParser\&.cc\&.
.PP
.nf
2534 {
2535 #if defined(_WIN32)
2536         ((IrcParser*)this_ptr)->RunParser();
2537         return 0;
2538 #else
2539         ((IrcParser*)this_ptr)->RunParser();
2540         return nullptr;
2541 #endif
2542 }
.fi
.SS "bool IrcParser::ExtractIrcBufData (const char *buffer, \fBircbuf_data\fP *data) const"
Analyzes the supplied \fIbuffer\fP and extracts the sender, data-code and data, storing it in the supplied structure\&. The entire received data from the server should be input, otherwise erroneous results will be returned\&. Note that the original buffer will be modified, with inserted NUL's\&.
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP The buffer to have the data extracted from 
.br
\fIdata\fP The structure used to store the extracted data 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns EC_Success if the data is retrieved successfully, otherwise the appropriate bool will be returned\&. 
.RE
.PP

.SS "bool IrcParser::ExtractIrcBufData (const char *buffer, \fBircbuf_data\fP *data) const"
Analyzes the supplied \fIbuffer\fP and extracts the sender, data-code and data, storing it in the supplied structure\&. The entire received data from the server should be input, otherwise erroneous results will be returned\&. Note that the original buffer will be modified, with inserted NUL's\&.
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP The buffer to have the data extracted from 
.br
\fIdata\fP The structure used to store the extracted data 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns IRCS_OK if the data is retrieved successfully, otherwise the appropriate EIrcStatus will be returned\&. 
.RE
.PP

.PP
Definition at line 226 of file IrcParser\&.cc\&.
.PP
References ircbuf_data::code, ircbuf_data::data, fg_red(), InvalidParameter, MissingParameter, OK, and ircbuf_data::sender\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
230 {
231         char*   sender = (char*)&buffer[0];
232         char*   code = nullptr;
233         char*   code_data = nullptr;
234 
235         if ( buffer == nullptr )
236                 goto no_buffer;
237         if ( data == nullptr )
238                 goto no_bufdata;
239 
240         // ignore the IRC standard prefix, if supplied
241         if ( *sender == ':' )
242                 sender++;
243 
244         code = strchr(sender, ' ');
245 
246         if ( code == nullptr || *code == '\0' )
247                 goto missing_data;
248 
249         // nul-out the space, and proceed to the 'first' character
250         *code = '\0';
251         code++;
252 
253         // copy the data, up to the first space (which is now a nul)
254         data->sender    = sender;
255 
256         code_data = strchr(code, ' ');
257 
258         if ( code_data == nullptr )
259                 goto missing_data;
260 
261         *code_data = '\0';
262 
263         if ( strlen(code) == 0 )
264                 goto missing_code;
265 
266         code_data++;
267 
268         data->code      = code;
269         data->data      = code_data;
270 
271         return EIrcStatus::OK;
272 
273 no_buffer:
274         std::cerr << fg_red << "The supplied input buffer was a nullptr\n";
275         return EIrcStatus::MissingParameter;
276 no_bufdata:
277         std::cerr << fg_red << "The supplied output data store was a nullptr\n";
278         return EIrcStatus::MissingParameter;
279 missing_data:
280         std::cerr << fg_red << "Invalid buffer received; missing data: " << buffer << "\n";
281         return EIrcStatus::InvalidParameter;
282 missing_code:
283         std::cerr << fg_red << "Invalid buffer received; missing code: " << buffer << "\n";
284         return EIrcStatus::InvalidParameter;
285 }
.fi
.SS "bool IrcParser::Handle001 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 001 numeric\&.
.PP
As this is the first handler, it may contain some comments that are pertinent to some of the other handler functions, and design choices\&.
.PP
At the time of writing, this is very true in regards to the object referencing\&.\&.\&.
.PP
All the HandleXxx functions have the same structure: a return bool set as false by default, goto's on errors, and everything ends up at a cleanup label, which returns the actual return value\&. Returning is not allowed anywhere else, even if there's nothing to cleanup\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, true is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP

.PP
Definition at line 310 of file bak/IrcParser\&.cc\&.
.PP
References IrcNetwork::_client, IrcObject::_irc_engine, IrcConnection::_parent_network, IrcNetwork::_server, IrcConnection::_state, CS_Active, CS_Connecting, ircbuf_data::data, fg_red(), IrcConnection::GetActivity(), LN_001, irc_activity::message, irc_client::nickname, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), and irc_server::server\&.
.PP
.nf
315 {
316         /* RPL_WELCOME [RFC2812]
317          *
318          * Bahamut:
319          * Hybrid:
320          * inspIRCd:    :ircd\&.trezanik\&.org 001 trez :Welcome to the Trezanik IRC Network trez!tirc@dev-laptop\&.trezanik\&.org
321          * ircd-seven:
322          * ircu:
323          * ngIRCd:      :ircd\&.trezanik\&.org 001 trez :Welcome to the Internet Relay Network trez!~tirc@dev-laptop\&.trezanik\&.org
324          * snircd:
325          * Unreal:
326          */
327 
328         bool            ret = false;
329         const char*     search = " :";
330         char*           nick = nullptr;
331         char*           nick_end = nullptr;
332         char*           p = nullptr;
333         IrcNetwork*     network = connection->_parent_network;
334         irc_client*     client = &network->_client;
335         irc_server*     server = &network->_server;
336         irc_activity&   activity = connection->GetActivity();
337 
338         /* Our accessors to other variables is done by direct access, and not
339          * using the Get() methods (which cause a reference)\&.
340          * This is because the connection, which is our route through to all the
341          * other variables (whether parents or children), is already referenced
342          * as part of the connection queue parsing loop\&.
343          * As such, this class will never be deleted (with a guarantee that the
344          * parent won't be either, if our design stays true), and the entire
345          * parser/listener/notifier setup is done in a single thread, so there
346          * should be no race conditions with plugins either\&.
347          */
348 
349         /* we have full private access to most Irc objects (see the documentation
350          * for this class as to the explanation!); this applies to all the other
351          * functions here too\&. */
352         connection->_state &= ~CS_Connecting;
353         connection->_state |= CS_Active;
354 
355         // we can retrieve our active nickname and the server name at the same time
356 
357         if (( nick_end = (char*)strstr(data->data\&.c_str(), search)) == nullptr )
358                 goto invalid_data;
359 
360         // nul-terminate so we can copy our nickname - data->data
361         *nick_end = '\0';
362 
363         server->server  = sender->nickname;
364         nick = (char*)data->data\&.c_str();
365 
366         /* first confirmation of our nickname; check to make sure that the one
367          * it says we are using is what we actually requested */
368         if ( client->nickname\&.compare(nick) != 0 )
369                 goto nickname_mismatch;
370 
371         // rest of the data is still valid, to output to the user
372         p = (nick_end + 1);
373         // skip the colon
374         p++;
375 
376         // prepare the activity data, then inform our listeners
377         {
378                 activity\&.message = p;
379                 activity\&.nickname        = nick;
380 
381                 _irc_engine->NotifyListeners(LN_001, connection);
382         }
383 
384         ret = true;
385         goto cleanup;
386 
387 invalid_data:
388         std::cerr << fg_red << "The supplied data contains no nickname end: " << data->data << "\n";
389         goto cleanup;
390 nickname_mismatch:
391         std::cerr << fg_red << "Nickname mismatch: Expected '" <<
392                 client->nickname << "', got '" << data->data << "'\n";
393         goto cleanup;
394 cleanup:
395         return ret;
396 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle001 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 001 numeric\&.
.PP
As this is the first handler, it may contain some comments that are pertinent to some of the other handler functions, and design choices\&.
.PP
All the HandleXxx functions have the same structure: goto's on errors, and everything ends up at a cleanup label, which returns the actual return value\&. Returning is not allowed anywhere else, even if there's nothing to cleanup\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 310 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, CS_Active, CS_Connecting, ircbuf_data::data, fg_red(), InvalidData, LN_001, irc_activity::message, NickIsNotClient, irc_client::nickname, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), ObjectNotFound, OK, irc_server::server, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
315 {
316         /* RPL_WELCOME [RFC2812]
317          *
318          * Bahamut:
319          * Hybrid:
320          * inspIRCd:    :ircd\&.trezanik\&.org 001 trez :Welcome to the Trezanik IRC Network trez!tirc@dev-laptop\&.trezanik\&.org
321          * ircd-seven:
322          * ircu:
323          * ngIRCd:      :ircd\&.trezanik\&.org 001 trez :Welcome to the Internet Relay Network trez!~tirc@dev-laptop\&.trezanik\&.org
324          * snircd:
325          * Unreal:
326          */
327 
328         std::shared_ptr<IrcNetwork>     network = connection->Owner();
329         EIrcStatus      ret = EIrcStatus::Unknown;
330         const char*     search = " :";
331         char*           nick = nullptr;
332         char*           nick_end = nullptr;
333         char*           p = nullptr;
334         irc_activity&   activity = connection->GetActivity();
335 
336         if ( network == nullptr )
337                 goto no_network;
338 
339         irc_client*     client = &network->_client;
340         irc_server*     server = &network->_server;
341 
342         /* Our accessors to other variables is done by direct access, and not
343          * using the Get() methods (which cause a reference)\&.
344          * This is because the connection, which is our route through to all the
345          * other variables (whether parents or children), is already referenced
346          * as part of the connection queue parsing loop\&.
347          * As such, this class will never be deleted (with a guarantee that the
348          * parent won't be either, if our design stays true), and the entire
349          * parser/listener/notifier setup is done in a single thread, so there
350          * should be no race conditions with plugins either\&.
351          */
352 
353         /* we have full private access to most Irc objects (see the documentation
354          * for this class as to the explanation!); this applies to all the other
355          * functions here too\&. */
356         connection->_state &= ~CS_Connecting;
357         connection->_state |= CS_Active;
358 
359         // we can retrieve our active nickname and the server name at the same time
360 
361         if (( nick_end = (char*)strstr(data->data\&.c_str(), search)) == nullptr )
362                 goto invalid_data;
363 
364         // nul-terminate so we can copy our nickname - data->data
365         *nick_end = '\0';
366 
367         server->server  = sender->nickname;
368         nick = (char*)data->data\&.c_str();
369 
370         /* first confirmation of our nickname; check to make sure that the one
371          * it says we are using is what we actually requested */
372         if ( client->nickname\&.compare(nick) != 0 )
373                 goto nickname_mismatch;
374 
375         // rest of the data is still valid, to output to the user
376         p = (nick_end + 1);
377         // skip the colon
378         p++;
379 
380         // prepare the activity data, then inform our listeners
381         {
382                 activity\&.message = p;
383                 activity\&.nickname        = nick;
384 
385                 _irc_engine->NotifyListeners(LN_001, connection);
386         }
387 
388         ret = EIrcStatus::OK;
389         goto cleanup;
390 
391 no_network:
392         ret = EIrcStatus::ObjectNotFound;
393         goto cleanup;
394 invalid_data:
395         std::cerr << fg_red << "The supplied data contains no nickname end: " << data->data << "\n";
396         ret = EIrcStatus::InvalidData;
397         goto cleanup;
398 nickname_mismatch:
399         std::cerr << fg_red << "Nickname mismatch: Expected '" <<
400                 client->nickname << "', got '" << data->data << "'\n";
401         ret = EIrcStatus::NickIsNotClient;
402         goto cleanup;
403 cleanup:
404         return ret;
405 }
.fi
.SS "bool IrcParser::Handle002 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 002 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EC_Success is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
We can compare the host with live/config - but is storing necessary?? 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
implement LN_002 
.RE
.PP

.PP
Definition at line 401 of file bak/IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, IrcConnection::_parent_network, IrcNetwork::_server, ircbuf_data::data, fg_red(), IrcConnection::GetActivity(), irc_server::host, irc_server::ip_address, LN_002, irc_activity::message, irc_activity::nickname, and IrcEngine::NotifyListeners()\&.
.PP
.nf
406 {
407         /* RPL_YOURHOST [RFC2812]
408          *
409          * Hybrid:      :ircd\&.trezanik\&.org 002 trez :Your host is ircd\&.trezanik\&.org[192\&.168\&.134\&.20/6697], running version hybrid-7\&.2\&.3+plexus-3\&.0\&.1(20100109_0-524)
410          * InspIRCd:    :ircd\&.trezanik\&.org 002 trez :Your host is ircd\&.trezanik\&.org, running version 2\&.0
411          * ngIRCd:      :ircd\&.trezanik\&.org 002 trez :Your host is ircd\&.trezanik\&.org, running version ngircd-20\&.3 (x86_64/unknown/linux-gnu)
412          */
413 
414         bool            ret = false;
415         const char      search = ',';
416         char*           host = nullptr;
417         char*           host_end = nullptr;
418         char*           p = nullptr;
419         char*           p2 = nullptr;
420         irc_server*     server = &connection->_parent_network->_server;
421         irc_activity&   activity = connection->GetActivity();
422 
423 
424 #if 0   
425         /* IRC servers don't need to specify anything, so on 'failure' we still
426          * return true\&. Most I've seen retain a 'nice' format */
427         if (( host_end = (char*)strchr(data->data\&.c_str(), search)) == nullptr )
428                 goto no_info;
429 
430         *host_end = '\0';
431 
432         if (( host = (char*)strrchr(data->data\&.c_str(), ' ')) == nullptr )
433                 goto no_info;
434 
435         /* some ircds have the ip address + port alongside this string */
436 
437         if (( p = strchr(host, '[')) != nullptr || ( p = strchr(host, '(')) != nullptr )
438         {
439                 /* appears the IP was specified */
440                 *p = '\0';
441                 server->host    = host;
442                 p++;
443 
444                 if (( p2 = strchr(p, '/')) != nullptr || ( p2 = strchr(p, ':')) != nullptr )
445                 {
446                         /* appears the port was specified too - ignore (we have it already) */
447                         *p2 = '\0';
448                 }
449                 server->ip_address      = p;
450         }
451         else
452         {
453                 server->host    = host;
454         }
455 #endif
456 
457 #if 0   
458         // prepare the activity data, then inform our listeners
459         {
460                 activity\&.message = p;
461                 activity\&.nickname        = nick;
462 
463                 _irc_engine->NotifyListeners(LN_002, connection);
464         }
465 #endif
466 
467         ret = true;
468         goto cleanup;
469 
470 no_info:
471         std::cerr << fg_red << "The server did not supply an expected hostname string\n";
472         goto cleanup;
473 cleanup:
474         return ret;
475 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle002 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 002 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
We can compare the host with live/config - but is storing necessary?? 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
implement LN_002 
.RE
.PP

.PP
Definition at line 410 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, fg_red(), irc_server::host, InvalidData, irc_server::ip_address, LN_002, irc_activity::message, irc_activity::nickname, IrcEngine::NotifyListeners(), OK, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
415 {
416         /* RPL_YOURHOST [RFC2812]
417          *
418          * Hybrid:      :ircd\&.trezanik\&.org 002 trez :Your host is ircd\&.trezanik\&.org[192\&.168\&.134\&.20/6697], running version hybrid-7\&.2\&.3+plexus-3\&.0\&.1(20100109_0-524)
419          * InspIRCd:    :ircd\&.trezanik\&.org 002 trez :Your host is ircd\&.trezanik\&.org, running version 2\&.0
420          * ngIRCd:      :ircd\&.trezanik\&.org 002 trez :Your host is ircd\&.trezanik\&.org, running version ngircd-20\&.3 (x86_64/unknown/linux-gnu)
421          */
422 
423         EIrcStatus      ret = EIrcStatus::Unknown;
424         const char      search = ',';
425         char*           host = nullptr;
426         char*           host_end = nullptr;
427         char*           p = nullptr;
428         char*           p2 = nullptr;
429         irc_server*     server = &connection->Owner()->_server;
430         irc_activity&   activity = connection->GetActivity();
431 
432 
433 #if 0   
434         /* IRC servers don't need to specify anything, so on 'failure' we still
435          * return true\&. Most I've seen retain a 'nice' format */
436         if (( host_end = (char*)strchr(data->data\&.c_str(), search)) == nullptr )
437                 goto no_info;
438 
439         *host_end = '\0';
440 
441         if (( host = (char*)strrchr(data->data\&.c_str(), ' ')) == nullptr )
442                 goto no_info;
443 
444         // some ircds have the ip address + port alongside this string
445 
446         if (( p = strchr(host, '[')) != nullptr || ( p = strchr(host, '(')) != nullptr )
447         {
448                 // appears the IP was specified
449                 *p = '\0';
450                 server->host    = host;
451                 p++;
452 
453                 if (( p2 = strchr(p, '/')) != nullptr || ( p2 = strchr(p, ':')) != nullptr )
454                 {
455                         // appears the port was specified too - ignore (we have it already)
456                         *p2 = '\0';
457                 }
458                 server->ip_address      = p;
459         }
460         else
461         {
462                 server->host    = host;
463         }
464 #endif
465 
466 #if 0   
467         // prepare the activity data, then inform our listeners
468         {
469                 activity\&.message = p;
470                 activity\&.nickname        = nick;
471 
472                 _irc_engine->NotifyListeners(LN_002, connection);
473         }
474 #endif
475 
476         ret = EIrcStatus::OK;
477         goto cleanup;
478 
479 no_info:
480         std::cerr << fg_red << "The server did not supply an expected hostname string\n";
481         ret = EIrcStatus::InvalidData;
482         goto cleanup;
483 cleanup:
484         return ret;
485 }
.fi
.SS "bool IrcParser::Handle003 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 003 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EC_Success is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP

.PP
Definition at line 480 of file bak/IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, IrcConnection::GetActivity(), irc_activity::instigator, LN_003, irc_activity::message, irc_activity::nickname, ircbuf_sender::nickname, and IrcEngine::NotifyListeners()\&.
.PP
.nf
485 {
486         /* RPL_CREATED [RFC2812]
487          *
488          * Hybrid:      :
489          * ngIRCd:      :ircd\&.trezanik\&.org 003 trez :This server has been started Sat Oct 19 2013 at 23:42:23 (BST)
490          */
491 
492         bool            ret = false;
493         irc_activity&   activity = connection->GetActivity();
494         const char*     p = strchr(data->data\&.c_str(), ':');     // skip our nick
495 
496         if ( p != nullptr )
497                 p++;
498 
499         // prepare the activity data, then inform our listeners
500         {
501                 activity\&.message = p;
502                 activity\&.instigator\&.nickname      = sender->nickname;
503 
504                 _irc_engine->NotifyListeners(LN_003, connection);
505         }
506 
507         ret = true;
508         goto cleanup;
509 
510 cleanup:
511         return ret;
512 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle003 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 003 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 490 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, irc_activity::instigator, LN_003, irc_activity::message, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), OK, and Unknown\&.
.PP
.nf
495 {
496         /* RPL_CREATED [RFC2812]
497          *
498          * Hybrid:      :
499          * ngIRCd:      :ircd\&.trezanik\&.org 003 trez :This server has been started Sat Oct 19 2013 at 23:42:23 (BST)
500          */
501 
502         EIrcStatus      ret = EIrcStatus::Unknown;
503         irc_activity&   activity = connection->GetActivity();
504         const char*     p = strchr(data->data\&.c_str(), ':');     // skip our nick
505 
506         if ( p != nullptr )
507                 p++;
508 
509         // prepare the activity data, then inform our listeners
510         {
511                 activity\&.message = p;
512                 activity\&.instigator\&.nickname      = sender->nickname;
513 
514                 _irc_engine->NotifyListeners(LN_003, connection);
515         }
516 
517         ret = EIrcStatus::OK;
518         goto cleanup;
519 
520 cleanup:
521         return ret;
522 }
.fi
.SS "bool IrcParser::Handle004 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 004 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EC_Success is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP

.PP
Definition at line 517 of file bak/IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, IrcConnection::GetActivity(), irc_activity::instigator, LN_004, irc_activity::message, irc_activity::nickname, ircbuf_sender::nickname, and IrcEngine::NotifyListeners()\&.
.PP
.nf
522 {
523         /* RPL_MYINFO [RFC2812]
524          *
525          * Hybrid:      :
526          * ngIRCd:      :ircd\&.trezanik\&.org 004 trez ircd\&.trezanik\&.org ngircd-20\&.3 abBcCioqrRswx abehiIklmMnoOPqQrRstvVz
527          */
528 
529         bool            ret = false;
530         irc_activity&   activity = connection->GetActivity();
531         const char*     p = strchr(data->data\&.c_str(), ' ');     // skip our nick
532 
533         if ( p != nullptr )
534                 p++;
535 
536         // prepare the activity data, then inform our listeners
537         {
538                 activity\&.message = p;
539                 activity\&.instigator\&.nickname      = sender->nickname;
540 
541                 _irc_engine->NotifyListeners(LN_004, connection);
542         }
543 
544         ret = true;
545         goto cleanup;
546 
547 cleanup:
548         return ret;
549 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle004 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 004 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 527 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, irc_activity::instigator, LN_004, irc_activity::message, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), OK, and Unknown\&.
.PP
.nf
532 {
533         /* RPL_MYINFO [RFC2812]
534          *
535          * Hybrid:      :
536          * ngIRCd:      :ircd\&.trezanik\&.org 004 trez ircd\&.trezanik\&.org ngircd-20\&.3 abBcCioqrRswx abehiIklmMnoOPqQrRstvVz
537          */
538 
539         EIrcStatus      ret = EIrcStatus::Unknown;
540         irc_activity&   activity = connection->GetActivity();
541         const char*     p = strchr(data->data\&.c_str(), ' ');     // skip our nick
542 
543         if ( p != nullptr )
544                 p++;
545 
546         // prepare the activity data, then inform our listeners
547         {
548                 activity\&.message = p;
549                 activity\&.instigator\&.nickname      = sender->nickname;
550 
551                 _irc_engine->NotifyListeners(LN_004, connection);
552         }
553 
554         ret = EIrcStatus::OK;
555         goto cleanup;
556 
557 cleanup:
558         return ret;
559 }
.fi
.SS "bool IrcParser::Handle005 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 005 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EC_Success is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
Use the rest of the RFC definitions on the variables not set by the server\&. Since Handle005 can be called more than once, we don't want to assign anything in there, in case they will be overwritten or otherwise cause issues - hence we apply the defaults once the server has ceased presenting itself to us\&. 
.RE
.PP

.PP
Definition at line 554 of file bak/IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, IrcConnection::_parent_network, IrcNetwork::_server, irc_server::chan_mode_chars, irc_server::chan_mode_symbols, irc_server::chan_types, irc_activity::data, ircbuf_data::data, fg_red(), FREE, IrcConnection::GetActivity(), irc_activity::instigator, IrcConnection::IsActive(), LN_005, MALLOC, irc_server::max_len_away, irc_server::max_len_channel, irc_server::max_len_kickmsg, irc_server::max_len_nick, irc_server::max_len_topic, irc_server::max_num_modes, irc_activity::message, irc_server::network, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), RFC1459_MODES, str_token(), strlcpy(), irc_server::supported_modes_A, irc_server::supported_modes_B, irc_server::supported_modes_C, and irc_server::supported_modes_D\&.
.PP
.nf
559 {
560         /* RPL_ISUPPORT [draft-brocklesby-irc-isupport-03; de-facto standard, deprecates RFC2812 005 RPL_BOUNCE]
561          *
562          * InspIRCd:    :ircd\&.trezanik\&.org 005 trez AWAYLEN=200 CASEMAPPING=rfc1459 CHANMODES=b,k,l,imnpst CHANNELLEN=64 CHANTYPES=# CHARSET=ascii ELIST=MU FNC KICKLEN=255 MAP MAXBANS=60 MAXCHANNELS=20 MAXPARA=32 :are supported by this server
563                         :ircd\&.trezanik\&.org 005 trez MAXTARGETS=20 MODES=20 NETWORK=Trezanik NICKLEN=31 PREFIX=(ov)@+ STATUSMSG=@+ TOPICLEN=307 VBANLIST WALLCHOPS WALLVOICES :are supported by this server
564          * ngIRCd:      :ircd\&.trezanik\&.org 005 trez RFC2812 IRCD=ngIRCd CHARSET=UTF-8 CASEMAPPING=ascii PREFIX=(qaohv)~&@%+ CHANTYPES=#&+ CHANMODES=beI,k,l,imMnOPQRstVz CHANLIMIT=#&+:10 :are supported on this server
565                         :ircd\&.trezanik\&.org 005 trez CHANNELLEN=50 NICKLEN=9 TOPICLEN=490 AWAYLEN=127 KICKLEN=400 MODES=5 MAXLIST=beI:50 EXCEPTS=e INVEX=I PENALTY :are supported on this server
566          */
567 
568         bool    ret = false;
569         char    delim[] = " ";
570         char    search = ' ';
571         char*   p = nullptr;
572         char*   str = nullptr;
573         char*   last = nullptr;
574         char*   nick_end = nullptr;
575         char*   dup = nullptr;
576         uint32_t        alloc;
577         IrcNetwork*     network;
578         irc_activity&   activity = connection->GetActivity();
579 
580         if ( !connection->IsActive() )
581                 goto incorrect_state;
582 
583         network = connection->_parent_network;
584 
585         /* duplicate the buffer so str_token can modify it without affecting the
586          * original recv contents\&. */
587 
588         alloc = data->data\&.length() + 1;
589         dup = (char*)MALLOC(alloc);
590         
591         if ( dup == nullptr )
592                 throw std::bad_alloc();
593 
594         strlcpy(dup, data->data\&.c_str(), alloc);
595         str = dup;
596 
597         p = str_token(str, delim, &last);
598 
599         while ( p != nullptr )
600         {
601                 // commented examples are from a standard connection to Rizon
602 
603                 // end of the list for this message
604                 if ( *p == ':' )
605                         break;
606 
607                 if ( strncmp(p, "NETWORK=", 8) == 0 )           // NETWORK=Rizon
608                         network->_server\&.network = (p+8);
609                 else if ( strncmp(p, "CHANTYPES=", 10) == 0 )   // CHANTYPES=#
610                         network->_server\&.chan_types = (p+10);
611                 else if ( strncmp(p, "NICKLEN=", 8) == 0 )      // NICKLEN=30
612                         network->_server\&.max_len_nick = (uint16_t)atoi((p+8));
613                 else if ( strncmp(p, "KICKLEN=", 8) == 0 )      // KICKLEN=160
614                         network->_server\&.max_len_kickmsg = (uint16_t)atoi((p+8));
615                 else if ( strncmp(p, "CHANNELLEN=", 11) == 0 )  // CHANNELLEN=50
616                         network->_server\&.max_len_channel = (uint16_t)atoi((p+11));
617                 else if ( strncmp(p, "AWAYLEN=", 8) == 0 )      // AWAYLEN=160
618                         network->_server\&.max_len_away = (uint16_t)atoi((p+8));
619                 else if ( strncmp(p, "MODES=", 6) == 0 )        // MODES=4
620                         network->_server\&.max_num_modes = (uint16_t)atoi((p+6));
621                 else if ( strncmp(p, "TOPICLEN=", 9) == 0 )     // TOPICLEN=390
622                         network->_server\&.max_len_topic = (uint16_t)atoi((p+9));
623                 else if ( strncmp(p, "PREFIX=", 7) == 0 )       // PREFIX=(qaohv)~&@%+
624                 {
625                         char*   psz = (p+7);
626                         size_t  len = strlen(psz);
627 
628                         if ( psz == nullptr || *psz != '(' )
629                         {
630                                 std::cerr << fg_red << "PREFIX is invalid; expected opening bracket in '" << p << "'\n";
631                                 goto invalid_data;
632                         }
633                         while ( *psz != ')' && len )
634                         {
635                                 psz++;
636                                 --len;
637                         }
638                         if ( len == 0 )
639                         {
640                                 std::cerr << fg_red << "PREFIX is invalid; no closing bracket in '" << p << "'\n";
641                                 goto invalid_data;
642                         }
643                         if ( psz == (p+8) )
644                         {
645                                 std::cerr << fg_red << "PREFIX is invalid; no prefixes specified in '" << p << "'\n";
646                                 goto invalid_data;
647                         }
648 
649                         // nul-terminate the prefix list
650                         *psz = '\0';
651                         // copy the contents, skipping the opening bracket
652                         network->_server\&.chan_mode_chars = (p+8);
653                         // move up to the user modes
654                         if ( *++psz == '\0' )
655                         {
656                                 std::cerr << fg_red << "PREFIX is invalid; no modes after prefix list in '" << p << "'\n";
657                                 goto invalid_data;
658                         }
659                         // and copy these contents
660                         network->_server\&.chan_mode_symbols       = psz;
661                 }
662                 else if ( strncmp(p, "CHANLIMIT=", 10) == 0 )   // CHANLIMIT=#:75
663                 {
664                         //network->_server\&.max_num_channels = (u16)atoi((p+10));
665                 }
666                 else if ( strncmp(p, "CHANMODES=", 10) == 0 )   // CHANMODES=eIb,k,l,BMNORScimnpstz
667                 {
668                         char    buffer[56];
669                         char    cm_delim[] = ",";
670                         char*   psz = (p+10);
671                         char*   cm_last = nullptr;
672                         uint32_t        ui = 0;
673 
674                         if ( strlen(psz) > 55 )  // a-z, A-Z, and 3 commas
675                         {
676                                 std::cerr << fg_red << "CHANMODES data exceeds possible limit: '" << p << "'\n";
677                                 goto invalid_data;
678                         }
679 
680                         strlcpy(buffer, psz, sizeof(buffer));
681                         psz = str_token(buffer, cm_delim, &cm_last);
682 
683                         while ( psz != nullptr )
684                         {
685                                 switch ( ui )
686                                 {
687                                 case 0:
688                                         network->_server\&.supported_modes_A = psz;
689                                         break;
690                                 case 1:
691                                         network->_server\&.supported_modes_B = psz;
692                                         break;
693                                 case 2:
694                                         network->_server\&.supported_modes_C = psz;
695                                         break;
696                                 case 3:
697                                         network->_server\&.supported_modes_D = psz;
698                                         break;
699                                         /* further advancements in the protocol,
700                                          * if any, can be added here */
701                                 default:
702                                         std::cerr << fg_red << "More chanmode types reported (" << ui << ") than the known amount (4)\n";
703                                         break;
704                                 }
705 
706                                 ++ui;
707                                 psz = str_token(nullptr, cm_delim, &cm_last);
708                         }
709                 }
710 
711                 p = str_token(nullptr, delim, &last);
712         }
713 
720         if ( network->_server\&.max_num_modes == 0 )
721                 network->_server\&.max_num_modes = RFC1459_MODES;
722 
723 
724 
725         if (( nick_end = (char*)strchr(data->data\&.c_str(), search)) == nullptr )
726                 goto invalid_data;
727         // data->data now nul terminates at the end of the nickname
728         *nick_end = '\0';
729 
730         // move nick_end to the first character of the 'supported'
731         nick_end++;
732 
733         if (( p = strchr(nick_end, ':')) == nullptr )
734                 goto invalid_data;
735 
736         // nul the end of the 'supported', which just leaves the message
737         *p = '\0';
738         p++;
739 
740         // prepare the activity data, then inform our listeners
741         {
742                 activity\&.data                    = nick_end;
743                 activity\&.message         = p;
744                 activity\&.instigator\&.nickname      = sender->nickname;
745 
746                 _irc_engine->NotifyListeners(LN_005, connection);
747         }
748 
749         ret = true;
750         goto cleanup;
751 
752 incorrect_state:
753         std::cerr << fg_red << "The connection state is invalid; not active\n";
754         goto cleanup;
755 invalid_data:
756         goto cleanup;
757 cleanup:
758         FREE(dup);
759         return ret;
760 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle005 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 005 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
Use the rest of the RFC definitions on the variables not set by the server\&. Since Handle005 can be called more than once, we don't want to assign anything in there, in case they will be overwritten or otherwise cause issues - hence we apply the defaults once the server has ceased presenting itself to us\&. 
.RE
.PP

.PP
Definition at line 564 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, irc_activity::data, ircbuf_data::data, fg_red(), FREE, irc_activity::instigator, InvalidData, InvalidState, LN_005, MALLOC, irc_activity::message, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), OK, RFC1459_MODES, str_token(), strlcpy(), and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
569 {
570         /* RPL_ISUPPORT [draft-brocklesby-irc-isupport-03; de-facto standard, deprecates RFC2812 005 RPL_BOUNCE]
571          *
572          * InspIRCd:    :ircd\&.trezanik\&.org 005 trez AWAYLEN=200 CASEMAPPING=rfc1459 CHANMODES=b,k,l,imnpst CHANNELLEN=64 CHANTYPES=# CHARSET=ascii ELIST=MU FNC KICKLEN=255 MAP MAXBANS=60 MAXCHANNELS=20 MAXPARA=32 :are supported by this server
573                         :ircd\&.trezanik\&.org 005 trez MAXTARGETS=20 MODES=20 NETWORK=Trezanik NICKLEN=31 PREFIX=(ov)@+ STATUSMSG=@+ TOPICLEN=307 VBANLIST WALLCHOPS WALLVOICES :are supported by this server
574          * ngIRCd:      :ircd\&.trezanik\&.org 005 trez RFC2812 IRCD=ngIRCd CHARSET=UTF-8 CASEMAPPING=ascii PREFIX=(qaohv)~&@%+ CHANTYPES=#&+ CHANMODES=beI,k,l,imMnOPQRstVz CHANLIMIT=#&+:10 :are supported on this server
575                         :ircd\&.trezanik\&.org 005 trez CHANNELLEN=50 NICKLEN=9 TOPICLEN=490 AWAYLEN=127 KICKLEN=400 MODES=5 MAXLIST=beI:50 EXCEPTS=e INVEX=I PENALTY :are supported on this server
576          */
577 
578         std::shared_ptr<IrcNetwork>     network;
579         EIrcStatus      ret = EIrcStatus::Unknown;
580         char            delim[] = " ";
581         char            search = ' ';
582         char*           p = nullptr;
583         char*           str = nullptr;
584         char*           last = nullptr;
585         char*           nick_end = nullptr;
586         char*           dup = nullptr;
587         uint32_t        alloc;
588         irc_activity&   activity = connection->GetActivity();
589 
590         if ( !connection->IsActive() )
591                 goto incorrect_state;
592 
593         network = connection->Owner();
594 
595         /* duplicate the buffer so str_token can modify it without affecting the
596          * original recv contents\&. */
597 
598         alloc = data->data\&.length() + 1;
599         dup = (char*)MALLOC(alloc);
600         
601         if ( dup == nullptr )
602                 throw std::bad_alloc();
603 
604         strlcpy(dup, data->data\&.c_str(), alloc);
605         str = dup;
606 
607         p = str_token(str, delim, &last);
608 
609         while ( p != nullptr )
610         {
611                 // commented examples are from a standard connection to Rizon
612 
613                 // end of the list for this message
614                 if ( *p == ':' )
615                         break;
616 
617                 if ( strncmp(p, "NETWORK=", 8) == 0 )           // NETWORK=Rizon
618                         network->_server\&.network = (p+8);
619                 else if ( strncmp(p, "CHANTYPES=", 10) == 0 )   // CHANTYPES=#
620                         network->_server\&.chan_types = (p+10);
621                 else if ( strncmp(p, "NICKLEN=", 8) == 0 )      // NICKLEN=30
622                         network->_server\&.max_len_nick = (uint16_t)atoi((p+8));
623                 else if ( strncmp(p, "KICKLEN=", 8) == 0 )      // KICKLEN=160
624                         network->_server\&.max_len_kickmsg = (uint16_t)atoi((p+8));
625                 else if ( strncmp(p, "CHANNELLEN=", 11) == 0 )  // CHANNELLEN=50
626                         network->_server\&.max_len_channel = (uint16_t)atoi((p+11));
627                 else if ( strncmp(p, "AWAYLEN=", 8) == 0 )      // AWAYLEN=160
628                         network->_server\&.max_len_away = (uint16_t)atoi((p+8));
629                 else if ( strncmp(p, "MODES=", 6) == 0 )        // MODES=4
630                         network->_server\&.max_num_modes = (uint16_t)atoi((p+6));
631                 else if ( strncmp(p, "TOPICLEN=", 9) == 0 )     // TOPICLEN=390
632                         network->_server\&.max_len_topic = (uint16_t)atoi((p+9));
633                 else if ( strncmp(p, "PREFIX=", 7) == 0 )       // PREFIX=(qaohv)~&@%+
634                 {
635                         char*   psz = (p+7);
636                         size_t  len = strlen(psz);
637 
638                         if ( psz == nullptr || *psz != '(' )
639                         {
640                                 std::cerr << fg_red << "PREFIX is invalid; expected opening bracket in '" << p << "'\n";
641                                 goto invalid_data;
642                         }
643                         while ( *psz != ')' && len )
644                         {
645                                 psz++;
646                                 --len;
647                         }
648                         if ( len == 0 )
649                         {
650                                 std::cerr << fg_red << "PREFIX is invalid; no closing bracket in '" << p << "'\n";
651                                 goto invalid_data;
652                         }
653                         if ( psz == (p+8) )
654                         {
655                                 std::cerr << fg_red << "PREFIX is invalid; no prefixes specified in '" << p << "'\n";
656                                 goto invalid_data;
657                         }
658 
659                         // nul-terminate the prefix list
660                         *psz = '\0';
661                         // copy the contents, skipping the opening bracket
662                         network->_server\&.chan_mode_chars = (p+8);
663                         // move up to the user modes
664                         if ( *++psz == '\0' )
665                         {
666                                 std::cerr << fg_red << "PREFIX is invalid; no modes after prefix list in '" << p << "'\n";
667                                 goto invalid_data;
668                         }
669                         // and copy these contents
670                         network->_server\&.chan_mode_symbols       = psz;
671                 }
672                 else if ( strncmp(p, "CHANLIMIT=", 10) == 0 )   // CHANLIMIT=#:75
673                 {
674                         //network->_server\&.max_num_channels = (u16)atoi((p+10));
675                 }
676                 else if ( strncmp(p, "CHANMODES=", 10) == 0 )   // CHANMODES=eIb,k,l,BMNORScimnpstz
677                 {
678                         char    buffer[56];
679                         char    cm_delim[] = ",";
680                         char*   psz = (p+10);
681                         char*   cm_last = nullptr;
682                         uint32_t        ui = 0;
683 
684                         if ( strlen(psz) > 55 )  // a-z, A-Z, and 3 commas
685                         {
686                                 std::cerr << fg_red << "CHANMODES data exceeds possible limit: '" << p << "'\n";
687                                 goto invalid_data;
688                         }
689 
690                         strlcpy(buffer, psz, sizeof(buffer));
691                         psz = str_token(buffer, cm_delim, &cm_last);
692 
693                         while ( psz != nullptr )
694                         {
695                                 switch ( ui )
696                                 {
697                                 case 0:
698                                         network->_server\&.supported_modes_A = psz;
699                                         break;
700                                 case 1:
701                                         network->_server\&.supported_modes_B = psz;
702                                         break;
703                                 case 2:
704                                         network->_server\&.supported_modes_C = psz;
705                                         break;
706                                 case 3:
707                                         network->_server\&.supported_modes_D = psz;
708                                         break;
709                                         /* further advancements in the protocol,
710                                          * if any, can be added here */
711                                 default:
712                                         std::cerr << fg_red << "More chanmode types reported (" << ui << ") than the known amount (4)\n";
713                                         break;
714                                 }
715 
716                                 ++ui;
717                                 psz = str_token(nullptr, cm_delim, &cm_last);
718                         }
719                 }
720 
721                 p = str_token(nullptr, delim, &last);
722         }
723 
730         if ( network->_server\&.max_num_modes == 0 )
731                 network->_server\&.max_num_modes = RFC1459_MODES;
732 
733 
734 
735         if (( nick_end = (char*)strchr(data->data\&.c_str(), search)) == nullptr )
736                 goto invalid_data;
737         // data->data now nul terminates at the end of the nickname
738         *nick_end = '\0';
739 
740         // move nick_end to the first character of the 'supported'
741         nick_end++;
742 
743         if (( p = strchr(nick_end, ':')) == nullptr )
744                 goto invalid_data;
745 
746         // nul the end of the 'supported', which just leaves the message
747         *p = '\0';
748         p++;
749 
750         // prepare the activity data, then inform our listeners
751         {
752                 activity\&.data                    = nick_end;
753                 activity\&.message         = p;
754                 activity\&.instigator\&.nickname      = sender->nickname;
755 
756                 _irc_engine->NotifyListeners(LN_005, connection);
757         }
758 
759         ret = EIrcStatus::OK;
760         goto cleanup;
761 
762 incorrect_state:
763         std::cerr << fg_red << "The connection state is invalid; not active\n";
764         ret = EIrcStatus::InvalidState;
765         goto cleanup;
766 invalid_data:
767         ret = EIrcStatus::InvalidData;
768         goto cleanup;
769 cleanup:
770         FREE(dup);
771         return ret;
772 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle331 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 331 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.SS "bool IrcParser::Handle331 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 331 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EC_Success is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP

.SS "\fBEIrcStatus\fP IrcParser::Handle332 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 332 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP
should we be generating an error? 332 could have no channel? 
.PP
Definition at line 777 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, irc_activity::channel_name, irc_activity::data, ircbuf_data::data, FREE, LN_332, IrcEngine::NotifyListeners(), OK, ParseParameters(), and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
782 {
783         std::shared_ptr<IrcChannel>     channel = nullptr;
784         EIrcStatus      ret = EIrcStatus::Unknown;
785         char*           extracted_channel = nullptr;
786         char*           extracted_nick = nullptr;
787         char*           extracted_topic = nullptr;
788         irc_activity&   activity = connection->GetActivity();
789 
790         if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_nick, &extracted_channel, &extracted_topic) )
791                 goto parse_failure;
792 
793         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
794                 goto channel_not_found;
795 
796         channel->UpdateTopic(extracted_topic);
797 
798         // prepare the activity data, then inform our listeners
799         {
800                 activity\&.channel_name    = extracted_channel;
801                 activity\&.data            = extracted_topic;
802 
803                 _irc_engine->NotifyListeners(LN_332, connection);
804         }
805 
806         ret = EIrcStatus::OK;
807         goto cleanup;
808 
809 parse_failure:
810         goto cleanup;
811 channel_not_found:
813         goto cleanup;
814 cleanup:
815         FREE(extracted_nick);
816         FREE(extracted_channel);
817         FREE(extracted_topic);
818         return ret;
819 }
.fi
.SS "bool IrcParser::Handle332 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 332 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EC_Success is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP
should we be generating an error? 332 could have no channel? 
.PP
Definition at line 765 of file bak/IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, irc_activity::channel_name, irc_activity::data, ircbuf_data::data, FREE, IrcConnection::GetActivity(), IrcConnection::GetChannel(), LN_332, IrcEngine::NotifyListeners(), ParseParameters(), UNREFERENCE_OBJECT, and IrcChannel::UpdateTopic()\&.
.PP
.nf
770 {
771         bool            ret = false;
772         IrcChannel*     channel = nullptr;
773         char*           extracted_channel = nullptr;
774         char*           extracted_nick = nullptr;
775         char*           extracted_topic = nullptr;
776         irc_activity&   activity = connection->GetActivity();
777 
778         if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_nick, &extracted_channel, &extracted_topic) )
779                 goto parse_failure;
780 
781         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
782                 goto channel_not_found;
783 
784         channel->UpdateTopic(extracted_topic);
785 
786         // prepare the activity data, then inform our listeners
787         {
788                 activity\&.channel_name    = extracted_channel;
789                 activity\&.data            = extracted_topic;
790 
791                 _irc_engine->NotifyListeners(LN_332, connection);
792         }
793 
794         ret = true;
795         goto cleanup;
796 
797 parse_failure:
798         goto cleanup;
799 channel_not_found:
801         goto cleanup;
802 cleanup:
803         if ( channel != nullptr )
804                 UNREFERENCE_OBJECT(channel);
805         FREE(extracted_nick);
806         FREE(extracted_channel);
807         FREE(extracted_topic);
808         return ret;
809 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle333 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 333 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
check - 3 param, 1st = channel used to work fine, now there's an extra nick\&.\&. 
.RE
.PP

.PP
Definition at line 824 of file IrcParser\&.cc\&.
.PP
References ircbuf_data::data, fg_red(), FREE, ObjectNotFound, OK, ParseParameters(), ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
829 {
830         std::shared_ptr<IrcChannel>     channel = nullptr;
831         EIrcStatus      ret = EIrcStatus::Unknown;
832         char*           extracted_channel = nullptr;
833         char*           extracted_setter = nullptr;
834         char*           extracted_datetime = nullptr;
835         irc_activity&   activity = connection->GetActivity();
836 
837         // :irc\&.siglost\&.com 333 trez #torze Torze!~quassel@staff\&.x22cheats\&.com 1349201058
838 
840         //if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_channel, &extracted_setter, &extracted_datetime) )
841         if ( !ParseParameters(data->data\&.c_str(), 4, nullptr, &extracted_channel, &extracted_setter, &extracted_datetime) )
842                 goto parse_failure;
843 
844         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
845                 goto channel_not_found;
846 
847         // prepare the activity data, then inform our listeners
848         {
849 
850 
851                 //_irc_engine->NotifyListeners(LN_333, connection);
852         }
853 
854         ret = EIrcStatus::OK;
855         goto cleanup;
856 
857 parse_failure:
858         ret = EIrcStatus::ParsingError;
859         goto cleanup;
860 channel_not_found:
861         std::cerr << fg_red << "The extracted channel '" << extracted_channel << "' could not be found\n";
862         ret = EIrcStatus::ObjectNotFound;
863         goto cleanup;
864 cleanup:
865         FREE(extracted_setter);
866         FREE(extracted_channel);
867         FREE(extracted_datetime);
868         return ret;
869 }
.fi
.SS "bool IrcParser::Handle333 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 333 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EC_Success is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
check - 3 param, 1st = channel used to work fine, now there's an extra nick\&.\&. 
.RE
.PP

.PP
Definition at line 814 of file bak/IrcParser\&.cc\&.
.PP
References ircbuf_data::data, fg_red(), FREE, IrcConnection::GetActivity(), IrcConnection::GetChannel(), ParseParameters(), and UNREFERENCE_OBJECT\&.
.PP
.nf
819 {
820         bool            ret = false;
821         IrcChannel*     channel = nullptr;
822         char*           extracted_channel = nullptr;
823         char*           extracted_setter = nullptr;
824         char*           extracted_datetime = nullptr;
825         irc_activity&   activity = connection->GetActivity();
826 
827         // :irc\&.siglost\&.com 333 trez #torze Torze!~quassel@staff\&.x22cheats\&.com 1349201058
828 
830         //if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_channel, &extracted_setter, &extracted_datetime) )
831         if ( !ParseParameters(data->data\&.c_str(), 4, nullptr, &extracted_channel, &extracted_setter, &extracted_datetime) )
832                 goto parse_failure;
833 
834         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
835                 goto channel_not_found;
836 
837         // prepare the activity data, then inform our listeners
838         {
839 
840 
841                 //_irc_engine->NotifyListeners(LN_333, connection);
842         }
843 
844         ret = true;
845         goto cleanup;
846 
847 parse_failure:
848         /* error already generated */
849         goto cleanup;
850 channel_not_found:
851         /* error not generated */
852         std::cerr << fg_red << "The extracted channel '" << extracted_channel << "' could not be found\n";
853         goto cleanup;
854 cleanup:
855         if ( channel != nullptr )
856                 UNREFERENCE_OBJECT(channel);
857         FREE(extracted_setter);
858         FREE(extracted_channel);
859         FREE(extracted_datetime);
860         return ret;
861 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle353 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 353 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
grab prefix meanings from config 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
send a 353 for each individual nick, or the whole message? 
.RE
.PP

.PP
Definition at line 874 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, irc_server::chan_mode_chars, irc_server::chan_mode_symbols, ircbuf_data::data, mode_update::erase_existing, fg_red(), FREE, ircbuf_sender::hostmask, ircbuf_sender::ident, InvalidData, LN_353, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), ObjectNotFound, OK, ParseParameters(), ParsingError, SplitSender(), str_token(), mode_update::to_add, mode_update::to_remove, UM_Admin, UM_HalfOp, UM_None, UM_Op, UM_Owner, UM_Unknown, UM_Voice, Unknown, and UnknownResponse\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
879 {
880         std::shared_ptr<IrcChannel>     channel = nullptr;
881         EIrcStatus      ret = EIrcStatus::Unknown;
882         char*           extracted_type = nullptr;
883         char*           extracted_channel = nullptr;
884         char*           extracted_names = nullptr;
885         char*           extracted_nick = nullptr;
886         char*           p = nullptr;
887         char*           last = nullptr;
888         char            delim[] = " ";
889         uint32_t        num_prefix;
890         uint32_t        i;
891         irc_server*     server = nullptr;
892         ircbuf_sender   user;
893         mode_update     umu;
894         irc_activity&   activity = connection->GetActivity();
895 
896         if ( !ParseParameters(data->data\&.c_str(), 4,
897                 &extracted_nick, &extracted_type, &extracted_channel, &extracted_names) )
898         {
899                 goto parse_failure;
900         }
901 
902         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
903                 goto channel_not_found;
904 
905 
906         server = &connection->Owner()->_server;
907 
908         if ( server->chan_mode_chars\&.empty() || server->chan_mode_symbols\&.empty() )
909                 goto unknown_prefixes;
910 
911         num_prefix = server->chan_mode_symbols\&.length();
912 
913         p = str_token(extracted_names, delim, &last);
914 
915         while ( p != nullptr )
916         {
917                 umu\&.erase_existing       = false;
918                 umu\&.to_add               = UM_None;
919                 umu\&.to_remove            = UM_None;
920 
921                 for ( i = 0; i < num_prefix; i++ )
922                 {
923                         if ( *p == server->chan_mode_symbols[i] )
924                         {
926                                 if ( *p == '+' )        umu\&.to_add |= UM_Voice;
927                                 else if ( *p == '%' )   umu\&.to_add |= UM_HalfOp;
928                                 else if ( *p == '@' )   umu\&.to_add |= UM_Op;
929                                 else if ( *p == '&' )   umu\&.to_add |= UM_Admin;
930                                 else if ( *p == '~' )   umu\&.to_add |= UM_Owner;
931                                 else                    umu\&.to_add |= UM_Unknown;
932                                 p++;
933                         }
934                 }
935 
936                 if ( SplitSender(p, &user) != EIrcStatus::OK )
937                         goto invalid_data;
938 
939                 // creates the user and adds it to the temporary names list
940                 if ( channel->AddNamesUser(
941                         user\&.nickname\&.c_str(), 
942                         user\&.ident\&.c_str(), 
943                         user\&.hostmask\&.c_str(), 
944                         &umu) != EIrcStatus::OK
945                 )
946                 {
947                         break;
948                 }
949 
950                 p = str_token(nullptr, delim, &last);
951         }
952 
954         // prepare the activity data, then inform our listeners
955         {
956 
957 
958                 _irc_engine->NotifyListeners(LN_353, connection);
959         }
960 
961         ret = EIrcStatus::OK;
962         goto cleanup;
963 
964 parse_failure:
965         ret = EIrcStatus::ParsingError;
966         goto cleanup;
967 channel_not_found:
968         std::cerr << fg_red << "The extracted channel '" << extracted_channel << "' could not be found\n";
969         ret = EIrcStatus::ObjectNotFound;
970         goto cleanup;
971 invalid_data:
972         ret = EIrcStatus::InvalidData;
973         goto cleanup;
974 unknown_prefixes:
975         std::cerr << fg_red << "No user/mode prefixes exist; required to parse IRC users\n";
976         ret = EIrcStatus::UnknownResponse;
977         goto cleanup;
978 cleanup:
979         FREE(extracted_nick);
980         FREE(extracted_channel);
981         FREE(extracted_type);
982         FREE(extracted_names);
983         return ret;
984 }
.fi
.SS "bool IrcParser::Handle353 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 353 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EC_Success is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
grab prefix meanings from config\&.xml 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
send a 353 for each individual nick, or the whole message? 
.RE
.PP

.PP
Definition at line 866 of file bak/IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, IrcConnection::_parent_network, IrcNetwork::_server, IrcChannel::AddNamesUser(), irc_server::chan_mode_chars, irc_server::chan_mode_symbols, ircbuf_data::data, mode_update::erase_existing, fg_red(), FREE, IrcConnection::GetActivity(), IrcConnection::GetChannel(), ircbuf_sender::hostmask, ircbuf_sender::ident, LN_353, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), ParseParameters(), SplitSender(), str_token(), mode_update::to_add, mode_update::to_remove, UM_Admin, UM_HalfOp, UM_None, UM_Op, UM_Owner, UM_Unknown, UM_Voice, and UNREFERENCE_OBJECT\&.
.PP
.nf
871 {
872         bool            ret = false;
873         char*           extracted_type = nullptr;
874         char*           extracted_channel = nullptr;
875         char*           extracted_names = nullptr;
876         char*           extracted_nick = nullptr;
877         irc_activity&   activity = connection->GetActivity();
878         IrcChannel*     channel = nullptr;
879         char*           p = nullptr;
880         char*           last = nullptr;
881         char            delim[] = " ";
882         uint32_t                num_prefix;
883         uint32_t                i;
884         irc_server*     server = nullptr;
885         ircbuf_sender   user;
886         mode_update     umu;
887 
888         if ( !ParseParameters(data->data\&.c_str(), 4,
889                 &extracted_nick, &extracted_type, &extracted_channel, &extracted_names) )
890         {
891                 goto parse_failure;
892         }
893 
894         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
895                 goto channel_not_found;
896 
897 
898         server = &connection->_parent_network->_server;
899 
900         if ( server->chan_mode_chars\&.empty() || server->chan_mode_symbols\&.empty() )
901                 goto unknown_prefixes;
902 
903         num_prefix = server->chan_mode_symbols\&.length();
904 
905         p = str_token(extracted_names, delim, &last);
906 
907         while ( p != nullptr )
908         {
909                 umu\&.erase_existing       = false;
910                 umu\&.to_add               = UM_None;
911                 umu\&.to_remove            = UM_None;
912 
913                 for ( i = 0; i < num_prefix; i++ )
914                 {
915                         if ( *p == server->chan_mode_symbols[i] )
916                         {
918                                 if ( *p == '+' )        umu\&.to_add |= UM_Voice;
919                                 else if ( *p == '%' )   umu\&.to_add |= UM_HalfOp;
920                                 else if ( *p == '@' )   umu\&.to_add |= UM_Op;
921                                 else if ( *p == '&' )   umu\&.to_add |= UM_Admin;
922                                 else if ( *p == '~' )   umu\&.to_add |= UM_Owner;
923                                 else                    umu\&.to_add |= UM_Unknown;
924                                 p++;
925                         }
926                 }
927 
928                 if ( SplitSender(p, &user) != true )
929                         goto invalid_data;
930 
931                 /* creates the user and adds it to the temporary names list */
932                 if ( !channel->AddNamesUser(user\&.nickname\&.c_str(), user\&.ident\&.c_str(), user\&.hostmask\&.c_str(), &umu) )
933                         break;
934 
935                 p = str_token(nullptr, delim, &last);
936         }
937 
939         // prepare the activity data, then inform our listeners
940         {
941 
942 
943                 _irc_engine->NotifyListeners(LN_353, connection);
944         }
945 
946         ret = true;
947         goto cleanup;
948 
949 parse_failure:
950         /* error already generated */
951         goto cleanup;
952 channel_not_found:
953         /* error not generated */
954         std::cerr << fg_red << "The extracted channel '" << extracted_channel << "' could not be found\n";
955         goto cleanup;
956 invalid_data:
957         goto cleanup;
958 unknown_prefixes:
959         std::cerr << fg_red << "No user/mode prefixes exist; required to parse IRC users\n";
960         goto cleanup;
961 cleanup:
962         if ( channel != nullptr )
963                 UNREFERENCE_OBJECT(channel);
964         FREE(extracted_nick);
965         FREE(extracted_channel);
966         FREE(extracted_type);
967         FREE(extracted_names);
968         return ret;
969 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle366 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 366 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 989 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, fg_red(), FREE, LN_366, IrcEngine::NotifyListeners(), ObjectNotFound, OK, ParseParameters(), ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
994 {
995         std::shared_ptr<IrcChannel>     channel = nullptr;
996         EIrcStatus      ret = EIrcStatus::Unknown;
997         char*           extracted_nick = nullptr;
998         char*           extracted_channel = nullptr;
999         char*           extracted_message = nullptr;
1000         irc_activity&   activity = connection->GetActivity();
1001 
1002         /* Rizon
1003         :$server 366 $nickname $channel :End of /NAMES list\&.
1004         */
1005 
1006         // only interested in the nick + channel
1007         if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_nick, &extracted_channel, &extracted_message) )
1008                 goto parse_failure;
1009 
1010         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
1011                 goto channel_not_found;
1012 
1013 
1014         // convert the temporary names list into the active userlist
1015         channel->PopulateUserlist();
1016 
1017         // prepare the activity data, then inform our listeners
1018         {
1019 
1020 
1021                 _irc_engine->NotifyListeners(LN_366, connection);
1022         }
1023 
1024         ret = EIrcStatus::OK;
1025         goto cleanup;
1026 
1027 parse_failure:
1028         ret = EIrcStatus::ParsingError;
1029         goto cleanup;
1030 channel_not_found:
1031         std::cerr << fg_red << "The extracted channel '" << extracted_channel << "' could not be found\n";
1032         ret = EIrcStatus::ObjectNotFound;
1033         goto cleanup;
1034 cleanup:
1035         FREE(extracted_nick);
1036         FREE(extracted_channel);
1037         FREE(extracted_message);
1038         return ret;
1039 }
.fi
.SS "bool IrcParser::Handle366 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 366 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EC_Success is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP

.PP
Definition at line 974 of file bak/IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, fg_red(), FREE, IrcConnection::GetActivity(), IrcConnection::GetChannel(), LN_366, IrcEngine::NotifyListeners(), ParseParameters(), IrcChannel::PopulateUserlist(), and UNREFERENCE_OBJECT\&.
.PP
.nf
979 {
980         bool            ret = false;
981         char*           extracted_nick = nullptr;
982         char*           extracted_channel = nullptr;
983         char*           extracted_message = nullptr;
984         irc_activity&   activity = connection->GetActivity();
985         IrcChannel*     channel = nullptr;
986 
987         /* Rizon
988         :$server 366 $nickname $channel :End of /NAMES list\&.
989         */
990 
991         /* only interested in the nick + channel */
992         if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_nick, &extracted_channel, &extracted_message) )
993                 goto parse_failure;
994 
995         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
996                 goto channel_not_found;
997 
998 
999         /* convert the temporary names list into the active userlist */
1000         channel->PopulateUserlist();
1001 
1002         // prepare the activity data, then inform our listeners
1003         {
1004 
1005 
1006                 _irc_engine->NotifyListeners(LN_366, connection);
1007         }
1008 
1009         ret = true;
1010         goto cleanup;
1011 
1012 parse_failure:
1013         /* error already generated */
1014         goto cleanup;
1015 channel_not_found:
1016         /* error not generated */
1017         std::cerr << fg_red << "The extracted channel '" << extracted_channel << "' could not be found\n";
1018         goto cleanup;
1019 cleanup:
1020         if ( channel != nullptr )
1021                 UNREFERENCE_OBJECT(channel);
1022         FREE(extracted_nick);
1023         FREE(extracted_channel);
1024         FREE(extracted_message);
1025         return ret;
1026 }
.fi
.SS "bool IrcParser::Handle372 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
Definition at line 1031 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::GetActivity()\&.
.PP
.nf
1036 {
1037         bool            ret = false;
1038         irc_activity&   activity = connection->GetActivity();
1039 
1040         // prepare the activity data, then inform our listeners
1041         {
1042 
1043 
1044                 //_irc_engine->NotifyListeners(LN_372, connection);
1045         }
1046 
1047         ret = true;
1048         goto cleanup;
1049 
1050 cleanup:
1051         return ret;
1052 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle372 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 372 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 1044 of file IrcParser\&.cc\&.
.PP
References OK, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1049 {
1050         EIrcStatus      ret = EIrcStatus::Unknown;
1051         irc_activity&   activity = connection->GetActivity();
1052 
1053         // prepare the activity data, then inform our listeners
1054         {
1055 
1056 
1057                 //_irc_engine->NotifyListeners(LN_372, connection);
1058         }
1059 
1060         ret = EIrcStatus::OK;
1061         goto cleanup;
1062 
1063 cleanup:
1064         return ret;
1065 }
.fi
.SS "bool IrcParser::Handle375 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
Definition at line 1057 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::GetActivity()\&.
.PP
.nf
1062 {
1063         bool            ret = false;
1064         irc_activity&   activity = connection->GetActivity();
1065 
1066         // prepare the activity data, then inform our listeners
1067         {
1068 
1069 
1070                 //_irc_engine->NotifyListeners(LN_375, connection);
1071         }
1072 
1073         ret = true;
1074         goto cleanup;
1075 
1076 cleanup:
1077         return ret;
1078 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle375 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 375 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 1070 of file IrcParser\&.cc\&.
.PP
References OK, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1075 {
1076         EIrcStatus      ret = EIrcStatus::Unknown;
1077         irc_activity&   activity = connection->GetActivity();
1078 
1079         // prepare the activity data, then inform our listeners
1080         {
1081 
1082 
1083                 //_irc_engine->NotifyListeners(LN_375, connection);
1084         }
1085 
1086         ret = EIrcStatus::OK;
1087         goto cleanup;
1088 
1089 cleanup:
1090         return ret;
1091 }
.fi
.SS "bool IrcParser::Handle376 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
Definition at line 1083 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::GetActivity()\&.
.PP
.nf
1088 {
1089         bool            ret = false;
1090         irc_activity&   activity = connection->GetActivity();
1091 
1092         // prepare the activity data, then inform our listeners
1093         {
1094 
1095 
1096                 //_irc_engine->NotifyListeners(LN_376, connection);
1097         }
1098 
1099         ret = true;
1100         goto cleanup;
1101 
1102 cleanup:
1103         return ret;
1104 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle376 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 376 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 1096 of file IrcParser\&.cc\&.
.PP
References OK, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1101 {
1102         EIrcStatus      ret = EIrcStatus::Unknown;
1103         irc_activity&   activity = connection->GetActivity();
1104 
1105         // prepare the activity data, then inform our listeners
1106         {
1107 
1108 
1109                 //_irc_engine->NotifyListeners(LN_376, connection);
1110         }
1111 
1112         ret = EIrcStatus::OK;
1113         goto cleanup;
1114 
1115 cleanup:
1116         return ret;
1117 }
.fi
.SS "bool IrcParser::Handle432 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 432 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EC_Success is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
if ( auto_change_nick\&.\&.\&. ) 
.RE
.PP

.PP
Definition at line 1111 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::AutoChangeNick(), ircbuf_data::data, FREE, IrcConnection::GetActivity(), and ParseParameters()\&.
.PP
.nf
1116 {
1117         bool            ret = false;
1118         char*           extracted_nick = nullptr;
1119         char*           extracted_bad_nick = nullptr;
1120         char*           extracted_message = nullptr;
1121         irc_activity&   activity = connection->GetActivity();
1122 
1123         if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_nick, &extracted_bad_nick, &extracted_message) )
1124                 goto parse_failure;
1125 
1126         /* a = sender, b = destination_nickname, c = bad_nickname, d = message */
1127         //add_ui_event((E_MSG_CODE)432, connection, 4, sender->nickname, extracted_nick, extracted_bad_nick, extracted_message);
1128 
1130         connection->AutoChangeNick();
1131 
1132         // prepare the activity data, then inform our listeners
1133         {
1134 
1135 
1136                 //_irc_engine->NotifyListeners(LN_432, connection);
1137         }
1138 
1139         ret = true;
1140         goto cleanup;
1141 
1142 parse_failure:
1143         goto cleanup;
1144 cleanup:
1145         FREE(extracted_nick);
1146         FREE(extracted_bad_nick);
1147         FREE(extracted_message);
1148         return ret;
1149 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle432 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 432 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
if ( auto_change_nick\&.\&.\&. ) 
.RE
.PP

.PP
Definition at line 1124 of file IrcParser\&.cc\&.
.PP
References ircbuf_data::data, FREE, OK, ParseParameters(), ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1129 {
1130         EIrcStatus      ret = EIrcStatus::Unknown;
1131         char*           extracted_nick = nullptr;
1132         char*           extracted_bad_nick = nullptr;
1133         char*           extracted_message = nullptr;
1134         irc_activity&   activity = connection->GetActivity();
1135 
1136         if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_nick, &extracted_bad_nick, &extracted_message) )
1137                 goto parse_failure;
1138 
1139         // a = sender, b = destination_nickname, c = bad_nickname, d = message */
1140         //add_ui_event((E_MSG_CODE)432, connection, 4, sender->nickname, extracted_nick, extracted_bad_nick, extracted_message);
1141 
1143         connection->AutoChangeNick();
1144 
1145         // prepare the activity data, then inform our listeners
1146         {
1147 
1148 
1149                 //_irc_engine->NotifyListeners(LN_432, connection);
1150         }
1151 
1152         ret = EIrcStatus::OK;
1153         goto cleanup;
1154 
1155 parse_failure:
1156         ret = EIrcStatus::ParsingError;
1157         goto cleanup;
1158 cleanup:
1159         FREE(extracted_nick);
1160         FREE(extracted_bad_nick);
1161         FREE(extracted_message);
1162         return ret;
1163 }
.fi
.SS "bool IrcParser::Handle433 (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 433 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EC_Success is returned\&. If it is invalid and/or parsing/processing fails, the relevant bool is returned\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
if ( auto_change_nick\&.\&.\&. ) 
.RE
.PP

.PP
Definition at line 1154 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::AutoChangeNick(), ircbuf_data::data, FREE, IrcConnection::GetActivity(), and ParseParameters()\&.
.PP
.nf
1159 {
1160         bool            ret = false;
1161         char*           extracted_nick = nullptr;
1162         char*           extracted_used_nick = nullptr;
1163         char*           extracted_message = nullptr;
1164         irc_activity&   activity = connection->GetActivity();
1165 
1166         if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_nick, &extracted_used_nick, &extracted_message) )
1167                 goto parse_failure;
1168 
1170         connection->AutoChangeNick();
1171 
1172         // prepare the activity data, then inform our listeners
1173         {
1174 
1175 
1176                 //_irc_engine->NotifyListeners(LN_433, connection);
1177         }
1178 
1179         ret = true;
1180         goto cleanup;
1181 
1182 parse_failure:
1183         goto cleanup;
1184 cleanup:
1185         FREE(extracted_nick);
1186         FREE(extracted_used_nick);
1187         FREE(extracted_message);
1188         return ret;
1189 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::Handle433 (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses the 433 numeric
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
if ( auto_change_nick\&.\&.\&. ) 
.RE
.PP

.PP
Definition at line 1168 of file IrcParser\&.cc\&.
.PP
References ircbuf_data::data, FREE, OK, ParseParameters(), ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1173 {
1174         EIrcStatus      ret = EIrcStatus::Unknown;
1175         char*           extracted_nick = nullptr;
1176         char*           extracted_used_nick = nullptr;
1177         char*           extracted_message = nullptr;
1178         irc_activity&   activity = connection->GetActivity();
1179 
1180         if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_nick, &extracted_used_nick, &extracted_message) )
1181                 goto parse_failure;
1182 
1184         connection->AutoChangeNick();
1185 
1186         // prepare the activity data, then inform our listeners
1187         {
1188 
1189 
1190                 //_irc_engine->NotifyListeners(LN_433, connection);
1191         }
1192 
1193         ret = EIrcStatus::OK;
1194         goto cleanup;
1195 
1196 parse_failure:
1197         ret = EIrcStatus::ParsingError;
1198         goto cleanup;
1199 cleanup:
1200         FREE(extracted_nick);
1201         FREE(extracted_used_nick);
1202         FREE(extracted_message);
1203         return ret;
1204 }
.fi
.SS "bool IrcParser::HandleCap (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
Definition at line 1194 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::_cap_ack, IrcConnection::_cap_ls, IrcConnection::_cap_nak, IrcObject::_irc_engine, irc_activity::data, ircbuf_data::data, fg_red(), FREE, IrcConnection::GetActivity(), irc_activity::hostmask, ircbuf_sender::hostmask, irc_activity::ident, ircbuf_sender::ident, irc_activity::instigator, LN_Cap, irc_activity::message, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), and ParseParameters()\&.
.PP
.nf
1199 {
1200         /* :ircd\&.trezanik\&.org CAP * ACK :multi-prefix */
1201         /* :ircd\&.trezanik\&.org CAP * NAK :uhnames */
1202         /*
1203          * R    CAP LS
1204          * S    CAP LIST
1205          * S    CAP REQ
1206          * R    CAP ACK
1207          * R    CAP NAK
1208          * S    CAP CLEAR
1209          * S    CAP END
1210          *
1211          * Servers MUST respond to a REQ command with either the ACK or NAK subcommands to indicate acceptance or rejection of the capability set requested by the client
1212         */
1213         bool            ret = false;
1214         char*           extracted_acknak = nullptr;
1215         char*           extracted_cap = nullptr;
1216         irc_activity&   activity = connection->GetActivity();
1217 
1218         // CAP param 1 will always be '*' as we won't have sent or confirmed NICK
1219         if ( !ParseParameters(data->data\&.c_str(), 3, nullptr, &extracted_acknak, &extracted_cap) )
1220                 goto parse_failure;
1221 
1222         if ( strcmp(extracted_acknak, "ACK") == 0 )
1223         {
1224                 connection->_cap_ack\&.push_back(extracted_cap);
1225         }
1226         else if ( strcmp(extracted_acknak, "NAK") == 0 )
1227         {
1228                 connection->_cap_nak\&.push_back(extracted_cap);
1229         }
1230         else if ( strcmp(extracted_acknak, "LS") == 0 )
1231         {
1232                 /* must have requested a list (atm, we don't at all) */
1233                 /* believe we need a str_token here */
1234                 connection->_cap_ls\&.push_back(extracted_cap);
1235         }
1236         else goto what_acknak;
1237 
1238 
1239 
1240         // prepare the activity data, then inform our listeners
1241         {
1242                 // only nickname should be valid, but just in case\&.\&.\&.
1243                 activity\&.instigator\&.hostmask      = sender->hostmask;
1244                 activity\&.instigator\&.ident = sender->ident;
1245                 activity\&.instigator\&.nickname      = sender->nickname;
1246                 activity\&.message         = extracted_cap;
1247                 activity\&.data                    = extracted_acknak;
1248 
1249                 _irc_engine->NotifyListeners(LN_Cap, connection);
1250         }
1251 
1252         ret = true;
1253         goto cleanup;
1254 
1255 parse_failure:
1256         goto cleanup;
1257 what_acknak:
1258         std::cerr << fg_red << "Unknown response to a CAP: " << data->data << "\n";
1259         goto cleanup;
1260 cleanup:
1261         FREE(extracted_acknak);
1262         FREE(extracted_cap);
1263         return ret;
1264 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandleCap (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses CAP
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 1209 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, irc_activity::data, ircbuf_data::data, fg_red(), FREE, irc_activity::hostmask, ircbuf_sender::hostmask, irc_activity::ident, ircbuf_sender::ident, irc_activity::instigator, LN_Cap, irc_activity::message, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), OK, ParseParameters(), ParsingError, Unknown, and UnknownResponse\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1214 {
1215         /* :ircd\&.trezanik\&.org CAP * ACK :multi-prefix */
1216         /* :ircd\&.trezanik\&.org CAP * NAK :uhnames */
1217         /*
1218          * R    CAP LS
1219          * S    CAP LIST
1220          * S    CAP REQ
1221          * R    CAP ACK
1222          * R    CAP NAK
1223          * S    CAP CLEAR
1224          * S    CAP END
1225          *
1226          * Servers MUST respond to a REQ command with either the ACK or NAK subcommands to indicate acceptance or rejection of the capability set requested by the client
1227         */
1228         EIrcStatus      ret = EIrcStatus::Unknown;
1229         char*           extracted_acknak = nullptr;
1230         char*           extracted_cap = nullptr;
1231         irc_activity&   activity = connection->GetActivity();
1232 
1233         // CAP param 1 will always be '*' as we won't have sent or confirmed NICK
1234         if ( !ParseParameters(data->data\&.c_str(), 3, nullptr, &extracted_acknak, &extracted_cap) )
1235                 goto parse_failure;
1236 
1237         if ( strcmp(extracted_acknak, "ACK") == 0 )
1238         {
1239                 connection->_cap_ack\&.push_back(extracted_cap);
1240         }
1241         else if ( strcmp(extracted_acknak, "NAK") == 0 )
1242         {
1243                 connection->_cap_nak\&.push_back(extracted_cap);
1244         }
1245         else if ( strcmp(extracted_acknak, "LS") == 0 )
1246         {
1247                 /* must have requested a list (atm, we don't at all) */
1248                 /* believe we need a str_token here */
1249                 connection->_cap_ls\&.push_back(extracted_cap);
1250         }
1251         else
1252         {
1253                 goto what_acknak;
1254         }
1255 
1256 
1257 
1258         // prepare the activity data, then inform our listeners
1259         {
1260                 // only nickname should be valid, but just in case\&.\&.\&.
1261                 activity\&.instigator\&.hostmask      = sender->hostmask;
1262                 activity\&.instigator\&.ident = sender->ident;
1263                 activity\&.instigator\&.nickname      = sender->nickname;
1264                 activity\&.message         = extracted_cap;
1265                 activity\&.data                    = extracted_acknak;
1266 
1267                 _irc_engine->NotifyListeners(LN_Cap, connection);
1268         }
1269 
1270         ret = EIrcStatus::OK;
1271         goto cleanup;
1272 
1273 parse_failure:
1274         ret = EIrcStatus::ParsingError;
1275         goto cleanup;
1276 what_acknak:
1277         std::cerr << fg_red << "Unknown response to a CAP: " << data->data << "\n";
1278         ret = EIrcStatus::UnknownResponse;
1279         goto cleanup;
1280 cleanup:
1281         FREE(extracted_acknak);
1282         FREE(extracted_cap);
1283         return ret;
1284 }
.fi
.SS "bool IrcParser::HandleInvite (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
Definition at line 1269 of file bak/IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, FREE, IrcConnection::GetActivity(), LN_Invite, IrcEngine::NotifyListeners(), and ParseParameters()\&.
.PP
.nf
1274 {
1275         bool            ret = false;
1276         IrcUser*        user = nullptr;
1277         IrcChannel*     channel = nullptr;
1278         char*           extracted_nick = nullptr;
1279         char*           extracted_channel = nullptr;
1280         irc_activity&   activity = connection->GetActivity();
1281 
1282         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_nick, &extracted_channel) )
1283                 goto parse_failure;
1284 
1285         user;
1286         channel;
1287 
1288         // prepare the activity data, then inform our listeners
1289         {
1290 
1291 
1292                 _irc_engine->NotifyListeners(LN_Invite, connection);
1293         }
1294 
1295         ret = true;
1296         goto cleanup;
1297 
1298 parse_failure:
1299         goto cleanup;
1300 cleanup:
1301         FREE(extracted_nick);
1302         FREE(extracted_channel);
1303         return ret;
1304 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandleInvite (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses INVITE
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 1289 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, FREE, LN_Invite, IrcEngine::NotifyListeners(), OK, ParseParameters(), ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1294 {
1295         std::shared_ptr<IrcUser>        user = nullptr;
1296         std::shared_ptr<IrcChannel>     channel = nullptr;
1297         EIrcStatus      ret = EIrcStatus::Unknown;
1298         char*           extracted_nick = nullptr;
1299         char*           extracted_channel = nullptr;
1300         irc_activity&   activity = connection->GetActivity();
1301 
1302         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_nick, &extracted_channel) )
1303                 goto parse_failure;
1304 
1305         user;
1306         channel;
1307 
1308         // prepare the activity data, then inform our listeners
1309         {
1310 
1311 
1312                 _irc_engine->NotifyListeners(LN_Invite, connection);
1313         }
1314 
1315         ret = EIrcStatus::OK;
1316         goto cleanup;
1317 
1318 parse_failure:
1319         ret = EIrcStatus::ParsingError;
1320         goto cleanup;
1321 cleanup:
1322         FREE(extracted_nick);
1323         FREE(extracted_channel);
1324         return ret;
1325 }
.fi
.SS "bool IrcParser::HandleJoin (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
\fBTodo\fP
.RS 4
is there any way to guarantee/ensure this? 
.RE
.PP

.PP
Definition at line 1309 of file bak/IrcParser\&.cc\&.
.PP
References IrcNetwork::_client, IrcChannel::_flags, IrcObject::_irc_engine, IrcConnection::_parent_network, IrcConnection::AddChannel(), IrcChannel::AddUser(), CHANFLAG_ACTIVE, irc_activity::channel_name, ircbuf_data::data, IrcConnection::GetActivity(), IrcConnection::GetChannel(), irc_activity::hostmask, ircbuf_sender::hostmask, irc_activity::ident, ircbuf_sender::ident, irc_activity::instigator, LN_Join, LN_WeJoined, irc_client::nickname, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), and UNREFERENCE_OBJECT\&.
.PP
.nf
1314 {
1315         bool            ret = false;
1316         IrcUser*        user = nullptr;
1317         IrcChannel*     channel = nullptr;
1318         std::string     channel_name;
1319         irc_activity&   activity = connection->GetActivity();
1320 
1321         if ( data->data[0] != ':' )
1322                 goto invalid_data;
1323 
1324         /* remainder of the string is the channel name - check if we're joining a
1325          * new one, or if another user is joining one we're in */
1326         channel_name = data->data\&.substr(1);
1327 
1328         if ( channel_name\&.length() < 2 )
1329                 goto invalid_data;
1330 
1331         if ( sender->nickname\&.compare(connection->_parent_network->_client\&.nickname) == 0 )
1332         {
1333                 /* it's me - check if we still have the channel 'open', but is not active */
1334 
1335                 if (( channel = connection->GetChannel(channel_name\&.c_str())) == nullptr )
1336                 {
1337                         /* totally brand new channel */
1338 
1339                         if ( connection->AddChannel(channel_name\&.c_str()) )
1340                                 channel = connection->GetChannel(channel_name\&.c_str());
1341                         else
1342                                 goto channel_add_failure;
1343 
1344                         /* note that we don't add our own user here - upon joining a channel,
1345                          * you should always receive a 353 NAMES list */
1347                 }
1348 
1349                 channel->_flags |= CHANFLAG_ACTIVE;
1350 
1351                 // prepare the activity data, then inform our listeners
1352                 {
1353                         activity\&.instigator\&.hostmask      = sender->hostmask;
1354                         activity\&.instigator\&.ident = sender->ident;
1355                         activity\&.instigator\&.nickname      = sender->nickname;
1356                         activity\&.channel_name            = channel_name;
1357 
1358                         _irc_engine->NotifyListeners(LN_WeJoined, connection);
1359                 }
1360         }
1361         else
1362         {
1363                 /* someone else joining a channel we're in */
1364 
1365                 if (( channel = connection->GetChannel(channel_name\&.c_str())) == nullptr )
1366                         goto no_channel_object;
1367                 if ( !(channel->_flags & CHANFLAG_ACTIVE) )
1368                         goto invalid_channel_state;
1369 
1370                 if ( !channel->AddUser(sender->nickname\&.c_str(), sender->ident\&.c_str(), sender->hostmask\&.c_str()) )
1371                         goto user_add_failure;
1372 
1373                 // prepare the activity data, then inform our listeners
1374                 {
1375                         activity\&.instigator\&.hostmask      = sender->hostmask;
1376                         activity\&.instigator\&.ident = sender->ident;
1377                         activity\&.instigator\&.nickname      = sender->nickname;
1378                         activity\&.channel_name            = channel_name;
1379 
1380                         _irc_engine->NotifyListeners(LN_Join, connection);
1381                 }
1382         }
1383 
1384         ret = true;
1385         goto cleanup;
1386 
1387 invalid_data:
1388         goto cleanup;
1389 channel_add_failure:
1390         goto cleanup;
1391 no_channel_object:
1392         goto cleanup;
1393 invalid_channel_state:
1394         goto cleanup;
1395 user_add_failure:
1396         goto cleanup;
1397 cleanup:
1398         if ( channel != nullptr )
1399                 UNREFERENCE_OBJECT(channel);
1400         return ret;
1401 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandleJoin (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses JOIN
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
is there any way to guarantee/ensure this? 
.RE
.PP

.PP
Definition at line 1330 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, CHANFLAG_ACTIVE, irc_activity::channel_name, IrcEngine::CreateChannel(), IrcEngine::CreateUser(), ircbuf_data::data, irc_activity::hostmask, ircbuf_sender::hostmask, irc_activity::ident, ircbuf_sender::ident, irc_activity::instigator, InvalidData, InvalidState, LN_Join, LN_WeJoined, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), ObjectAddError, ObjectNotFound, OK, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1335 {
1336         std::shared_ptr<IrcUser>        user = nullptr;
1337         std::shared_ptr<IrcChannel>     channel = nullptr;
1338         EIrcStatus      ret = EIrcStatus::Unknown;
1339         std::string     channel_name;
1340         irc_activity&   activity = connection->GetActivity();
1341 
1342         if ( data->data[0] != ':' )
1343                 goto invalid_data;
1344 
1345         /* remainder of the string is the channel name - check if we're joining 
1346          * a new one, or if another user is joining one we're in */
1347         channel_name = data->data\&.substr(1);
1348 
1349         if ( channel_name\&.length() < 2 )
1350                 goto invalid_data;
1351 
1352         if ( sender->nickname\&.compare(connection->Owner()->_client\&.nickname) == 0 )
1353         {
1354                 // self; check if we still have the channel 'open', but is not active
1355 
1356                 if (( channel = connection->GetChannel(channel_name\&.c_str())) == nullptr )
1357                 {
1358                         // totally brand new channel
1359                         _irc_engine->CreateChannel(connection->Id(), channel_name\&.c_str());
1360                         /*
1361                         if (( ret = connection->AddChannel(channel_name\&.c_str()) == EIrcStatus::OK )
1362                                 channel = connection->GetChannel(channel_name\&.c_str());
1363                         else
1364                                 goto channel_add_failure;*/
1365 
1366                         /* note that we don't add our own user here - upon joining a channel,
1367                          * you should always receive a 353 NAMES list */
1369                 }
1370 
1371                 channel->_flags |= CHANFLAG_ACTIVE;
1372 
1373                 // prepare the activity data, then inform our listeners
1374                 {
1375                         activity\&.instigator\&.hostmask      = sender->hostmask;
1376                         activity\&.instigator\&.ident = sender->ident;
1377                         activity\&.instigator\&.nickname      = sender->nickname;
1378                         activity\&.channel_name            = channel_name;
1379 
1380                         _irc_engine->NotifyListeners(LN_WeJoined, connection);
1381                 }
1382         }
1383         else
1384         {
1385                 // someone else joining a channel we're in
1386 
1387                 if (( channel = connection->GetChannel(channel_name\&.c_str())) == nullptr )
1388                         goto no_channel_object;
1389                 if ( !(channel->_flags & CHANFLAG_ACTIVE) )
1390                         goto invalid_channel_state;
1391 
1392                 if ( _irc_engine->CreateUser(
1393                         connection->Id(), 
1394                         channel_name\&.c_str(),
1395                         sender->nickname\&.c_str(), 
1396                         sender->ident\&.c_str(), 
1397                         sender->hostmask\&.c_str())
1398                         != EIrcStatus::OK
1399                 )
1400                 {
1401                         goto user_add_failure;
1402                 }
1403 
1404                 // prepare the activity data, then inform our listeners
1405                 {
1406                         activity\&.instigator\&.hostmask      = sender->hostmask;
1407                         activity\&.instigator\&.ident = sender->ident;
1408                         activity\&.instigator\&.nickname      = sender->nickname;
1409                         activity\&.channel_name            = channel_name;
1410 
1411                         _irc_engine->NotifyListeners(LN_Join, connection);
1412                 }
1413         }
1414 
1415         ret = EIrcStatus::OK;
1416         goto cleanup;
1417 
1418 invalid_data:
1419         ret = EIrcStatus::InvalidData;
1420         goto cleanup;
1421 channel_add_failure:
1422         ret = EIrcStatus::ObjectAddError;
1423         goto cleanup;
1424 no_channel_object:
1425         ret = EIrcStatus::ObjectNotFound;
1426         goto cleanup;
1427 invalid_channel_state:
1428         ret = EIrcStatus::InvalidState;
1429         goto cleanup;
1430 user_add_failure:
1431         ret = EIrcStatus::ObjectAddError;
1432         goto cleanup;
1433 cleanup:
1434         return ret;
1435 }
.fi
.SS "bool IrcParser::HandleKick (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
\fBTodo\fP
.RS 4
if ( AutoRejoinOnKick ) 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
retain the channel key to rejoin?? 
.RE
.PP

.PP
Definition at line 1406 of file bak/IrcParser\&.cc\&.
.PP
References IrcNetwork::_client, IrcChannel::_flags, IrcObject::_irc_engine, IrcConnection::_parent_network, CHANFLAG_RAW, ircbuf_data::data, IrcChannel::DeleteUser(), IrcChannel::EraseUserlist(), fg_red(), FREE, IrcConnection::GetActivity(), IrcConnection::GetChannel(), IrcChannel::GetUser(), LN_GotKicked, LN_Kick, irc_client::nickname, IrcEngine::NotifyListeners(), ParseParameters(), IrcConnection::SendJoin(), and UNREFERENCE_OBJECT\&.
.PP
.nf
1411 {
1412         bool            ret = false;
1413         IrcChannel*     channel = nullptr;
1414         IrcUser*        user = nullptr;
1415         char*           extracted_channel = nullptr;
1416         char*           extracted_kicked = nullptr;
1417         char*           extracted_kick_message = nullptr;
1418         irc_activity&   activity = connection->GetActivity();
1419 
1420         /* Rizon:
1421         :$nick!$ident@$host KICK $channel $nickname :$message
1422         */
1423 
1424         if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_channel, &extracted_kicked, &extracted_kick_message) )
1425                 goto parse_failure;
1426 
1427         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
1428                 goto channel_not_found;
1429 
1430 
1431         if ( strcmp(extracted_kicked, connection->_parent_network->_client\&.nickname\&.c_str()) == 0 )
1432         {
1433                 /* we're the one that was kicked; remove compulsory items from the chan */
1434 
1435                 channel->_flags = CHANFLAG_RAW; /* disable */
1436                 channel->EraseUserlist();
1437 
1438                 // prepare the activity data, then inform our listeners
1439                 {
1440 
1441 
1442                         _irc_engine->NotifyListeners(LN_GotKicked, connection);
1443                 }
1444 
1446                 {
1448                         connection->SendJoin(extracted_channel);
1449                 }
1450 
1451                 /* a = sender_nick, b = sender_ident, c = sender_host, d = channel, e = kicked_nick, f = kick_message */
1452                 //add_ui_event(MC_Kick, connection, 6,
1453                 //      sender->nickname, sender->ident, sender->hostmask,
1454                 //      extracted_channel, extracted_kicked, extracted_kick_message);
1455         }
1456         else
1457         {
1458                 /* someone else in the channel was kicked */
1459 
1460                 if (( user = channel->GetUser(extracted_kicked)) == nullptr )
1461                         goto kicked_not_found;
1462 
1463                 if ( !channel->DeleteUser(user) )
1464                         goto failed;
1465 
1466                 // prepare the activity data, then inform our listeners
1467                 {
1468 
1469 
1470                         _irc_engine->NotifyListeners(LN_Kick, connection);
1471                 }
1472 
1473                 /* a = sender_nick, b = sender_ident, c = sender_host, d = channel, e = kicked_nick, f = kick_message */
1474                 //add_ui_event(MC_Kick, connection, 6,
1475                 //      sender->nickname, sender->ident, sender->hostmask,
1476                 //      extracted_channel, extracted_kicked, extracted_kick_message);
1477         }
1478 
1479         ret = true;
1480         goto cleanup;
1481 
1482 parse_failure:
1483         goto cleanup;
1484 channel_not_found:
1485         std::cerr << fg_red << "The extracted channel '" << extracted_channel << "' could not be found\n";
1486         goto cleanup;
1487 kicked_not_found:
1488         std::cerr << fg_red << "The extracted kicked nickname '" << extracted_kicked << "' was not found\n";
1489         goto cleanup;
1490 failed:
1491         goto cleanup;
1492 cleanup:
1493         if ( channel != nullptr )
1494                 UNREFERENCE_OBJECT(channel);
1495         FREE(extracted_channel);
1496         FREE(extracted_kicked);
1497         FREE(extracted_kick_message);
1498         return ret;
1499 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandleKick (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses KICK
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
if ( AutoRejoinOnKick ) 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
retain the channel key to rejoin?? 
.RE
.PP

.PP
Definition at line 1440 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, CHANFLAG_RAW, ircbuf_data::data, fg_red(), FREE, LN_GotKicked, LN_Kick, IrcEngine::NotifyListeners(), ObjectNotFound, OK, ParseParameters(), ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1445 {
1446         std::shared_ptr<IrcChannel>     channel = nullptr;
1447         std::shared_ptr<IrcUser>        user = nullptr;
1448         EIrcStatus      ret = EIrcStatus::Unknown;
1449         char*           extracted_channel = nullptr;
1450         char*           extracted_kicked = nullptr;
1451         char*           extracted_kick_message = nullptr;
1452         irc_activity&   activity = connection->GetActivity();
1453 
1454         /* Rizon:
1455         :$nick!$ident@$host KICK $channel $nickname :$message
1456         */
1457 
1458         if ( !ParseParameters(data->data\&.c_str(), 3, &extracted_channel, &extracted_kicked, &extracted_kick_message) )
1459                 goto parse_failure;
1460 
1461         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
1462                 goto channel_not_found;
1463 
1464 
1465         if ( strcmp(extracted_kicked, connection->Owner()->_client\&.nickname\&.c_str()) == 0 )
1466         {
1467                 // we're the one that was kicked; remove compulsory items from the chan
1468 
1469                 channel->_flags = CHANFLAG_RAW;
1470                 channel->EraseUserlist();
1471 
1472                 // prepare the activity data, then inform our listeners
1473                 {
1474 
1475 
1476                         _irc_engine->NotifyListeners(LN_GotKicked, connection);
1477                 }
1478 
1480                 {
1482                         connection->SendJoin(extracted_channel);
1483                 }
1484 
1485                 /* a = sender_nick, b = sender_ident, c = sender_host, d = channel, e = kicked_nick, f = kick_message */
1486                 //add_ui_event(MC_Kick, connection, 6,
1487                 //      sender->nickname, sender->ident, sender->hostmask,
1488                 //      extracted_channel, extracted_kicked, extracted_kick_message);
1489         }
1490         else
1491         {
1492                 // someone else in the channel was kicked
1493 
1494                 if (( user = channel->GetUser(extracted_kicked)) == nullptr )
1495                         goto kicked_not_found;
1496 
1497                 if (( ret = channel->DeleteUser(user)) != EIrcStatus::OK )
1498                         goto delete_failed;
1499 
1500                 // prepare the activity data, then inform our listeners
1501                 {
1502 
1503 
1504                         _irc_engine->NotifyListeners(LN_Kick, connection);
1505                 }
1506 
1507                 /* a = sender_nick, b = sender_ident, c = sender_host, d = channel, e = kicked_nick, f = kick_message */
1508                 //add_ui_event(MC_Kick, connection, 6,
1509                 //      sender->nickname, sender->ident, sender->hostmask,
1510                 //      extracted_channel, extracted_kicked, extracted_kick_message);
1511         }
1512 
1513         ret = EIrcStatus::OK;
1514         goto cleanup;
1515 
1516 parse_failure:
1517         ret = EIrcStatus::ParsingError;
1518         goto cleanup;
1519 channel_not_found:
1520         std::cerr << fg_red << "The extracted channel '" << extracted_channel << "' could not be found\n";
1521         ret = EIrcStatus::ObjectNotFound;
1522         goto cleanup;
1523 kicked_not_found:
1524         std::cerr << fg_red << "The extracted kicked nickname '" << extracted_kicked << "' was not found\n";
1525         ret = EIrcStatus::ObjectNotFound;
1526         goto cleanup;
1527 delete_failed:
1528         // report error?
1529         goto cleanup;
1530 cleanup:
1531         FREE(extracted_channel);
1532         FREE(extracted_kicked);
1533         FREE(extracted_kick_message);
1534         return ret;
1535 }
.fi
.SS "bool IrcParser::HandleKill (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
Definition at line 1504 of file bak/IrcParser\&.cc\&.
.PP
References IrcNetwork::_client, IrcObject::_irc_engine, IrcConnection::_parent_network, ircbuf_data::data, fg_red(), FREE, IrcConnection::GetActivity(), IrcConnection::GetCurrentNickname(), LN_GotKilled, irc_client::nickname, IrcEngine::NotifyListeners(), and ParseParameters()\&.
.PP
.nf
1509 {
1510         bool            ret = false;
1511         IrcChannel*     channel = nullptr;
1512         IrcUser*        user = nullptr;
1513         char*           extracted_nickname = nullptr;
1514         char*           extracted_message = nullptr;
1515         irc_activity&   activity = connection->GetActivity();
1516 
1517         /* Rizon:
1518         :$server KILL $nickname :$message
1519         */
1520 
1521         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_nickname, &extracted_message) )
1522                 goto parse_failure;
1523 
1524         if ( strcmp(extracted_nickname, connection->GetCurrentNickname()\&.c_str()) == 0 )
1525         {
1526                 // prepare the activity data, then inform our listeners
1527                 {
1528 
1529 
1530                         _irc_engine->NotifyListeners(LN_GotKilled, connection);
1531                 }
1532         }
1533         else
1534         {
1535                 /* consistency failure; KILLs should only be directed at the affected
1536                  * user - either the server is lying or we lost track of our nick */
1537                 goto nick_not_client;
1538 
1539         }
1540 
1541         ret = true;
1542         goto cleanup;
1543 
1544 parse_failure:
1545         goto cleanup;
1546 nick_not_client:
1547         std::cerr << fg_red << "Killed nickname '" << extracted_nickname <<
1548                 "' does not match the current client setting: '" <<
1549                 connection->_parent_network->_client\&.nickname\&.c_str() << "'\n";
1550         goto cleanup;
1551 cleanup:
1552         FREE(extracted_nickname);
1553         FREE(extracted_message);
1554         return ret;
1555 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandleKill (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses KILL
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 1540 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, fg_red(), FREE, LN_GotKilled, NickIsNotClient, IrcEngine::NotifyListeners(), OK, ParseParameters(), ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1545 {
1546         std::shared_ptr<IrcChannel>     channel = nullptr;
1547         std::shared_ptr<IrcUser>        user = nullptr;
1548         EIrcStatus      ret = EIrcStatus::Unknown;
1549         char*           extracted_nickname = nullptr;
1550         char*           extracted_message = nullptr;
1551         irc_activity&   activity = connection->GetActivity();
1552 
1553         /* Rizon:
1554         :$server KILL $nickname :$message
1555         */
1556 
1557         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_nickname, &extracted_message) )
1558                 goto parse_failure;
1559 
1560         if ( strcmp(extracted_nickname, connection->GetCurrentNickname()\&.c_str()) == 0 )
1561         {
1562                 // prepare the activity data, then inform our listeners
1563                 {
1564 
1565 
1566                         _irc_engine->NotifyListeners(LN_GotKilled, connection);
1567                 }
1568         }
1569         else
1570         {
1571                 /* consistency failure; KILLs should only be directed at the 
1572                  * affected user - either the server is lying or we lost track 
1573                  * of our nick */
1574                 goto nick_not_client;
1575 
1576         }
1577 
1578         ret = EIrcStatus::OK;
1579         goto cleanup;
1580 
1581 parse_failure:
1582         ret = EIrcStatus::ParsingError;
1583         goto cleanup;
1584 nick_not_client:
1585         std::cerr << fg_red << "Killed nickname '" << extracted_nickname <<
1586                 "' does not match the current client setting: '" <<
1587                 connection->Owner()->_client\&.nickname\&.c_str() << "'\n";
1588         ret = EIrcStatus::NickIsNotClient;
1589         goto cleanup;
1590 cleanup:
1591         FREE(extracted_nickname);
1592         FREE(extracted_message);
1593         return ret;
1594 }
.fi
.SS "bool IrcParser::HandleMode (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
\fBTodo\fP
.RS 4
complete me 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
; bring these in from configuration 
.RE
.PP

.PP
Definition at line 1560 of file bak/IrcParser\&.cc\&.
.PP
References IrcNetwork::_client, IrcConnection::_parent_network, IrcNetwork::_server, ircbuf_data::data, mode_update::erase_existing, fg_red(), FREE, IrcConnection::GetActivity(), IrcConnection::GetChannel(), IrcChannel::GetUser(), HasChannelPrefix(), irc_server::max_num_modes, ModeHasArgument(), irc_client::nickname, ParseParameters(), str_token(), mode_update::to_add, mode_update::to_remove, UM_Admin, UM_HalfOp, UM_None, UM_Op, UM_Owner, UM_Voice, UNREFERENCE_OBJECT, and IrcUser::Update()\&.
.PP
.nf
1565 {
1566         bool            ret = false;
1567         char*           extracted_target = nullptr;
1568         char*           extracted_changes = nullptr;
1569         char*           extracted_affected = nullptr;
1570         irc_activity&   activity = connection->GetActivity();
1571         IrcNetwork*     network = nullptr;
1572         IrcChannel*     channel = nullptr;
1573         char*           p = nullptr;
1574         char*           str = nullptr;
1575         char*           last = nullptr;
1576         char            delim[] = " ";
1577         bool            is_set = false;
1578         uint32_t                i;
1579         uint32_t                len;
1580         /* must be shared_ptr if a part of a vector! */
1581         std::vector< std::shared_ptr<mode_data> >       modes;
1582 
1583         /* Rizon:
1584         :$nickname!$ident@$hostmask MODE $nickname :+ix
1585         :$nickname!$ident@$hostmask MODE $channel +h $nickname
1586         */
1587 
1588         if ( !ParseParameters(data->data\&.c_str(), 3,
1589                 &extracted_target, &extracted_changes, &extracted_affected) )
1590                 goto parse_failure;
1591 
1592         network = connection->_parent_network;
1593 
1594         p = extracted_changes;
1595 
1596         if ( strcmp(extracted_target, network->_client\&.nickname\&.c_str()) == 0 )
1597         {
1598                 /* 'self' user mode */
1601                 // prepare the activity data, then inform our listeners
1602                 {
1603 
1604 
1605                         //_irc_engine->NotifyListeners(LN_, connection);
1606                 }
1607         }
1608         else if ( extracted_affected == nullptr || *extracted_affected == '\0' )
1609         {
1610                 /* simple channel/user modes - ms, ix, etc\&. */
1611 
1612                 /* some, not all, have a colon prefixed */
1613                 if ( *p == ':' )
1614                         p++;
1615 
1616                 while ( *p != '\0' )
1617                 {
1618                         if ( *p == '+' )
1619                                 is_set = true;
1620                         else if ( *p == '-' )
1621                                 is_set = false;
1622                         /* else the character is a continuation of the previous enable state */
1623                         else
1624                         {
1625                                 /* check if already at the limit */
1626                                 if ( modes\&.size() >= network->_server\&.max_num_modes )
1627                                         goto limit_exceeded;
1628 
1629                                 std::shared_ptr<mode_data>      mode(new mode_data);
1630 
1631                                 mode->is_enabled        = is_set;
1632                                 mode->mode              = *p;
1633                                 mode->has_data          = false;
1634                                 mode->data              = "";
1635 
1636                                 modes\&.push_back(mode);
1637                         }
1638                         p++;
1639                 }
1640 
1641                 /* use get_channel on extracted_target; if no channel is found, it is
1642                  * a user mode\&. Will use same functionality as below - merge the two */
1643         }
1644         else
1645         {
1646                 len = strlen(extracted_changes);
1647                 is_set = (*p == '+');
1648 
1649                 /* ensure we're starting with valid data; make no assumptions */
1650                 if ( *p != '+' && *p != '-' )
1651                         goto invalid_data;
1652 
1653                 for ( i = 1; i < len; i++ )
1654                 {
1655                         /* increment on loop entry and then every other iteration (entry
1656                          * will bring us to the first real character) */
1657                         p++;
1658                         if ( *p == '+' )
1659                                 is_set = true;
1660                         else if ( *p == '-' )
1661                                 is_set = false;
1662                         /* else the character is a continuation of the enable state */
1663                         else
1664                         {
1665                                 std::shared_ptr<mode_data>      mode(new mode_data);
1666 
1667                                 mode->is_enabled        = is_set;
1668                                 mode->mode              = *p;
1669                                 mode->data              = "";
1670 
1671                                 if ( ModeHasArgument(connection, is_set, *p) )
1672                                         mode->has_data = true;
1673 
1674                                 modes\&.push_back(mode);
1675                         }
1676                 }
1677 
1678                 p = extracted_affected;
1679                 str = str_token(p, delim, &last);
1680 
1681                 /* for every mode, assign the data if it requires any */
1682                 for ( auto m : modes )
1683                 {
1684                         /* only if it needs data; +m, +p, etc\&. do not have any data assigned! */
1685                         if ( m->has_data )
1686                         {
1687                                 if ( str == nullptr )
1688                                 {
1689                                         std::cerr << fg_red << "No data remaining for required assignment; server supplied invalid data\n";
1690                                 }
1691                                 else
1692                                 {
1693                                         m->data  = str;
1694                                 }
1695 
1696                                 str = str_token(nullptr, delim, &last);
1697                         }
1698                 }
1699 
1700                 if ( !HasChannelPrefix(connection, extracted_target) )
1701                 {
1702                         /* target was not a channel
1703                         ** @todo Use the 'activation' mode to trigger our auto-joins,
1704                         * auto-identifys, and any other commands */
1705                 }
1706                 else if ( (channel = connection->GetChannel(extracted_target)) == nullptr )
1707                 {
1708                         goto channel_not_found;
1709                 }
1710                 else
1711                 {
1712                         /* target was a channel, and we have it opened */
1713                         for ( auto m : modes )
1714                         {
1715                                 if ( !m->data\&.empty() )
1716                                 {
1717                                         mode_update     umu;
1718                                         uint16_t                update = UM_None;
1719                                         IrcUser*        user;
1720 
1722                                         /* also list against server modes (005 PREFIX) */
1723                                         const char      char_voice = 'v';
1724                                         const char      char_halfop = 'h';
1725                                         const char      char_op = 'o';
1726                                         const char      char_admin = 'a';
1727                                         const char      char_owner = 'q';
1728 
1729                                         /* @todo extract mode mappings */
1730                                         switch ( modes[i]->mode )
1731                                         {
1732                                         case char_voice:        update = UM_Voice; break;
1733                                         case char_halfop:       update = UM_HalfOp; break;
1734                                         case char_op:           update = UM_Op; break;
1735                                         case char_admin:        update = UM_Admin; break;
1736                                         case char_owner:        update = UM_Owner; break;
1737                                         default:
1738                                                 break;
1739                                         }
1740 
1741                                         if ( update != UM_None )
1742                                         {
1743                                                 user = channel->GetUser(m->data\&.c_str());
1744                                                 if ( user != nullptr )
1745                                                 {
1746                                                         umu\&.erase_existing = false;
1747                                                         umu\&.to_add = UM_None;
1748                                                         umu\&.to_remove = UM_None;
1749 
1750                                                         if ( modes[i]->is_enabled )
1751                                                                 umu\&.to_add = update;
1752                                                         else
1753                                                                 umu\&.to_remove = update;
1754 
1755                                                         user->Update(nullptr, nullptr, nullptr, &umu);
1756                                                 }
1757                                         }
1758                                 }
1759                         }
1760                 }
1761         }
1762 
1763         /* note: if the server is the sender, b & c will be NULL; affected can
1764          * be NULL or an additional 'list', depending on the mode type */
1765         /* a = sender_nick, b = sender_ident, c = sender_host, d = target, e = changes, f = affected */
1766         //add_ui_event(MC_Mode, connection, 6, sender->nickname, sender->ident, sender->hostmask, extracted_target, extracted_changes, extracted_affected);
1767         // @todo these must be put into each 'section' above
1768 
1769         ret = true;
1770         goto cleanup;
1771 
1772 parse_failure:
1773         goto cleanup;
1774 limit_exceeded:
1775         goto cleanup;
1776 invalid_data:
1777         goto cleanup;
1778 channel_not_found:
1779         std::cerr << fg_red << "The extracted target '" << extracted_target << "' could not be found\n";
1780         goto cleanup;
1781 cleanup:
1782         if ( channel != nullptr )
1783                 UNREFERENCE_OBJECT(channel);
1784         FREE(extracted_target);
1785         FREE(extracted_changes);
1786         FREE(extracted_affected);
1787         return ret;
1788 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandleMode (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses MODE
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
complete me 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
; bring these in from configuration 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
extract mode mappings 
.RE
.PP

.PP
Definition at line 1599 of file IrcParser\&.cc\&.
.PP
References ircbuf_data::data, mode_update::erase_existing, fg_red(), FREE, HasChannelPrefix(), InvalidData, LimitExceeded, ModeHasArgument(), ObjectNotFound, OK, ParseParameters(), ParsingError, str_token(), mode_update::to_add, mode_update::to_remove, UM_Admin, UM_HalfOp, UM_None, UM_Op, UM_Owner, UM_Voice, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1604 {
1605         std::shared_ptr<IrcNetwork>     network = nullptr;
1606         std::shared_ptr<IrcChannel>     channel = nullptr;
1607         EIrcStatus      ret = EIrcStatus::Unknown;
1608         char*           extracted_target = nullptr;
1609         char*           extracted_changes = nullptr;
1610         char*           extracted_affected = nullptr;
1611         irc_activity&   activity = connection->GetActivity();
1612         char*           p = nullptr;
1613         char*           str = nullptr;
1614         char*           last = nullptr;
1615         char            delim[] = " ";
1616         bool            is_set = false;
1617         uint32_t        i;
1618         uint32_t        len;
1619         // must be shared_ptr if a part of a vector!
1620         std::vector<std::shared_ptr<mode_data>> modes;
1621 
1622         /* Rizon:
1623         :$nickname!$ident@$hostmask MODE $nickname :+ix
1624         :$nickname!$ident@$hostmask MODE $channel +h $nickname
1625         */
1626 
1627         if ( !ParseParameters(data->data\&.c_str(), 3,
1628                 &extracted_target, &extracted_changes, &extracted_affected) )
1629                 goto parse_failure;
1630 
1631         network = connection->Owner();
1632 
1633         p = extracted_changes;
1634 
1635         if ( strcmp(extracted_target, network->_client\&.nickname\&.c_str()) == 0 )
1636         {
1637                 // 'self' user mode
1639 
1640                 // prepare the activity data, then inform our listeners
1641                 {
1642 
1643 
1644                         //_irc_engine->NotifyListeners(LN_, connection);
1645                 }
1646         }
1647         else if ( extracted_affected == nullptr || *extracted_affected == '\0' )
1648         {
1649                 // simple channel/user modes - ms, ix, etc\&.
1650 
1651                 // some, not all, have a colon prefixed
1652                 if ( *p == ':' )
1653                         p++;
1654 
1655                 while ( *p != '\0' )
1656                 {
1657                         if ( *p == '+' )
1658                                 is_set = true;
1659                         else if ( *p == '-' )
1660                                 is_set = false;
1661                         // else the character is a continuation of the previous enable state
1662                         else
1663                         {
1664                                 // check if already at the limit
1665                                 if ( modes\&.size() >= network->_server\&.max_num_modes )
1666                                         goto limit_exceeded;
1667 
1668                                 std::shared_ptr<mode_data>      mode(new mode_data);
1669 
1670                                 mode->is_enabled        = is_set;
1671                                 mode->mode              = *p;
1672                                 mode->has_data          = false;
1673                                 mode->data              = "";
1674 
1675                                 modes\&.push_back(mode);
1676                         }
1677                         p++;
1678                 }
1679 
1680                 /* use get_channel on extracted_target; if no channel is found, 
1681                  * it is a user mode\&. Will use same functionality as below - 
1682                  * need to merge the two */
1683         }
1684         else
1685         {
1686                 len = strlen(extracted_changes);
1687                 is_set = (*p == '+');
1688 
1689                 // ensure we're starting with valid data; make no assumptions
1690                 if ( *p != '+' && *p != '-' )
1691                         goto invalid_data;
1692 
1693                 for ( i = 1; i < len; i++ )
1694                 {
1695                         /* increment on loop entry and then every other iteration (entry
1696                          * will bring us to the first real character) */
1697                         p++;
1698                         if ( *p == '+' )
1699                                 is_set = true;
1700                         else if ( *p == '-' )
1701                                 is_set = false;
1702                         // else the character is a continuation of the enable state
1703                         else
1704                         {
1705                                 std::shared_ptr<mode_data>      mode(new mode_data);
1706 
1707                                 mode->is_enabled        = is_set;
1708                                 mode->mode              = *p;
1709                                 mode->data              = "";
1710 
1711                                 if ( ModeHasArgument(connection, is_set, *p) )
1712                                         mode->has_data = true;
1713 
1714                                 modes\&.push_back(mode);
1715                         }
1716                 }
1717 
1718                 p = extracted_affected;
1719                 str = str_token(p, delim, &last);
1720 
1721                 // for every mode, assign the data if it requires any
1722                 for ( auto m : modes )
1723                 {
1724                         // only if it needs data; +m, +p, etc\&. do not have any data assigned!
1725                         if ( m->has_data )
1726                         {
1727                                 if ( str == nullptr )
1728                                 {
1729                                         std::cerr << fg_red << "No data remaining for required assignment; server supplied invalid data\n";
1730                                 }
1731                                 else
1732                                 {
1733                                         m->data  = str;
1734                                 }
1735 
1736                                 str = str_token(nullptr, delim, &last);
1737                         }
1738                 }
1739 
1740                 if ( !HasChannelPrefix(connection, extracted_target) )
1741                 {
1742                         // target was not a channel
1743 
1744                 }
1745                 else if ( (channel = connection->GetChannel(extracted_target)) == nullptr )
1746                 {
1747                         goto channel_not_found;
1748                 }
1749                 else
1750                 {
1751                         // target was a channel, and we have it opened
1752                         for ( auto m : modes )
1753                         {
1754                                 if ( !m->data\&.empty() )
1755                                 {
1756                                         mode_update     umu;
1757                                         uint16_t                update = UM_None;
1758                                         std::shared_ptr<IrcUser>        user;
1759 
1761                                         // also list against server modes (005 PREFIX)
1762                                         const char      char_voice = 'v';
1763                                         const char      char_halfop = 'h';
1764                                         const char      char_op = 'o';
1765                                         const char      char_admin = 'a';
1766                                         const char      char_owner = 'q';
1767 
1769                                         switch ( modes[i]->mode )
1770                                         {
1771                                         case char_voice:        update = UM_Voice; break;
1772                                         case char_halfop:       update = UM_HalfOp; break;
1773                                         case char_op:           update = UM_Op; break;
1774                                         case char_admin:        update = UM_Admin; break;
1775                                         case char_owner:        update = UM_Owner; break;
1776                                         default:
1777                                                 break;
1778                                         }
1779 
1780                                         if ( update != UM_None )
1781                                         {
1782                                                 user = channel->GetUser(m->data\&.c_str());
1783                                                 if ( user != nullptr )
1784                                                 {
1785                                                         umu\&.erase_existing = false;
1786                                                         umu\&.to_add = UM_None;
1787                                                         umu\&.to_remove = UM_None;
1788 
1789                                                         if ( modes[i]->is_enabled )
1790                                                                 umu\&.to_add = update;
1791                                                         else
1792                                                                 umu\&.to_remove = update;
1793 
1794                                                         user->Update(nullptr, nullptr, nullptr, &umu);
1795                                                 }
1796                                         }
1797                                 }
1798                         }
1799                 }
1800         }
1801 
1802         /* note: if the server is the sender, b & c will be NULL; affected can
1803          * be NULL or an additional 'list', depending on the mode type */
1804         /* a = sender_nick, b = sender_ident, c = sender_host, d = target, e = changes, f = affected */
1805         //add_ui_event(MC_Mode, connection, 6, sender->nickname, sender->ident, sender->hostmask, extracted_target, extracted_changes, extracted_affected);
1806         // @todo these must be put into each 'section' above
1807 
1808         ret = EIrcStatus::OK;
1809         goto cleanup;
1810 
1811 parse_failure:
1812         ret = EIrcStatus::ParsingError;
1813         goto cleanup;
1814 limit_exceeded:
1815         ret = EIrcStatus::LimitExceeded;
1816         goto cleanup;
1817 invalid_data:
1818         ret = EIrcStatus::InvalidData;
1819         goto cleanup;
1820 channel_not_found:
1821         std::cerr << fg_red << "The extracted target '" << extracted_target << "' could not be found\n";
1822         ret = EIrcStatus::ObjectNotFound;
1823         goto cleanup;
1824 cleanup:
1825         FREE(extracted_target);
1826         FREE(extracted_changes);
1827         FREE(extracted_affected);
1828         return ret;
1829 }
.fi
.SS "bool IrcParser::HandleNick (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
\fBTodo\fP
.RS 4
What if we're in no channels, but are querying with a user who changes nick\&.\&.\&. 
.RE
.PP

.PP
Definition at line 1793 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::_channel_list, IrcNetwork::_client, IrcObject::_irc_engine, IrcConnection::_parent_network, ircbuf_data::data, IrcConnection::GetActivity(), LN_GotNickChanged, LN_Nick, irc_client::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), and IrcUser::Update()\&.
.PP
.nf
1798 {
1799         bool            ret = false;
1800         IrcNetwork*     network = nullptr;
1801         IrcUser*        user = nullptr;
1802         irc_activity&   activity = connection->GetActivity();
1803         std::string     new_nick;
1804 
1805         /* Rizon:
1806         :$nickname!$ident@$hostmask NICK :$new_nick
1807         */
1808 
1809         if ( data->data[0] != ':' )
1810                 goto invalid_data;
1811 
1812         network = connection->_parent_network;
1813 
1814         new_nick = (data->data\&.substr(1));
1815 
1816         if ( sender->nickname\&.compare(network->_client\&.nickname) == 0 )
1817         {
1818                 /* our own nickname has been changed; loop through all the channels
1819                  * we're in and update them, then update our internal client info */
1820 
1821                 for ( auto channel : connection->_channel_list )
1822                 {
1823                         if ( !channel->IsActive() )
1824                                 continue;
1825 
1826                         if (( user = channel->GetUser(network->_client\&.nickname\&.c_str())) == nullptr )
1827                         {
1828                                 /* since this is us, we MUST be in every channel
1829                                  * if it is active */
1830                                 goto not_found;
1831                         }
1832 
1833                         user->Update(new_nick\&.c_str(), nullptr, nullptr, nullptr);
1834 
1835                         /* we don't notify for each channel; the listener is
1836                          * responsible for handling it (e\&.g\&. outputting our own
1837                          * nick change on each channel window for the GUI) */
1838                 }
1839 
1840                 /* finally, update the client settings */
1841                 network->_client\&.nickname        = new_nick\&.c_str();
1842 
1843                 // prepare the activity data, then inform our listeners
1844                 {
1845 
1846 
1847                         _irc_engine->NotifyListeners(LN_GotNickChanged, connection);
1848                 }
1849         }
1850         else
1851         {
1852                 /* another user has updated their nick in at least one of the channels
1853                  * we are in - loop through them all and update as necessary */
1854 
1855                 for ( auto channel : connection->_channel_list )
1856                 {
1857                         if (( user = channel->GetUser(sender->nickname\&.c_str())) != nullptr )
1858                         {
1859                                 user->Update(new_nick\&.c_str(), nullptr, nullptr, nullptr);
1860                         }
1861                         else
1862                         {
1863                         }
1864                 }
1865 
1869                 // prepare the activity data, then inform our listeners
1870                 {
1871 
1872 
1873                         _irc_engine->NotifyListeners(LN_Nick, connection);
1874                 }
1875         }
1876 
1877         ret = true;
1878         goto cleanup;
1879 
1880 invalid_data:
1881         goto cleanup;
1882 not_found:
1883         goto cleanup;
1884 cleanup:
1885         return ret;
1886 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandleNick (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses NICK
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 1834 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, LN_GotNickChanged, LN_Nick, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), ObjectNotFound, OK, ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1839 {
1840         std::shared_ptr<IrcNetwork>     network = nullptr;
1841         std::shared_ptr<IrcUser>        user = nullptr;
1842         EIrcStatus      ret = EIrcStatus::Unknown;
1843         irc_activity&   activity = connection->GetActivity();
1844         std::string     new_nick;
1845 
1846         /* Rizon:
1847         :$nickname!$ident@$hostmask NICK :$new_nick
1848         */
1849 
1850         if ( data->data[0] != ':' )
1851                 goto invalid_data;
1852 
1853         network = connection->Owner();
1854 
1855         new_nick = (data->data\&.substr(1));
1856 
1857         if ( sender->nickname\&.compare(network->_client\&.nickname) == 0 )
1858         {
1859                 // our own nickname has been changed; update our client info
1860 
1861                 network->_client\&.nickname        = new_nick\&.c_str();
1862 
1863                 // prepare the activity data, then inform our listeners
1864                 {
1865 
1866 
1867                         _irc_engine->NotifyListeners(LN_GotNickChanged, connection);
1868                 }
1869         }
1870         else
1871         {
1872 #if 0
1873                 /* another user has updated their nick in at least one of the channels
1874                  * we are in - loop through them all and update as necessary */
1875 
1876                 for ( auto channel : connection->_channel_list )
1877                 {
1878                         if (( user = channel->GetUser(sender->nickname\&.c_str())) != nullptr )
1879                         {
1880                                 user->Update(new_nick\&.c_str(), nullptr, nullptr, nullptr);
1881                         }
1882                         else
1883                         {
1884                         }
1885                 }
1886 
1889 #endif
1890 
1891                 // prepare the activity data, then inform our listeners
1892                 {
1893 
1894 
1895                         _irc_engine->NotifyListeners(LN_Nick, connection);
1896                 }
1897         }
1898 
1899         ret = EIrcStatus::OK;
1900         goto cleanup;
1901 
1902 invalid_data:
1903         ret = EIrcStatus::ParsingError;
1904         goto cleanup;
1905 not_found:
1906         ret = EIrcStatus::ObjectNotFound;
1907         goto cleanup;
1908 cleanup:
1909         return ret;
1910 }
.fi
.SS "bool IrcParser::HandleNotice (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
\fBTodo\fP
.RS 4
complete me 
.RE
.PP

.PP
Definition at line 1891 of file bak/IrcParser\&.cc\&.
.PP
References IrcNetwork::_client, IrcNetwork::_network_config, IrcConnection::_parent_network, IrcNetwork::_profile_config, config_network::auto_exec_commands, config_profile::auto_identify, config_network::auto_join_channels, config_profile::autoident_password, config_profile::autoident_service, config_network::channels, config_network::commands, ircbuf_data::data, FREE, IrcConnection::GetActivity(), HasChannelPrefix(), IrcConnection::IsActive(), irc_client::nickname, ParseParameters(), IrcConnection::SendIdentify(), IrcConnection::SendJoin(), and IrcConnection::SendRaw()\&.
.PP
.nf
1896 {
1897         bool            ret = false;
1898         char*           extracted_destination = nullptr;
1899         char*           extracted_message = nullptr;
1900         irc_activity&   activity = connection->GetActivity();
1901         IrcNetwork*     network = connection->_parent_network;
1902 
1903         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_destination, &extracted_message) )
1904                 goto parse_failure;
1905 
1906         if ( HasChannelPrefix(connection, extracted_destination) )
1907         {
1910         }
1911         else
1912         {
1913 
1914                 // Hybrid, Quakenet, InspIRCd, efnet: 'AUTH'
1915                 // Freenode: '*'
1916 
1917                 if ( network->_client\&.nickname\&.empty() )
1918                 {
1919                         char    preauth[] = "AUTH";
1920                         char    preauth_freenode[] = "*";
1921 
1922                         if ( strcmp(extracted_destination, preauth) == 0 ||
1923                                 strcmp(extracted_destination, preauth_freenode) == 0 )
1924                         {
1925                                 /* pre-connection notice; own nickname not confirmed\&. When
1926                                  * using CAPS, we get our nickname back assuming there is
1927                                  * no conflict - otherwise the first we can 100% confirm
1928                                  * the server + client are in sync is in the 001 */
1929                         }
1930                 }
1931                 else if ( strcmp(extracted_destination, network->_client\&.nickname\&.c_str()) == 0 )
1932                 {
1933                         /* the notice was directed at us */
1934 
1935                         static bool     init_sent = false;
1936 
1937                         if ( !connection->IsActive() && !init_sent )
1938                         {
1939                                 /* connection not yet sustained, so send through
1940                                  * any initialization to perform */
1941 
1942                                 init_sent = true;
1943 
1944                                 if ( network->_profile_config\&.auto_identify )
1945                                 {
1946                                         connection->SendIdentify(
1947                                                 network->_profile_config\&.autoident_service\&.c_str(),
1948                                                 network->_profile_config\&.autoident_password\&.c_str());
1949                                 }
1950                                 if ( network->_network_config\&.auto_exec_commands )
1951                                 {
1952                                         for ( auto cmd : network->_network_config\&.commands )
1953                                         {
1954                                                 connection->SendRaw(cmd\&.c_str());
1955                                         }
1956                                 }
1957                                 if ( network->_network_config\&.auto_join_channels )
1958                                 {
1959                                         for ( auto channel : network->_network_config\&.channels )
1960                                         {
1961                                                 connection->SendJoin(channel\&.c_str());
1962                                         }
1963                                 }
1964                         }
1965                 }
1966         }
1967 
1968         ret = true;
1969         goto cleanup;
1970 
1971 parse_failure:
1972         goto cleanup;
1973 cleanup:
1974         FREE(extracted_destination);
1975         FREE(extracted_message);
1976         return ret;
1977 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandleNotice (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses NOTICE
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
complete me 
.RE
.PP

.PP
Definition at line 1915 of file IrcParser\&.cc\&.
.PP
References ircbuf_data::data, FREE, HasChannelPrefix(), OK, ParseParameters(), ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
1920 {
1921         std::shared_ptr<IrcNetwork>     network = connection->Owner();
1922         EIrcStatus      ret = EIrcStatus::Unknown;
1923         char*           extracted_destination = nullptr;
1924         char*           extracted_message = nullptr;
1925         irc_activity&   activity = connection->GetActivity();
1926         
1927 
1928         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_destination, &extracted_message) )
1929                 goto parse_failure;
1930 
1931         if ( HasChannelPrefix(connection, extracted_destination) )
1932         {
1935         }
1936         else
1937         {
1938 
1939                 // Hybrid, Quakenet, InspIRCd, efnet: 'AUTH'
1940                 // Freenode: '*'
1941 
1942                 if ( network->_client\&.nickname\&.empty() )
1943                 {
1944                         char    preauth[] = "AUTH";
1945                         char    preauth_freenode[] = "*";
1946 
1947                         if ( strcmp(extracted_destination, preauth) == 0 ||
1948                                 strcmp(extracted_destination, preauth_freenode) == 0 )
1949                         {
1950                                 /* pre-connection notice; own nickname not confirmed\&. When
1951                                  * using CAPS, we get our nickname back assuming there is
1952                                  * no conflict - otherwise the first we can 100% confirm
1953                                  * the server + client are in sync is in the 001 */
1954                         }
1955                 }
1956                 else if ( strcmp(extracted_destination, network->_client\&.nickname\&.c_str()) == 0 )
1957                 {
1958                         // the notice was directed at us
1959 
1960                         static bool     init_sent = false;
1961 
1962                         if ( !connection->IsActive() && !init_sent )
1963                         {
1964                                 /* connection not yet sustained, so send through
1965                                  * any initialization to perform */
1966 
1967                                 init_sent = true;
1968 
1969                                 if ( network->_profile_config\&.auto_identify )
1970                                 {
1971                                         connection->SendIdentify(
1972                                                 network->_profile_config\&.autoident_service\&.c_str(),
1973                                                 network->_profile_config\&.autoident_password\&.c_str());
1974                                 }
1975                                 if ( network->_network_config\&.auto_exec_commands )
1976                                 {
1977                                         for ( auto cmd : network->_network_config\&.commands )
1978                                         {
1979                                                 connection->SendRaw(cmd\&.c_str());
1980                                         }
1981                                 }
1982                                 if ( network->_network_config\&.auto_join_channels )
1983                                 {
1984                                         for ( auto channel : network->_network_config\&.channels )
1985                                         {
1986                                                 connection->SendJoin(channel\&.c_str());
1987                                         }
1988                                 }
1989                         }
1990                 }
1991         }
1992 
1993         ret = EIrcStatus::OK;
1994         goto cleanup;
1995 
1996 parse_failure:
1997         ret = EIrcStatus::ParsingError;
1998         goto cleanup;
1999 cleanup:
2000         FREE(extracted_destination);
2001         FREE(extracted_message);
2002         return ret;
2003 }
.fi
.SS "bool IrcParser::HandlePart (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
\fBTodo\fP
.RS 4
Close & delete the channel if not configured to remain open, notify() - special, auto-delete, what? 
.RE
.PP

.PP
Definition at line 1982 of file bak/IrcParser\&.cc\&.
.PP
References IrcNetwork::_client, IrcChannel::_flags, IrcObject::_irc_engine, IrcConnection::_parent_network, CHANFLAG_RAW, ircbuf_data::data, IrcChannel::DeleteUser(), IrcChannel::EraseUserlist(), IrcConnection::GetActivity(), IrcConnection::GetChannel(), IrcChannel::GetUser(), LN_Part, LN_WeParted, irc_client::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), ParseParameters(), and UNREFERENCE_OBJECT\&.
.PP
.nf
1987 {
1988         bool            ret = false;
1989         IrcNetwork*     network = nullptr;
1990         IrcChannel*     channel = nullptr;
1991         IrcUser*        user = nullptr;
1992         char*           extracted_channel = nullptr;
1993         char*           extracted_message = nullptr;
1994         irc_activity&   activity = connection->GetActivity();
1995 
1996         network = connection->_parent_network;
1997 
1998         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_channel, &extracted_message) )
1999                 goto parse_failure;
2000 
2001         /* locate the channel the user was in, and remove them from it */
2002 
2003         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
2004                 goto channel_not_found;
2005 
2006 
2007         if ( sender->nickname\&.compare(network->_client\&.nickname) == 0 )
2008         {
2009                 /* we're the one that parted - channel is now inactive */
2010 
2011                 channel->_flags = CHANFLAG_RAW;
2012 
2016                 // prepare the activity data, then inform our listeners
2017                 {
2018 
2019 
2020                         _irc_engine->NotifyListeners(LN_WeParted, connection);
2021                 }
2022 
2023                 channel->EraseUserlist();
2024         }
2025         else
2026         {
2027                 if (( user = channel->GetUser(sender->nickname\&.c_str())) != nullptr )
2028                 {
2029                         /*sn\&.channel     = channel;
2030                         sn\&.hostmask      = user->Hostmask();
2031                         sn\&.ident = user->Ident();
2032                         sn\&.nickname      = user->Nickname();
2033                         sn\&.message       = extracted_message;*/
2034 
2035                         // prepare the activity data, then inform our listeners
2036                         {
2037 
2038 
2039                                 _irc_engine->NotifyListeners(LN_Part, connection);
2040                         }
2041 
2042                         channel->DeleteUser(user);
2043                 }
2044         }
2045 
2046         ret = true;
2047         goto cleanup;
2048 
2049 parse_failure:
2050         goto cleanup;
2051 channel_not_found:
2052         goto cleanup;
2053 cleanup:
2054         if ( channel != nullptr )
2055                 UNREFERENCE_OBJECT(channel);
2056         return ret;
2057 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandlePart (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses PART
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
Close & delete the channel if not configured to remain open, notify() - special, auto-delete, what? 
.RE
.PP

.PP
Definition at line 2008 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, CHANFLAG_RAW, ircbuf_data::data, LN_Part, LN_WeParted, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), ObjectNotFound, OK, ParseParameters(), ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
2013 {
2014         std::shared_ptr<IrcNetwork>     network = nullptr;
2015         std::shared_ptr<IrcChannel>     channel = nullptr;
2016         std::shared_ptr<IrcUser>        user = nullptr;
2017         EIrcStatus      ret = EIrcStatus::Unknown;
2018         char*           extracted_channel = nullptr;
2019         char*           extracted_message = nullptr;
2020         irc_activity&   activity = connection->GetActivity();
2021 
2022         network = connection->Owner();
2023 
2024         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_channel, &extracted_message) )
2025                 goto parse_failure;
2026 
2027         // locate the channel the user was in, and remove them from it
2028 
2029         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
2030                 goto channel_not_found;
2031 
2032 
2033         if ( sender->nickname\&.compare(network->_client\&.nickname) == 0 )
2034         {
2035                 // we're the one that parted - channel is now inactive
2036 
2037                 channel->_flags = CHANFLAG_RAW;
2038 
2042                 // prepare the activity data, then inform our listeners
2043                 {
2044 
2045 
2046                         _irc_engine->NotifyListeners(LN_WeParted, connection);
2047                 }
2048 
2049                 channel->EraseUserlist();
2050         }
2051         else
2052         {
2053                 if (( user = channel->GetUser(sender->nickname\&.c_str())) != nullptr )
2054                 {
2055                         /*sn\&.channel     = channel;
2056                         sn\&.hostmask      = user->Hostmask();
2057                         sn\&.ident = user->Ident();
2058                         sn\&.nickname      = user->Nickname();
2059                         sn\&.message       = extracted_message;*/
2060 
2061                         // prepare the activity data, then inform our listeners
2062                         {
2063 
2064 
2065                                 _irc_engine->NotifyListeners(LN_Part, connection);
2066                         }
2067 
2068                         channel->DeleteUser(user);
2069                 }
2070         }
2071 
2072         ret = EIrcStatus::OK;
2073         goto cleanup;
2074 
2075 parse_failure:
2076         ret = EIrcStatus::ParsingError;
2077         goto cleanup;
2078 channel_not_found:
2079         ret = EIrcStatus::ObjectNotFound;
2080         goto cleanup;
2081 cleanup:
2082         return ret;
2083 }
.fi
.SS "bool IrcParser::HandlePong (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
\fBTodo\fP
.RS 4
compare recv time with sent time to determine lag 
.RE
.PP

.PP
Definition at line 2062 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::_lag_sent, and IrcConnection::GetActivity()\&.
.PP
.nf
2067 {
2068         irc_activity&   activity = connection->GetActivity();
2069 
2070         /* reply from our lag message */
2071         connection->_lag_sent = 0;
2072 
2075         return true;
2076 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandlePong (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses PONG
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
compare recv time with sent time to determine lag 
.RE
.PP

.PP
Definition at line 2088 of file IrcParser\&.cc\&.
.PP
References OK\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
2093 {
2094         irc_activity&   activity = connection->GetActivity();
2095 
2096         // reply from our lag message
2097         connection->_lag_sent = 0;
2098 
2101         return EIrcStatus::OK;
2102 }
.fi
.SS "bool IrcParser::HandlePrivmsg (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
\fBTodo\fP
.RS 4
readd terminating \\001 check; feeling lazy atm 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
Same code as privmsg? 
.RE
.PP

.PP
Definition at line 2081 of file bak/IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, irc_activity::channel_name, irc_activity::data, ircbuf_data::data, fg_red(), FREE, IrcConnection::GetActivity(), IrcConnection::GetChannel(), HasChannelPrefix(), irc_activity::hostmask, ircbuf_sender::hostmask, irc_activity::ident, ircbuf_sender::ident, irc_activity::instigator, LN_Privmsg, irc_activity::message, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), ParseParameters(), IrcConnection::SendBypass(), and UNREFERENCE_OBJECT\&.
.PP
.nf
2086 {
2087         bool            ret = false;
2088         IrcChannel*     channel = nullptr;
2089         char*           extracted_destination = nullptr;
2090         char*           extracted_message = nullptr;
2091         irc_activity&   activity = connection->GetActivity();
2092         char            *p = nullptr;
2093 
2094         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_destination, &extracted_message) )
2095                 goto parse_failure;
2096 
2098         if (    *extracted_message == '\001' &&
2099                 *(extracted_message + 1) != '\0' )
2100                 //extracted_message[(strlen(extracted_message)-1)] == '\001' )
2101         {
2102                 /* CTCP message */
2103 
2104                 /* move up to the first real character */
2105                 p = (extracted_message + 1);
2106 
2107                 if ( strncmp(p, "ACTION", 6) == 0 )
2108                 {
2109                         /* CTCP ACTION - 'me' style privmsg */
2110 
2113                         // prepare the activity data, then inform our listeners
2114                         {
2115 
2116 
2117                                 //_irc_engine->NotifyListeners(LN_CtcpAction, connection);
2118                         }
2119                 }
2120                 else
2121                 {
2122                         if ( strncmp(p, "VERSION", 7) == 0 )
2123                         {
2124                                 /* CTCP VERSION */
2125 
2126                                 connection->SendBypass("NOTICE %s :\001VERSION %s\001\r\n",
2127                                         sender->nickname\&.c_str(), "Trezanik IRC");
2128 
2129                                 // prepare the activity data, then inform our listeners
2130                                 {
2131 
2132 
2133                                         //_irc_engine->NotifyListeners(LN_CtcpVersion, connection);
2134                                 }
2135                         }
2136                         /* @todo Handle the other CTCPs */
2137                 }
2138 
2139         }
2140         else
2141         {
2142                 /* Didn't contain a CTCP prefix/suffix */
2143 
2144                 activity\&.instigator\&.hostmask      = sender->hostmask;
2145                 activity\&.instigator\&.ident = sender->ident;
2146                 activity\&.instigator\&.nickname      = sender->nickname;
2147                 activity\&.message         = extracted_message;
2148 
2149                 if ( HasChannelPrefix(connection, extracted_destination) )
2150                 {
2151                         /* channel message */
2152 
2153                         if (( channel = connection->GetChannel(extracted_destination)) == nullptr )
2154                                 goto channel_not_found;
2155 
2156                         activity\&.channel_name    = extracted_destination;
2157                 }
2158                 else
2159                 {
2160                         /* query message */
2161                         activity\&.data            = extracted_destination;
2162                 }
2163 
2164 
2165                 {
2166                         _irc_engine->NotifyListeners(LN_Privmsg, connection);
2167                 }
2168         }
2169 
2170         ret = true;
2171         goto cleanup;
2172 
2173 parse_failure:
2174         goto cleanup;
2175 channel_not_found:
2176         std::cerr << fg_red << "The extracted channel '" << extracted_destination << "' could not be found\n";
2177         goto cleanup;
2178 cleanup:
2179         if ( channel != nullptr )
2180                 UNREFERENCE_OBJECT(channel);
2181         FREE(extracted_destination);
2182         FREE(extracted_message);
2183         return ret;
2184 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandlePrivmsg (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses PRIVMSG
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
readd terminating \\001 check; feeling lazy atm 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
Same code as privmsg? 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
Handle the other CTCPs 
.RE
.PP

.PP
Definition at line 2107 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, irc_activity::channel_name, irc_activity::data, ircbuf_data::data, fg_red(), FREE, HasChannelPrefix(), irc_activity::hostmask, ircbuf_sender::hostmask, irc_activity::ident, ircbuf_sender::ident, irc_activity::instigator, LN_Privmsg, irc_activity::message, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), ObjectNotFound, OK, ParseParameters(), ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
2112 {
2113         std::shared_ptr<IrcChannel>     channel = nullptr;
2114         EIrcStatus      ret = EIrcStatus::Unknown;
2115         char*           extracted_destination = nullptr;
2116         char*           extracted_message = nullptr;
2117         irc_activity&   activity = connection->GetActivity();
2118         char            *p = nullptr;
2119 
2120         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_destination, &extracted_message) )
2121                 goto parse_failure;
2122 
2124         if (    *extracted_message == '\001' &&
2125                 *(extracted_message + 1) != '\0' )
2126                 //extracted_message[(strlen(extracted_message)-1)] == '\001' )
2127         {
2128                 // CTCP message
2129 
2130                 // move up to the first real character
2131                 p = (extracted_message + 1);
2132 
2133                 if ( strncmp(p, "ACTION", 6) == 0 )
2134                 {
2135                         // CTCP ACTION - 'me' style privmsg
2136 
2139                         // prepare the activity data, then inform our listeners
2140                         {
2141 
2142 
2143                                 //_irc_engine->NotifyListeners(LN_CtcpAction, connection);
2144                         }
2145                 }
2146                 else
2147                 {
2148                         if ( strncmp(p, "VERSION", 7) == 0 )
2149                         {
2150                                 // CTCP VERSION
2151 
2152                                 connection->SendBypass("NOTICE %s :\001VERSION %s\001\r\n",
2153                                         sender->nickname\&.c_str(), "Trezanik IRC");
2154 
2155                                 // prepare the activity data, then inform our listeners
2156                                 {
2157 
2158 
2159                                         //_irc_engine->NotifyListeners(LN_CtcpVersion, connection);
2160                                 }
2161                         }
2163                 }
2164 
2165         }
2166         else
2167         {
2168                 // Didn't contain a CTCP prefix/suffix
2169 
2170                 activity\&.instigator\&.hostmask      = sender->hostmask;
2171                 activity\&.instigator\&.ident = sender->ident;
2172                 activity\&.instigator\&.nickname      = sender->nickname;
2173                 activity\&.message         = extracted_message;
2174 
2175                 if ( HasChannelPrefix(connection, extracted_destination) )
2176                 {
2177                         // channel message
2178 
2179                         if (( channel = connection->GetChannel(extracted_destination)) == nullptr )
2180                                 goto channel_not_found;
2181 
2182                         activity\&.channel_name    = extracted_destination;
2183                 }
2184                 else
2185                 {
2186                         // query message
2187                         activity\&.data            = extracted_destination;
2188                 }
2189 
2190 
2191                 {
2192                         _irc_engine->NotifyListeners(LN_Privmsg, connection);
2193                 }
2194         }
2195 
2196         ret = EIrcStatus::OK;
2197         goto cleanup;
2198 
2199 parse_failure:
2200         ret = EIrcStatus::ParsingError;
2201         goto cleanup;
2202 channel_not_found:
2203         std::cerr << fg_red << "The extracted channel '" << extracted_destination << "' could not be found\n";
2204         ret = EIrcStatus::ObjectNotFound;
2205         goto cleanup;
2206 cleanup:
2207         FREE(extracted_destination);
2208         FREE(extracted_message);
2209         return ret;
2210 }
.fi
.SS "bool IrcParser::HandleQuit (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
Definition at line 2189 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::_channel_list, IrcNetwork::_client, IrcObject::_irc_engine, IrcConnection::_parent_network, ircbuf_data::data, IrcConnection::EraseChannelList(), fg_red(), IrcConnection::GetActivity(), irc_activity::hostmask, ircbuf_sender::hostmask, irc_activity::ident, ircbuf_sender::ident, irc_activity::instigator, LN_Quit, LN_WeQuit, irc_activity::message, irc_client::nickname, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), and UNREFERENCE_OBJECT\&.
.PP
.nf
2194 {
2195         bool            ret = false;
2196         IrcUser*        user = nullptr;
2197         irc_activity&   activity = connection->GetActivity();
2198         std::string     quit_message;
2199         uint32_t        num_affected = 0;
2200 
2201         /* no point using parse_parameters, only 1 'field' */
2202         if ( data->data[0] != ':' )
2203                 goto invalid_data;
2204 
2205         quit_message = data->data\&.substr(1);     /* either a nul or remainder of string */
2206 
2207         if ( sender->nickname\&.compare(connection->_parent_network->_client\&.nickname) == 0 )
2208         {
2209                 /* we're the one quitting the network - !!TODO:: were we expecting it?
2210                  * If the server wants us out it will/should call KILL */
2211 
2212                 /* how far do we want to cleanup the connection? Destroying all channels
2213                  * may not actually be desired - just remove CHANFLAG_ACTIVE? */
2214 
2215                 connection->EraseChannelList();
2216 
2217                 // prepare the activity data, then inform our listeners
2218                 {
2219 
2220 
2221                         _irc_engine->NotifyListeners(LN_WeQuit, connection);
2222                 }
2223         }
2224         else
2225         {
2226                 // prepare the activity data, then inform our listeners
2227                 {
2228                         activity\&.instigator\&.nickname      = sender->nickname;
2229                         activity\&.instigator\&.ident = sender->ident;
2230                         activity\&.instigator\&.hostmask      = sender->hostmask;
2231                         activity\&.message = quit_message;
2232 
2233                         _irc_engine->NotifyListeners(LN_Quit, connection);
2234                 }
2235 
2236                 /* remove the user leaving from all channels we're maintaining */
2237                 for ( auto channel : connection->_channel_list )
2238                 {
2239                         if (( user = channel->GetUser(sender->nickname\&.c_str())) != nullptr )
2240                         {
2241                                 // caveat: must dereference before delete!
2242                                 UNREFERENCE_OBJECT(user);
2243                                 channel->DeleteUser(user);
2244                                 num_affected++;
2245                         }
2246 
2247                 }
2248 
2249                 /* query windows? */
2250 
2251                 if ( num_affected == 0 )
2252                 {
2253                         /* we received the message, so there must/should be at least one
2254                          * channel that is affected\&.\&. */
2255                         std::cerr << fg_red << "Received a QUIT, but no users were affected\&. Recommend restart, possible corruption\n";
2256                 }
2257         }
2258 
2259         ret = true;
2260         goto cleanup;
2261 
2262 invalid_data:
2263         std::cerr << fg_red << "Invalid data: " << data->data\&.c_str();
2264         goto cleanup;
2265 cleanup:
2266         return ret;
2267 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandleQuit (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses QUIT
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 2215 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ObjectPool< T >::Allocated(), ircbuf_data::data, fg_red(), irc_activity::hostmask, ircbuf_sender::hostmask, irc_activity::ident, ircbuf_sender::ident, irc_activity::instigator, InvalidData, IrcPool::IrcChannels(), LN_Quit, LN_WeQuit, irc_activity::message, irc_activity::nickname, ircbuf_sender::nickname, IrcEngine::NotifyListeners(), OK, IrcEngine::Pools(), and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
2220 {
2221         std::shared_ptr<IrcUser>        user = nullptr;
2222         //std::shared_ptr<IrcNetwork>   network = nullptr;
2223         EIrcStatus      ret = EIrcStatus::Unknown;
2224         irc_activity&   activity = connection->GetActivity();
2225         std::string     quit_message;
2226         uint32_t        num_affected = 0;
2227 
2228         // no point using parse_parameters, only 1 'field'
2229         if ( data->data[0] != ':' )
2230                 goto invalid_data;
2231 
2232         // either a nul or remainder of string
2233         quit_message = data->data\&.substr(1);
2234 
2235         if ( sender->nickname\&.compare(connection->Owner()->_client\&.nickname) == 0 )
2236         {
2237                 /* we're the one quitting the network - !!TODO:: were we expecting it?
2238                  * If the server wants us out it will/should call KILL */
2239 
2240                 /* how far do we want to cleanup the connection? Destroying all channels
2241                  * may not actually be desired - just remove CHANFLAG_ACTIVE? */
2242 
2243                 connection->EraseChannelList();
2244 
2245                 // prepare the activity data, then inform our listeners
2246                 {
2247 
2248 
2249                         _irc_engine->NotifyListeners(LN_WeQuit, connection);
2250                 }
2251         }
2252         else
2253         {
2254                 // prepare the activity data, then inform our listeners
2255                 {
2256                         activity\&.instigator\&.nickname      = sender->nickname;
2257                         activity\&.instigator\&.ident = sender->ident;
2258                         activity\&.instigator\&.hostmask      = sender->hostmask;
2259                         activity\&.message         = quit_message;
2260 
2261                         _irc_engine->NotifyListeners(LN_Quit, connection);
2262                 }
2263 
2264                 // remove the user leaving from all channels we're maintaining
2265                 for ( auto channel : _irc_engine->Pools()->IrcChannels()->Allocated() )
2266                 {
2267                         if (( user = channel->GetUser(sender->nickname\&.c_str())) != nullptr )
2268                         {
2269                                 channel->DeleteUser(user);
2270                                 num_affected++;
2271                         }
2272 
2273                 }
2274 
2275                 // query windows?
2276 
2277                 if ( num_affected == 0 )
2278                 {
2279                         /* we received the message, so there must/should be at 
2280                          * least one channel that is affected\&.\&. */
2281                         std::cerr << fg_red << "Received a QUIT, but no users were affected\&. Recommend restart, likely corruption\n";
2282                 }
2283         }
2284 
2285         ret = EIrcStatus::OK;
2286         goto cleanup;
2287 
2288 invalid_data:
2289         std::cerr << fg_red << "Invalid data: " << data->data\&.c_str();
2290         ret = EIrcStatus::InvalidData;
2291         goto cleanup;
2292 cleanup:
2293         return ret;
2294 }
.fi
.SS "bool IrcParser::HandleTopic (\fBIrcConnection\fP *connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"

.PP
Definition at line 2272 of file bak/IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, fg_red(), IrcConnection::GetActivity(), IrcConnection::GetChannel(), LN_Topic, IrcEngine::NotifyListeners(), ParseParameters(), UNREFERENCE_OBJECT, and IrcChannel::UpdateTopic()\&.
.PP
.nf
2277 {
2278         bool            ret = false;
2279         IrcChannel*     channel = nullptr;
2280         char*           extracted_channel = nullptr;
2281         char*           extracted_topic = nullptr;
2282         irc_activity&   activity = connection->GetActivity();
2283 
2284         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_channel, &extracted_topic) )
2285                 goto parse_failure;
2286 
2287         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
2288                 goto channel_not_found;
2289 
2290         channel->UpdateTopic(extracted_topic);
2291 
2292         // prepare the activity data, then inform our listeners
2293         {
2294 
2295 
2296                 _irc_engine->NotifyListeners(LN_Topic, connection);
2297         }
2298 
2299         ret = true;
2300         goto cleanup;
2301 
2302 parse_failure:
2303         goto cleanup;
2304 channel_not_found:
2305         std::cerr << fg_red << "The extracted channel '" << extracted_channel << "' could not be found\n";
2306         goto cleanup;
2307 cleanup:
2308         if ( channel != nullptr )
2309                 UNREFERENCE_OBJECT(channel);
2310         return ret;
2311 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::HandleTopic (std::shared_ptr< \fBIrcConnection\fP >connection, \fBircbuf_data\fP *data, \fBircbuf_sender\fP *sender)\fC [private]\fP"
Parses TOPIC
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection the data was received from 
.br
\fIdata\fP The segmented data received into sender, code + data 
.br
\fIsender\fP The nickname, ident and hostmask combo 
.RE
.PP
\fBReturns:\fP
.RS 4
If the processed data was valid, EIrcStatus::Ok is returned\&. 
.PP
If parsing/processing fails, returns the relevant EIrcStatus\&. 
.RE
.PP

.PP
Definition at line 2299 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, ircbuf_data::data, fg_red(), FREE, LN_Topic, IrcEngine::NotifyListeners(), ObjectNotFound, OK, ParseParameters(), ParsingError, and Unknown\&.
.PP
Referenced by ParseNextRecvQueueItem()\&.
.PP
.nf
2304 {
2305         std::shared_ptr<IrcChannel>     channel = nullptr;
2306         EIrcStatus      ret = EIrcStatus::Unknown;
2307         char*           extracted_channel = nullptr;
2308         char*           extracted_topic = nullptr;
2309         irc_activity&   activity = connection->GetActivity();
2310 
2311         if ( !ParseParameters(data->data\&.c_str(), 2, &extracted_channel, &extracted_topic) )
2312                 goto parse_failure;
2313 
2314         if (( channel = connection->GetChannel(extracted_channel)) == nullptr )
2315                 goto channel_not_found;
2316 
2317         channel->UpdateTopic(extracted_topic);
2318 
2319         // prepare the activity data, then inform our listeners
2320         {
2321 
2322 
2323                 _irc_engine->NotifyListeners(LN_Topic, connection);
2324         }
2325 
2326         ret = EIrcStatus::OK;
2327         goto cleanup;
2328 
2329 parse_failure:
2330         ret = EIrcStatus::ParsingError;
2331         goto cleanup;
2332 channel_not_found:
2333         std::cerr << fg_red << "The extracted channel '" << extracted_channel << "' could not be found\n";
2334         ret = EIrcStatus::ObjectNotFound;
2335         goto cleanup;
2336 cleanup:
2337         FREE(extracted_channel);
2338         FREE(extracted_topic);
2339         return ret;
2340 }
.fi
.SS "bool IrcParser::HasChannelPrefix (const \fBIrcConnection\fP *connection, char *str) const"
Determines if the supplied string has a channel prefix, determined from the data initially received from the server\&. Only checks the very first char of the supplied \fIstr\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The irc_connection containing the server data 
.br
\fIstr\fP The string to check for a prefix 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true/false as required, if the supplied string begins with a channel prefix (as previously supplied from the server)\&. 
.RE
.PP

.PP
Definition at line 2316 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::_parent_network, IrcNetwork::_server, irc_server::chan_types, and fg_red()\&.
.PP
.nf
2320 {
2321         if ( connection == nullptr )
2322                 goto no_connection;
2323         if ( connection->_parent_network == nullptr )
2324                 goto no_parent;
2325         if ( str == nullptr )
2326                 goto no_str;
2327 
2328         /* chan types is populated only after receiving 005, so check for an empty string */
2329         if ( connection->_parent_network->_server\&.chan_types\&.empty() )
2330                 return false;
2331 
2332         /* only check the first character\&.\&.\&. */
2333         return strchr(connection->_parent_network->_server\&.chan_types\&.c_str(), *str) != nullptr;
2334 
2335 no_connection:
2336         std::cerr << fg_red << "The supplied connection was a nullptr\n";
2337         return false;
2338 no_parent:
2339         std::cerr << fg_red << "The supplied connections parent network was a nullptr\n";
2340         return false;
2341 no_str:
2342         std::cerr << fg_red << "The input string was a nullptr\n";
2343         return false;
2344 }
.fi
.SS "bool IrcParser::HasChannelPrefix (const std::shared_ptr< \fBIrcConnection\fP >connection, char *str) const"
Determines if the supplied string has a channel prefix, determined from the data initially received from the server\&. Only checks the very first char of the supplied \fIstr\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The irc_connection containing the server data 
.br
\fIstr\fP The string to check for a prefix 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true/false as required, if the supplied string begins with a channel prefix (as previously supplied from the server)\&. 
.RE
.PP

.PP
Definition at line 2345 of file IrcParser\&.cc\&.
.PP
References fg_red()\&.
.PP
Referenced by HandleMode(), HandleNotice(), and HandlePrivmsg()\&.
.PP
.nf
2349 {
2350         std::shared_ptr<IrcNetwork>     network = nullptr;
2351 
2352         if ( connection == nullptr )
2353         {
2354                 std::cerr << fg_red << "The supplied connection was a nullptr\n";
2355                 return false;
2356         }
2357         if ( str == nullptr )
2358         {
2359                 std::cerr << fg_red << "The input string was a nullptr\n";
2360                 return false;
2361         }
2362         if (( network = connection->Owner()) == nullptr )
2363         {
2364                 std::cerr << fg_red << "The supplied connections owning network was a nullptr\n";
2365                 return false;
2366         }
2367 
2368         // chan types is populated only after receiving 005, so check for an empty string
2369         if ( network->_server\&.chan_types\&.empty() )
2370                 return false;
2371 
2372         // only check the first character\&.\&.\&.
2373         return strchr(network->_server\&.chan_types\&.c_str(), *str) != nullptr;
2374 }
.fi
.SS "bool IrcParser::ModeHasArgument (const \fBIrcConnection\fP *connection, boolis_set, charmode) const"
Checks whether the supplied mode has any 'data' associated with it - used when parsing mode messages, to determine the number of parameters there should be in retrieval\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The irc_connection owning the data 
.br
\fIis_set\fP Boolean flag if the mode needs to be 'set' to have data 
.br
\fImode\fP The mode itself 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns false if any parameter is invalid, or the mode does indeed not have any arguments with it\&. Returns true if it does\&. 
.RE
.PP

.PP
Definition at line 2349 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::_parent_network, IrcNetwork::_server, irc_server::chan_mode_chars, fg_red(), irc_server::supported_modes_A, irc_server::supported_modes_B, and irc_server::supported_modes_C\&.
.PP
.nf
2354 {
2355         IrcNetwork*     network = nullptr;
2356 
2357         if ( connection == nullptr )
2358                 goto no_connection;
2359         if ( connection->_parent_network == nullptr )
2360                 goto no_parent;
2361         if ( mode == '\0' )
2362                 goto no_mode;
2363 
2364         network = connection->_parent_network;
2365 
2366         /* if it's a user/nick mode, it must have an argument (+v, +o) */
2367         if ( strchr(network->_server\&.chan_mode_chars\&.c_str(), mode) != nullptr )
2368                 return true;
2369 
2370         /* A & B type modes will always have one (+e, +I) */
2371         if ( strchr(network->_server\&.supported_modes_A\&.c_str(), mode) != nullptr ||
2372                 strchr(network->_server\&.supported_modes_B\&.c_str(), mode) != nullptr )
2373                 return true;
2374 
2375         /* C type modes will have one, if the mode is being enabled (+k, +l) */
2376         if ( strchr(network->_server\&.supported_modes_C\&.c_str(), mode) != nullptr && is_set )
2377                 return true;
2378 
2379         /* D type modes will have none, and default return none for unknown modes */
2380         return false;
2381 
2382 no_connection:
2383         std::cerr << fg_red << "The supplied connection was a nullptr\n";
2384         return false;
2385 no_parent:
2386         std::cerr << fg_red << "The supplied connections parent network was a nullptr\n";
2387         return false;
2388 no_mode:
2389         std::cerr << fg_red << "The supplied mode was a NUL\n";
2390         return false;
2391 }
.fi
.SS "bool IrcParser::ModeHasArgument (const std::shared_ptr< \fBIrcConnection\fP >connection, boolis_set, charmode) const"
Checks whether the supplied mode has any 'data' associated with it - used when parsing mode messages, to determine the number of parameters there should be in retrieval\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The irc_connection owning the data 
.br
\fIis_set\fP Boolean flag if the mode needs to be 'set' to have data 
.br
\fImode\fP The mode itself 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns false if any parameter is invalid, or the mode does indeed not have any arguments with it\&. Returns true if it does\&. 
.RE
.PP

.PP
Definition at line 2379 of file IrcParser\&.cc\&.
.PP
References fg_red()\&.
.PP
Referenced by HandleMode()\&.
.PP
.nf
2384 {
2385         std::shared_ptr<IrcNetwork>     network = nullptr;
2386 
2387         if ( connection == nullptr )
2388         {
2389                 std::cerr << fg_red << "The supplied connection was a nullptr\n";
2390                 return false;
2391         }
2392         if ( mode == '\0' )
2393         {
2394                 std::cerr << fg_red << "The supplied mode was a NUL\n";
2395                 return false;
2396         }
2397         if (( network = connection->Owner()) == nullptr )
2398         {
2399                 std::cerr << fg_red << "The supplied connections owning network was a nullptr\n";
2400                 return false;
2401         }
2402         
2403 
2404         // if it's a user/nick mode, it must have an argument (+v, +o)
2405         if ( strchr(network->_server\&.chan_mode_chars\&.c_str(), mode) != nullptr )
2406                 return true;
2407 
2408         // A & B type modes will always have one (+e, +I)
2409         if ( strchr(network->_server\&.supported_modes_A\&.c_str(), mode) != nullptr ||
2410                 strchr(network->_server\&.supported_modes_B\&.c_str(), mode) != nullptr )
2411                 return true;
2412 
2413         // C type modes will have one, if the mode is being enabled (+k, +l)
2414         if ( strchr(network->_server\&.supported_modes_C\&.c_str(), mode) != nullptr && is_set )
2415                 return true;
2416 
2417         // D type modes will have none, and default return none for unknown modes
2418         return false;
2419 }
.fi
.SS "uint32_t IrcParser::ParseConnectionQueues (\fBIrcConnection\fP *connection)\fC [private]\fP"

.PP
Definition at line 2514 of file bak/IrcParser\&.cc\&.
.PP
References fg_red(), ParseNextRecvQueueItem(), and ProcessNextSendQueueItem()\&.
.PP
.nf
2517 {
2518         bool    ret_code;
2519 
2520         if ( connection == nullptr )
2521         {
2522                 std::cerr << fg_red << "The supplied connection was a nullptr\n";
2523                 return EXIT_FAILURE;
2524         }
2525 
2526         do
2527         {
2528                 ret_code = ParseNextRecvQueueItem(connection);
2529                 /* continue the loop regardless of if the result was successful
2530                  * or an error; errors will be logged, could only apply to a
2531                  * single queue entry, and shouldn't kline the entire process\&. */
2532         }
2533         while ( ret_code != false );
2534 
2535         // repeat for the send queue
2536         do
2537         {
2538                 ret_code = ProcessNextSendQueueItem(connection);
2539         }
2540         while ( ret_code != false );
2541 
2542         return EXIT_SUCCESS;
2543 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::ParseConnectionQueues (std::shared_ptr< \fBIrcConnection\fP >connection)\fC [private]\fP"

.PP
Definition at line 2547 of file IrcParser\&.cc\&.
.PP
References fg_red(), MissingParameter, OK, ParseNextRecvQueueItem(), ProcessNextSendQueueItem(), and QueueEmpty\&.
.PP
Referenced by RunParser()\&.
.PP
.nf
2550 {
2551         EIrcStatus      ret_code;
2552 
2553         if ( connection == nullptr )
2554         {
2555                 std::cerr << fg_red << "The supplied connection was a nullptr\n";
2556                 return EIrcStatus::MissingParameter;
2557         }
2558 
2559         do
2560         {
2561                 ret_code = ParseNextRecvQueueItem(connection);
2562                 /* continue the loop regardless of if the result was successful
2563                  * or an error; errors will be logged, could only apply to a
2564                  * single queue entry, and shouldn't kline the entire process\&. */
2565         }
2566         while ( ret_code != EIrcStatus::QueueEmpty );
2567 
2568         // repeat for the send queue
2569         do
2570         {
2571                 ret_code = ProcessNextSendQueueItem(connection);
2572         }
2573         while ( ret_code != EIrcStatus::QueueEmpty );
2574 
2575         return EIrcStatus::OK;
2576 }
.fi
.SS "bool IrcParser::ParseNextRecvQueueItem (\fBIrcConnection\fP *connection) const"
Parses the next recv queue item, determining the IRC message code (if any), and interpreting the data, preparing it for usage in the parser handling functions (HandleXXX)\&. Also sends the server initialization if it has not yet been done for this connection\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection containing the recv queue to process 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns EC_Success if the data was parsed, even if no handler exists for the text 
.PP
Returns EC_QueueEmpty if there are no queue items to process 
.PP
Otherwise, the appropriate bool is returned 
.RE
.PP

.PP
Definition at line 2548 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::_mutex, IrcConnection::_recv_queue, IrcConnection::_state, ircbuf_data::code, CS_Disconnected, CS_InitSent, ExtractIrcBufData(), fg_cyan(), fg_magenta(), fg_red(), fg_white(), Handle001(), Handle002(), Handle005(), Handle332(), Handle333(), Handle353(), Handle366(), Handle372(), Handle375(), Handle376(), Handle432(), Handle433(), HandleCap(), HandleInvite(), HandleJoin(), HandleKick(), HandleKill(), HandleMode(), HandleNick(), HandleNotice(), HandlePart(), HandlePong(), HandlePrivmsg(), HandleQuit(), HandleTopic(), ircbuf_data::sender, IrcConnection::SendInit(), and SplitSender()\&.
.PP
.nf
2551 {
2552         std::string     queue_str;
2553         const char*     err = nullptr;
2554         ircbuf_data     buf_data;
2555         ircbuf_sender   sender;
2556 
2557         if ( connection == nullptr )
2558                 goto no_connection;
2559 
2560         /* prevent a race condition, if AddToRecvQueue is amending the queue at
2561          * the exact time we're trying to grab an item from it\&. Release the lock
2562          * asap, so have a dedicated scope for it\&. */
2563         {
2564                 std::lock_guard<std::mutex>     lock(connection->_mutex);
2565 
2566                 if ( connection->_recv_queue\&.empty() )
2567                         return false;
2568 
2569                 queue_str = connection->_recv_queue\&.front();
2570                 connection->_recv_queue\&.pop();
2571         }
2572 
2573         std::cout << fg_cyan << "Parsing " << fg_white << queue_str\&.c_str() << "\n";
2574 
2575         if ( strncmp(queue_str\&.c_str(), "ERROR :", 7) == 0 )
2576         {
2577                 /* the server can disconnect us, for things like registration
2578                  * time-outs\&. Pass the error string so it can be logged\&. */
2579                 err = queue_str\&.substr(7)\&.c_str();
2580                 goto srv_error;
2581         }
2582 #if 0   // Code Removed: now done pre-reading the first buffer in EstablishConnection()
2583         else if ( !(connection->_state & CS_InitSent) )
2584         {
2585                 connection->SendInit();
2586         }
2587 #endif
2588         else
2589         {
2590                 // reduce duplication and spam; assign handler by function pointer
2591                 typedef bool (IrcParser::*pf_CodeHandler)(IrcConnection*, ircbuf_data*, ircbuf_sender*);
2592 
2593                 pf_CodeHandler  parser_func;
2594                 uint32_t        len;
2595                 uint16_t        numeric;
2596 
2597                 /* generates errors themselves */
2598                 if ( ExtractIrcBufData(queue_str\&.c_str(), &buf_data) != true )
2599                         goto extract_failed;
2600                 if ( SplitSender(buf_data\&.sender\&.c_str(), &sender) != true )
2601                         goto split_failed;
2602                 if ( buf_data\&.code\&.length() < 3 )
2603                         goto invalid_code;
2604 
2605 
2606                 numeric = (uint16_t)atoi(buf_data\&.code\&.c_str());
2607 
2608                 if ( numeric > 0 && numeric < 1000 )
2609                 {
2610                         switch ( numeric )
2611                         {
2612                         case 1:         parser_func = &IrcParser::Handle001; goto exec;
2613                         case 2:         parser_func = &IrcParser::Handle002; goto exec;
2614                         case 5:         parser_func = &IrcParser::Handle005; goto exec;
2615                         case 332:       parser_func = &IrcParser::Handle332; goto exec;
2616                         case 333:       parser_func = &IrcParser::Handle333; goto exec;
2617                         case 353:       parser_func = &IrcParser::Handle353; goto exec;
2618                         case 366:       parser_func = &IrcParser::Handle366; goto exec;
2619                         case 372:       parser_func = &IrcParser::Handle372; goto exec;
2620                         case 375:       parser_func = &IrcParser::Handle375; goto exec;
2621                         case 376:       parser_func = &IrcParser::Handle376; goto exec;
2622                         case 432:       parser_func = &IrcParser::Handle432; goto exec;
2623                         case 433:       parser_func = &IrcParser::Handle433; goto exec;
2624                         default:
2625                                 std::cout << fg_magenta << "Unhandled numeric: " << buf_data\&.code\&.c_str() << "\n";
2626                                 goto cleanup;
2627                         }
2628                 }
2629                 else
2630                 {
2631                         switch ( buf_data\&.code[0] )
2632                         {
2633                         case 'C':
2634                                 {
2635                                         switch ( buf_data\&.code[1] )
2636                                         {
2637                                         case 'A':
2638                                                 {
2639                                                         switch ( buf_data\&.code[2] )
2640                                                         {
2641                                                         case 'P':       parser_func = &IrcParser::HandleCap; goto exec;
2642                                                         default:
2643                                                                 goto unhandled_text;
2644                                                         }
2645                                                 }
2646                                         default:
2647                                                 goto unhandled_text;
2648                                         }
2649                                 }
2650                         case 'I':
2651                                 {
2652                                         switch ( buf_data\&.code[1] )
2653                                         {
2654                                         case 'N':
2655                                                 {
2656                                                         switch ( buf_data\&.code[2] )
2657                                                         {
2658                                                         case 'V':       parser_func = &IrcParser::HandleInvite; goto exec;
2659                                                         default:
2660                                                                 goto unhandled_text;
2661                                                         }
2662                                                 }
2663                                         default:
2664                                                 goto unhandled_text;
2665                                         }
2666                                 }
2667                         case 'J':
2668                                 {
2669                                         switch ( buf_data\&.code[1] )
2670                                         {
2671                                         case 'O':       parser_func = &IrcParser::HandleJoin; goto exec;
2672                                         default:
2673                                                 goto unhandled_text;
2674                                         }
2675                                 }
2676                         case 'K':
2677                                 {
2678                                         switch ( buf_data\&.code[1] )
2679                                         {
2680                                         case 'I':
2681                                                 {
2682                                                         switch ( buf_data\&.code[2] )
2683                                                         {
2684                                                         case 'C':       parser_func = &IrcParser::HandleKick; goto exec;
2685                                                         case 'L':       parser_func = &IrcParser::HandleKill; goto exec;
2686                                                         default:
2687                                                                 goto unhandled_text;
2688                                                         }
2689                                                 }
2690                                         default:
2691                                                 goto unhandled_text;
2692                                         }
2693                                 }
2694                         case 'M':
2695                                 {
2696                                         switch ( buf_data\&.code[1] )
2697                                         {
2698                                         case 'O':       parser_func = &IrcParser::HandleMode; goto exec;
2699                                         default:
2700                                                 goto unhandled_text;
2701                                         }
2702                                 }
2703                         case 'N':
2704                                 {
2705                                         switch ( buf_data\&.code[1] )
2706                                         {
2707                                         case 'I':       parser_func = &IrcParser::HandleNick; goto exec;
2708                                         case 'O':       parser_func = &IrcParser::HandleNotice; goto exec;
2709                                         default:
2710                                                 goto unhandled_text;
2711                                         }
2712                                 }
2713                         case 'P':
2714                                 {
2715                                         switch ( buf_data\&.code[1] )
2716                                         {
2717                                         case 'A':       parser_func = &IrcParser::HandlePart; goto exec;
2718                                         case 'O':       parser_func = &IrcParser::HandlePong; goto exec;
2719                                         case 'R':       parser_func = &IrcParser::HandlePrivmsg; goto exec;
2720                                         default:
2721                                                 goto unhandled_text;
2722                                         }
2723                                 }
2724                         case 'Q':
2725                                 {
2726                                         switch ( buf_data\&.code[1] )
2727                                         {
2728                                         case 'U':       parser_func = &IrcParser::HandleQuit; goto exec;
2729                                         default:
2730                                                 goto unhandled_text;
2731                                         }
2732                                 }
2733                         case 'T':
2734                                 {
2735                                         switch ( buf_data\&.code[1] )
2736                                         {
2737                                         case 'O':       parser_func = &IrcParser::HandleTopic; goto exec;
2738                                         default:
2739                                                 goto unhandled_text;
2740                                         }
2741                                 }
2742                         default:
2743 unhandled_text:
2744                                 std::cout << fg_magenta << "Unhandled text-code: " << buf_data\&.code\&.c_str() << "\n";
2745                                 goto cleanup;
2746                         }
2747                 }
2748 exec:
2749                 //dbgprint("Executing Handler, 0x%p\n", parser_func);
2750 
2751                 // calling member function pointers is fun!
2752                 ((IrcParser*)this->*parser_func)(connection, &buf_data, &sender);
2753         }
2754 
2755 cleanup:
2756 
2757         return true;
2758 
2759 no_connection:
2760         std::cerr << fg_red << "The supplied connection was a nullptr\n";
2761         return false;
2762 extract_failed:
2763         return false;
2764 split_failed:
2765         return false;
2766 invalid_code:
2767         std::cerr << fg_red << "An invalid code was received: " << buf_data\&.code\&.c_str() << "\n";
2768         return false;
2769 srv_error:
2770         std::cerr << fg_red << "The server closed the connection: " << err << "\n";
2771         connection->_state = CS_Disconnected;
2772         return false;
2773 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::ParseNextRecvQueueItem (std::shared_ptr< \fBIrcConnection\fP >connection) const"
Parses the next recv queue item, determining the IRC message code (if any), and interpreting the data, preparing it for usage in the parser handling functions (HandleXXX)\&. Also sends the server initialization if it has not yet been done for this connection\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection containing the recv queue to process 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns IRCS_OK if the data was parsed, even if no handler exists for the text 
.PP
Returns IRCS_QueueEmpty if there are no queue items 
.PP
Otherwise, the appropriate EIrcStatus is returned 
.RE
.PP

.PP
Definition at line 2581 of file IrcParser\&.cc\&.
.PP
References ircbuf_data::code, CS_Disconnected, CS_InitSent, ExtractIrcBufData(), fg_cyan(), fg_magenta(), fg_red(), fg_white(), Handle001(), Handle002(), Handle005(), Handle332(), Handle333(), Handle353(), Handle366(), Handle372(), Handle375(), Handle376(), Handle432(), Handle433(), HandleCap(), HandleInvite(), HandleJoin(), HandleKick(), HandleKill(), HandleMode(), HandleNick(), HandleNotice(), HandlePart(), HandlePong(), HandlePrivmsg(), HandleQuit(), HandleTopic(), InvalidData, MissingParameter, OK, ParsingError, QueueEmpty, ircbuf_data::sender, ServerClosed, and SplitSender()\&.
.PP
Referenced by ParseConnectionQueues()\&.
.PP
.nf
2584 {
2585         std::string     queue_str;
2586         const char*     err = nullptr;
2587         ircbuf_data     buf_data;
2588         ircbuf_sender   sender;
2589 
2590         if ( connection == nullptr )
2591                 goto no_connection;
2592 
2593         /* prevent a race condition, if AddToRecvQueue is amending the queue at
2594          * the exact time we're trying to grab an item from it\&. Release the lock
2595          * asap, so have a dedicated scope for it\&. */
2596         {
2597                 std::lock_guard<std::mutex>     lock(connection->_mutex);
2598 
2599                 if ( connection->_recv_queue\&.empty() )
2600                 {
2601                         return EIrcStatus::QueueEmpty;
2602                 }
2603 
2604                 queue_str = connection->_recv_queue\&.front();
2605                 connection->_recv_queue\&.pop();
2606         }
2607 
2608         std::cout << fg_cyan << "Parsing " << fg_white << queue_str\&.c_str() << "\n";
2609 
2610         if ( strncmp(queue_str\&.c_str(), "ERROR :", 7) == 0 )
2611         {
2612                 /* the server can disconnect us, for things like registration
2613                  * time-outs\&. Pass the error string so it can be logged\&. */
2614                 err = queue_str\&.substr(7)\&.c_str();
2615                 goto srv_error;
2616         }
2617 #if 0   // Code Removed: now done pre-reading the first buffer in EstablishConnection()
2618         else if ( !(connection->_state & CS_InitSent) )
2619         {
2620                 connection->SendInit();
2621         }
2622 #endif
2623         else
2624         {
2625                 // reduce duplication and spam; assign handler by function pointer
2626                 typedef EIrcStatus (IrcParser::*pf_CodeHandler)(std::shared_ptr<IrcConnection>, ircbuf_data*, ircbuf_sender*);
2627 
2628                 pf_CodeHandler  parser_func;
2629                 uint32_t        len;
2630                 uint16_t        numeric;
2631 
2632                 /* generates errors themselves */
2633                 if ( ExtractIrcBufData(queue_str\&.c_str(), &buf_data) != EIrcStatus::OK )
2634                         goto extract_failed;
2635                 if ( SplitSender(buf_data\&.sender\&.c_str(), &sender) != EIrcStatus::OK )
2636                         goto split_failed;
2637                 if ( buf_data\&.code\&.length() < 3 )
2638                         goto invalid_code;
2639 
2640 
2641                 numeric = (uint16_t)atoi(buf_data\&.code\&.c_str());
2642 
2643                 if ( numeric > 0 && numeric < 1000 )
2644                 {
2645                         switch ( numeric )
2646                         {
2647                         case 1:         parser_func = &IrcParser::Handle001; goto exec;
2648                         case 2:         parser_func = &IrcParser::Handle002; goto exec;
2649                         case 5:         parser_func = &IrcParser::Handle005; goto exec;
2650                         case 332:       parser_func = &IrcParser::Handle332; goto exec;
2651                         case 333:       parser_func = &IrcParser::Handle333; goto exec;
2652                         case 353:       parser_func = &IrcParser::Handle353; goto exec;
2653                         case 366:       parser_func = &IrcParser::Handle366; goto exec;
2654                         case 372:       parser_func = &IrcParser::Handle372; goto exec;
2655                         case 375:       parser_func = &IrcParser::Handle375; goto exec;
2656                         case 376:       parser_func = &IrcParser::Handle376; goto exec;
2657                         case 432:       parser_func = &IrcParser::Handle432; goto exec;
2658                         case 433:       parser_func = &IrcParser::Handle433; goto exec;
2659                         default:
2660                                 std::cout << fg_magenta << "Unhandled numeric: " << buf_data\&.code\&.c_str() << "\n";
2661                                 goto cleanup;
2662                         }
2663                 }
2664                 else
2665                 {
2666                         switch ( buf_data\&.code[0] )
2667                         {
2668                         case 'C':
2669                                 {
2670                                         switch ( buf_data\&.code[1] )
2671                                         {
2672                                         case 'A':
2673                                                 {
2674                                                         switch ( buf_data\&.code[2] )
2675                                                         {
2676                                                         case 'P':       parser_func = &IrcParser::HandleCap; goto exec;
2677                                                         default:
2678                                                                 goto unhandled_text;
2679                                                         }
2680                                                 }
2681                                         default:
2682                                                 goto unhandled_text;
2683                                         }
2684                                 }
2685                         case 'I':
2686                                 {
2687                                         switch ( buf_data\&.code[1] )
2688                                         {
2689                                         case 'N':
2690                                                 {
2691                                                         switch ( buf_data\&.code[2] )
2692                                                         {
2693                                                         case 'V':       parser_func = &IrcParser::HandleInvite; goto exec;
2694                                                         default:
2695                                                                 goto unhandled_text;
2696                                                         }
2697                                                 }
2698                                         default:
2699                                                 goto unhandled_text;
2700                                         }
2701                                 }
2702                         case 'J':
2703                                 {
2704                                         switch ( buf_data\&.code[1] )
2705                                         {
2706                                         case 'O':       parser_func = &IrcParser::HandleJoin; goto exec;
2707                                         default:
2708                                                 goto unhandled_text;
2709                                         }
2710                                 }
2711                         case 'K':
2712                                 {
2713                                         switch ( buf_data\&.code[1] )
2714                                         {
2715                                         case 'I':
2716                                                 {
2717                                                         switch ( buf_data\&.code[2] )
2718                                                         {
2719                                                         case 'C':       parser_func = &IrcParser::HandleKick; goto exec;
2720                                                         case 'L':       parser_func = &IrcParser::HandleKill; goto exec;
2721                                                         default:
2722                                                                 goto unhandled_text;
2723                                                         }
2724                                                 }
2725                                         default:
2726                                                 goto unhandled_text;
2727                                         }
2728                                 }
2729                         case 'M':
2730                                 {
2731                                         switch ( buf_data\&.code[1] )
2732                                         {
2733                                         case 'O':       parser_func = &IrcParser::HandleMode; goto exec;
2734                                         default:
2735                                                 goto unhandled_text;
2736                                         }
2737                                 }
2738                         case 'N':
2739                                 {
2740                                         switch ( buf_data\&.code[1] )
2741                                         {
2742                                         case 'I':       parser_func = &IrcParser::HandleNick; goto exec;
2743                                         case 'O':       parser_func = &IrcParser::HandleNotice; goto exec;
2744                                         default:
2745                                                 goto unhandled_text;
2746                                         }
2747                                 }
2748                         case 'P':
2749                                 {
2750                                         switch ( buf_data\&.code[1] )
2751                                         {
2752                                         case 'A':       parser_func = &IrcParser::HandlePart; goto exec;
2753                                         case 'O':       parser_func = &IrcParser::HandlePong; goto exec;
2754                                         case 'R':       parser_func = &IrcParser::HandlePrivmsg; goto exec;
2755                                         default:
2756                                                 goto unhandled_text;
2757                                         }
2758                                 }
2759                         case 'Q':
2760                                 {
2761                                         switch ( buf_data\&.code[1] )
2762                                         {
2763                                         case 'U':       parser_func = &IrcParser::HandleQuit; goto exec;
2764                                         default:
2765                                                 goto unhandled_text;
2766                                         }
2767                                 }
2768                         case 'T':
2769                                 {
2770                                         switch ( buf_data\&.code[1] )
2771                                         {
2772                                         case 'O':       parser_func = &IrcParser::HandleTopic; goto exec;
2773                                         default:
2774                                                 goto unhandled_text;
2775                                         }
2776                                 }
2777                         default:
2778 unhandled_text:
2779                                 std::cout << fg_magenta << "Unhandled text-code: " << buf_data\&.code\&.c_str() << "\n";
2780                                 goto cleanup;
2781                         }
2782                 }
2783 exec:
2784                 //dbgprint("Executing Handler, 0x%p\n", parser_func);
2785 
2786                 // calling member function pointers is fun!
2787                 ((IrcParser*)this->*parser_func)(connection, &buf_data, &sender);
2788         }
2789 
2790 cleanup:
2791 
2792         return EIrcStatus::OK;
2793 
2794 no_connection:
2795         std::cerr << fg_red << "The supplied connection was a nullptr\n";
2796         return EIrcStatus::MissingParameter;
2797 extract_failed:
2798         return EIrcStatus::ParsingError;
2799 split_failed:
2800         return EIrcStatus::ParsingError;
2801 invalid_code:
2802         std::cerr << fg_red << "An invalid code was received: " << buf_data\&.code\&.c_str() << "\n";
2803         return EIrcStatus::InvalidData;
2804 srv_error:
2805         std::cerr << fg_red << "The server closed the connection: " << err << "\n";
2806         connection->_state = CS_Disconnected;
2807         return EIrcStatus::ServerClosed;
2808 }
.fi
.SS "char* IrcParser::ParseParam (char **data) const"
Checks the supplied \fIdata\fP for the IRC separator (:) and/or the end of the string without one, and retrieves the next 'parameter', if any, of the data\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP The pointer-to-char-pointer to check 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to the extracted parameter on 'success', otherwise a nullptr is returned\&. If the number of arguments supplied to \fBParseParameters()\fP is accurate for the message type, this shouldn't ever return a nullptr\&. 
.RE
.PP

.SS "char * IrcParser::ParseParam (char **data) const"
Checks the supplied data for the IRC separator (:) and/or the end of the string without one, and retrieves the next 'parameter', if any, of the data\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP The pointer-to-char-pointer to check 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to the extracted parameter on 'success', otherwise a nullptr is returned\&. If the number of arguments supplied to \fBParseParameters()\fP is accurate for the message type, this shouldn't ever return a nullptr\&. 
.RE
.PP

.PP
Definition at line 2424 of file IrcParser\&.cc\&.
.PP
References fg_red()\&.
.PP
Referenced by ParseParameters()\&.
.PP
.nf
2427 {
2428         char*   p = nullptr;
2429 
2430         if ( data == nullptr )
2431         {
2432                 std::cerr << fg_red << "The input string was a nullptr\n";
2433                 return nullptr;
2434         }
2435         if ( *data == nullptr )
2436         {
2437                 std::cerr << fg_red << "The input string started with a nullptr\n";
2438                 return nullptr;
2439         }
2440 
2441         if ( **data == ':' )
2442         {
2443                 // last parameter
2444                 p = *data;
2445                 *data += strlen(*data);
2446                 return (p + 1);
2447         }
2448 
2449         p = *data;
2450 
2451         while ( **data != '\0' && **data != ' ' )
2452                 (*data)++;
2453 
2454         if ( **data == ' ' )
2455                 *(*data)++ = '\0';
2456 
2457         return p;
2458 }
.fi
.SS "bool IrcParser::ParseParameters (const char *buffer, uint32_tnum_args, \&.\&.\&.) const"
Splits the supplied buffer into the IRC separated list of parameters (:) storing the results in the supplied arguments, by calling \fBParseParam()\fP\&.
.PP
.PP
.nf
char*    extracted_channel = NULL;
char*    extracted_kicked = NULL;
char*    extracted_kick_message = NULL;

if ( !ParseParameters(data->data, 3, &extracted_channel, &extracted_kicked, &extracted_kick_message) )
       goto parse_failure;

// the extracted_* variables now contain an allocated buffer
* 
.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP The buffer containing the original string from the server 
.br
\fInum_args\fP The number of arguments to extract/parse from the buffer 
.br
\fI\&.\&.\&.\fP The variable list of arguments, which should be pointers to unallocated buffers (char**) 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true if the arguments are populated successfully, or false if any parameter/memory allocation fails 
.RE
.PP

.SS "bool IrcParser::ParseParameters (const char *buffer, uint32_tnum_args, \&.\&.\&.) const"
Splits the supplied buffer into the IRC separated list of parameters (:) storing the results in the supplied arguments, by calling \fBParseParam()\fP\&.
.PP
.PP
.nf
char*    extracted_channel = NULL;
char*    extracted_kicked = NULL;
char*    extracted_kick_message = NULL;

if ( !ParseParameters(data->data, 3, &extracted_channel, &extracted_kicked, &extracted_kick_message) )
       goto parse_failure;

// the extracted_* variables now contain an allocated buffer
* 
.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP The buffer containing the original string from the server 
.br
\fInum_args\fP The number of arguments to extract/parse from the buffer 
.br
\fI\&.\&.\&.\fP The variable list of arguments, which should be pointers to unallocated buffers (char**) 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true if the arguments are populated successfully, or false on any failure\&. 
.RE
.PP

.PP
Definition at line 2463 of file IrcParser\&.cc\&.
.PP
References fg_red(), MALLOC, ParseParam(), and strlcpy()\&.
.PP
Referenced by Handle332(), Handle333(), Handle353(), Handle366(), Handle432(), Handle433(), HandleCap(), HandleInvite(), HandleKick(), HandleKill(), HandleMode(), HandleNotice(), HandlePart(), HandlePrivmsg(), and HandleTopic()\&.
.PP
.nf
2468 {
2469         char**          arg_str = nullptr;
2470         char*           tmp_str = nullptr;
2471         char*           p = (char*)buffer;
2472         uint32_t        alloc;
2473         uint32_t        i = num_args;   // copy in case we need to revert our actions
2474         va_list         args;
2475 
2476         if ( buffer == nullptr )
2477         {
2478                 std::cerr << fg_red << "The supplied buffer was a nullptr\n";
2479                 return false;
2480         }
2481         
2482         if ( num_args == 0 )
2483         {
2484                 std::cerr << fg_red << "No arguments were supplied\n";
2485                 return false;
2486         }
2487 
2488         // va_start MUST receive the last member passed into the function!
2489         va_start(args, num_args);
2490 
2491         /* num_args should ALWAYS be the number of arguments within the buffer; if
2492          * not interested in a parameter, pass NULL in, instead of just leaving
2493          * the data early (which can/will result in receiving the rest of the data
2494          * within the last parameter, which will not be desired!) */
2495         while ( i-- > 0 )
2496         {
2497                 /* get the variable passed down */
2498                 arg_str = (char**)va_arg(args, char**);
2499 
2500                 /* if the last parameter, also check for the separating colon */
2501                 if ( i == 0 )
2502                         tmp_str = *p == ':' ? p+1 : p;
2503                 else
2504                         tmp_str = ParseParam(&p);
2505 
2506                 /* we want to ignore some arguments that will appear before the rest of
2507                  * the data (e\&.g\&. &extracted_nick, NULL, &extracted_data), so NULLs
2508                  * must be acceptable when passed in\&. */
2509                 if ( arg_str != nullptr && *arg_str == nullptr )
2510                 {
2511                         alloc = strlen(tmp_str) + 1;
2512                         *arg_str = (char*)MALLOC(alloc);
2513                         strlcpy(*arg_str, tmp_str, alloc);
2514 
2515                         if ( &*arg_str == nullptr )
2516                                 throw std::bad_alloc();
2517                 }
2518         }
2519 
2520         va_end(args);
2521         return true;
2522 }
.fi
.SS "bool IrcParser::ProcessNextSendQueueItem (\fBIrcConnection\fP *connection) const"
Parses the next send queue item, which should be a raw IRC message\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection containing the send queue to process 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns EC_Success if a queue item was popped and sent off to the server 
.PP
Returns EC_QueueEmpty if there are no queue items to process 
.PP
Otherwise, the appropriate bool is returned 
.RE
.PP

.PP
Definition at line 2778 of file bak/IrcParser\&.cc\&.
.PP
References IrcConnection::_send_queue, and fg_red()\&.
.PP
.nf
2781 {
2782         if ( connection == nullptr )
2783                 goto no_connection;
2784 
2785         if ( connection->_send_queue\&.empty() )
2786                 return false;
2787 
2788 
2789 
2790         return true;
2791 
2792 no_connection:
2793         std::cerr << fg_red << "The supplied connection was a nullptr\n";
2794         return false;
2795 }
.fi
.SS "\fBEIrcStatus\fP IrcParser::ProcessNextSendQueueItem (std::shared_ptr< \fBIrcConnection\fP >connection) const"
Parses the next send queue item, which should be a raw IRC message\&.
.PP
\fBParameters:\fP
.RS 4
\fIconnection\fP The connection containing the send queue to process 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns IRCS_OK if a queue item was popped and sent off to the server 
.PP
Returns IRCS_QueueEmpty if there are no queue items 
.PP
Otherwise, the appropriate EIrcStatus is returned 
.RE
.PP

.PP
Definition at line 2813 of file IrcParser\&.cc\&.
.PP
References fg_red(), MissingParameter, OK, and QueueEmpty\&.
.PP
Referenced by ParseConnectionQueues()\&.
.PP
.nf
2816 {
2817         if ( connection == nullptr )
2818         {
2819                 std::cerr << fg_red << "The supplied connection was a nullptr\n";
2820                 return EIrcStatus::MissingParameter;
2821         }
2822 
2823         if ( connection->_send_queue\&.empty() )
2824         {
2825                 return EIrcStatus::QueueEmpty;
2826         }
2827 
2828         // to add processing\&.\&.\&.
2829 
2830         return EIrcStatus::OK;
2831 }
.fi
.SS "uint32_t IrcParser::RunParser ()\fC [private]\fP"

.SS "uint32_t IrcParser::RunParser ()\fC [private]\fP"

.PP
Definition at line 2836 of file IrcParser\&.cc\&.
.PP
References IrcObject::_irc_engine, _sync_event, ObjectPool< T >::Allocated(), fg_red(), IrcPool::IrcConnections(), Runtime::IsQuitting(), OK, OSAPIError, ParseConnectionQueues(), IrcEngine::Pools(), runtime, and Runtime::ThreadStopping()\&.
.PP
.nf
2837 {
2838         try
2839         {
2840 
2841         for ( ;; )
2842         {
2843 #if defined(_WIN32)
2844                 DWORD   wait_ret;
2845 
2846                 ResetEvent(_sync_event);
2847 
2848                 wait_ret = WaitForSingleObject(_sync_event, INFINITE);
2849 
2850                 /* object type can only return _0 or FAILED, as it never
2851                  * times out and is not a mutex */
2852                 if ( wait_ret == WAIT_FAILED )
2853                 {
2854                         std::cerr << fg_red << "WaitForSingleObject() failed for the parser sync event; last error= " << GetLastError() << "\n";
2855                         return EIrcStatus::OSAPIError;
2856                 }
2857                 else if ( wait_ret == WAIT_OBJECT_0 )
2858 #else
2859                 sync_event_wait(&_sync_event);
2860 #endif
2861                 {
2862                         // abort immediately if the app is quitting
2863                         if ( runtime\&.IsQuitting() )
2864                                 break;
2865 
2866                         for ( auto c : _irc_engine->Pools()->IrcConnections()->Allocated() )
2867                         {
2868                                 ParseConnectionQueues(c);
2869                         }
2870                 }
2871         }
2872 
2873         }
2874         catch ( std::exception& e )
2875         {
2876                 std::cerr << fg_red << "Caught an exception; " << e\&.what() << "\n";
2877         }
2878         catch ( \&.\&.\&. )
2879         {
2880                 std::cerr << fg_red << "Caught an unhandled exception\n";
2881         }
2882 
2883 #if defined(_WIN32)
2884         runtime\&.ThreadStopping(GetCurrentThreadId(), __FUNCTION__);
2885 #else
2886         runtime\&.ThreadStopping(pthread_self(), __FUNCTION__);
2887 #endif
2888 
2889         return EIrcStatus::OK;
2890 }
.fi
.SS "bool IrcParser::SplitSender (const char *buffer, \fBircbuf_sender\fP *sender) const"
Splits the supplied string, which should be in the format $nick!$ident$host into its three separate parts, storing them in the supplied sender struct\&. No memory is allocated in doing so, but the original string is modified\&.
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP The buffer containing the sender information 
.br
\fIsender\fP The \fBircbuf_sender\fP to store the separate sender parts in 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns EC_Success if the sender was split into its three parts (or single part if it is a server), otherwise the appropriate bool 
.RE
.PP

.SS "bool IrcParser::SplitSender (const char *buffer, \fBircbuf_sender\fP *sender) const"
Splits the supplied string, which should be in the format $nick!$ident$host into its three separate parts, storing them in the supplied sender struct\&. No memory is allocated in doing so, but the original string is modified\&.
.PP
\fBParameters:\fP
.RS 4
\fIbuffer\fP The buffer containing the sender information 
.br
\fIsender\fP The \fBircbuf_sender\fP to store the separate sender parts in 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns IRCS_Success if the sender was split into its three parts (or single part if it is a server), otherwise the appropriate EIrcStatus 
.RE
.PP

.PP
Definition at line 2895 of file IrcParser\&.cc\&.
.PP
References fg_red(), ircbuf_sender::hostmask, ircbuf_sender::ident, MissingParameter, ircbuf_sender::nickname, OK, and ParsingError\&.
.PP
Referenced by Handle353(), and ParseNextRecvQueueItem()\&.
.PP
.nf
2899 {
2900         /* although we modify buffer, we will not alter its length (we only
2901          * replace spaces with nul characters), therefore this function is still
2902          * safe to use with a caller of a CHARSTRINGTYPE->c_str() */
2903 
2904         char*   nickname = (char*)&buffer[0];
2905         char*   ident = nullptr;
2906         char*   hostmask = nullptr;
2907 
2908         if ( buffer == nullptr )
2909                 goto no_buffer;
2910         if ( sender == nullptr )
2911                 goto no_sender;
2912 
2913         ident = strchr(nickname, '!');
2914 
2915         if ( ident == nullptr )
2916         {
2917                 /* message from the server - ideally should be a check with what
2918                  * we received on the initial connection, and if it doesn't 
2919                  * match it should be regarded as invalid\&. */
2920                 sender->nickname        = nickname;
2921                 return EIrcStatus::OK;
2922         }
2923 
2924         // null-out the space, and proceed to the 'first' character
2925         *ident = '\0';
2926         ident++;
2927 
2928         // copy the data, up to the first space (which is now a nul)
2929         sender->nickname        = nickname;
2930 
2931         hostmask = strchr(ident, '@');
2932 
2933         if ( hostmask == nullptr )
2934                 goto missing_data;
2935 
2936         *hostmask = '\0';
2937         hostmask++;
2938 
2939         sender->ident           = ident;
2940         sender->hostmask        = hostmask;
2941 
2942         return EIrcStatus::OK;
2943 
2944 no_buffer:
2945         std::cerr << fg_red << "The supplied buffer was a nullptr\n";
2946         return EIrcStatus::MissingParameter;
2947 no_sender:
2948         std::cerr << fg_red << "The supplied sender struct was a nullptr\n";
2949         return EIrcStatus::MissingParameter;
2950 missing_data:
2951         std::cerr << fg_red << "The hostmask is missing where expected: " << ident << "\n";
2952         return EIrcStatus::ParsingError;
2953 }
.fi
.SS "void IrcParser::TriggerSync () const"
Notifies the parser there is work to do\&. Using this rather than a poll, which would use more CPU time and cause a delay in send/recv\&.
.PP
\fBSee Also:\fP
.RS 4
\fBRunParser()\fP 
.RE
.PP

.SS "void IrcParser::TriggerSync () const"
Notifies the parser there is work to do\&. Using this rather than a poll, which would use more CPU time and cause a delay in send/recv\&.
.PP
\fBSee Also:\fP
.RS 4
\fBRunParser()\fP 
.RE
.PP

.PP
Definition at line 2958 of file IrcParser\&.cc\&.
.PP
References _sync_event, and fg_red()\&.
.PP
Referenced by IrcConnection::EstablishConnection()\&.
.PP
.nf
2959 {
2960 #if defined(_WIN32)
2961         if ( !SetEvent(_sync_event) )
2962                 goto evt_failure;
2963 
2964         return;
2965 
2966 evt_failure:
2967         std::cerr << fg_red << "Failed to signal the parser event; last error= " << GetLastError() << "\n";
2968 
2969 #elif defined(__linux__) || defined(BSD)
2970 
2971         sync_event_set(&_sync_event);
2972 
2973 #endif
2974 }
.fi
.SH "Friends And Related Function Documentation"
.PP 
.SS "\fBIrcEngine\fP\fC [friend]\fP"

.PP
Definition at line 68 of file IrcParser\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBHANDLE\fP IrcParser::_sync_event\fC [private]\fP"

.PP
Definition at line 74 of file IrcParser\&.h\&.
.PP
Referenced by Cleanup(), RunParser(), and TriggerSync()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Social Bot Interface from the source code\&.
