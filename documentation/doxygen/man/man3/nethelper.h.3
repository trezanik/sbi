.TH "nethelper.h" 3 "Mon Jun 23 2014" "Version 0.1" "Social Bot Interface" \" -*- nroff -*-
.ad l
.nh
.SH NAME
nethelper.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <WS2tcpip\&.h>\fP
.br
\fC#include <in6addr\&.h>\fP
.br
\fC#include <api/char_helper\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBip_address\fP"
.br
.ti -1c
.RI "struct \fBsockaddr_union\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBSBI_IRC_API\fP int32_t \fBhost_to_ipv4\fP (const char *hostname, int32_t index, char *ip_dest, uint32_t dest_size)"
.br
.ti -1c
.RI "\fBSBI_IRC_API\fP bool \fBipv4_to_host\fP (const char *ipv4_address, char *host_dest, uint32_t dest_size)"
.br
.ti -1c
.RI "\fBSBI_IRC_API\fP bool \fBis_ip_address\fP (const char *data)"
.br
.ti -1c
.RI "\fBSBI_IRC_API\fP void \fBnet_cleanup\fP ()"
.br
.ti -1c
.RI "\fBSBI_IRC_API\fP bool \fBnet_startup\fP (uint16_t winsock_version=0)"
.br
.ti -1c
.RI "\fBSBI_IRC_API\fP int32_t \fBopenssl_err_callback\fP (const char *str, size_t len, void *context)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBSBI_IRC_API\fP int32_t host_to_ipv4 (const char *hostname, int32_tindex, char *ip_dest, uint32_tdest_size)"
Validates and looks up the supplied \fIhostname\fP\&. On success, the first IP address (or overriden by index) is copied into \fIip_dest\fP\&. This allows a different address to be returned in case the first one tried is unreachable\&.
.PP
If the index is out of range, an error is generated\&.
.PP
Useful on systems that have a lookup cache, otherwise, you'll be doing a fresh lookup every time you need to use an alternate address - hopefully this shouldn't come up too often anyway\&.
.PP
Example usage:
.PP
.PP
.nf
       char     buf[NI_MAXHOST];
       int              num_res;
       char     ip_dest[INET_ADDRSTRLEN];

       // fgets into buf

       if (( num_res = host_to_ipv4(buf, -1, ip_dest, sizeof(ip_dest))) >= 0 )
       {
        printf("Primary Index: %s\n", ip_dest);

        // do work on address, otherwise enter loop

        for ( int i = 1; i < num_res; i++ )
        {
                host_to_ipv4(buf, i, ip_dest, sizeof(ip_dest));
                printf("Secondary Index [%i]: %s\n", i, ip_dest);

                // attempt work on alternate address
        }
       }

// Example Output::
//
// google\&.com
// Primary Index: 173\&.194\&.34\&.65
// Secondary Index [1]: 173\&.194\&.34\&.68
// Secondary Index [2]: 173\&.194\&.34\&.70
// Secondary Index [3]: 173\&.194\&.34\&.69
// Secondary Index [4]: 173\&.194\&.34\&.66
// Secondary Index [5]: 173\&.194\&.34\&.64
// Secondary Index [6]: 173\&.194\&.34\&.78
// Secondary Index [7]: 173\&.194\&.34\&.67
// Secondary Index [8]: 173\&.194\&.34\&.73
// Secondary Index [9]: 173\&.194\&.34\&.72
// Secondary Index [10]: 173\&.194\&.34\&.71
* 
.fi
.PP
.PP
\fBParameters:\fP
.RS 4
\fIhostname\fP The hostname to lookup 
.br
\fIindex\fP The 0-based index within the results to return 
.br
\fIip_dest\fP The buffer to copy the IP address to 
.br
\fIdest_size\fP The size of \fIip_dest\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns the number of addresses found for the specified \fIhostname\fP\&. 
.PP
-1 is returned if the input data is invalid; 0 is returned if the data was valid, but there were no results (this is abnormal)\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBipv4_to_host\fP 
.RE
.PP

.PP
Definition at line 40 of file nethelper\&.cc\&.
.PP
.nf
46 {
47         struct addrinfo         hints = { 0 };
48         struct addrinfo*        result = NULL;
49         struct addrinfo*        rp = NULL;
50         int32_t         ret = 0;
51         int32_t         res;
52 
53         // obtain address(es) matching host
54 
55         // IPv4 only
56         hints\&.ai_family          = AF_INET;
57 
58 
59         if (( res = getaddrinfo(hostname, NULL, &hints, &result)) != 0 )
60         {
61                 LOG(ELogLevel::Error) << fg_red 
62                         << "Error " << res 
63                         << " (" << gai_strerror(res) 
64                         << ") looking up" << hostname 
65                         << "\n";
66 
67                 ret--;
68         }
69         else
70         {
71                 for ( rp = result; rp != NULL; rp = rp->ai_next, ++ret )
72                 {
73                         struct sockaddr_in      *a = (struct sockaddr_in*)rp->ai_addr;
74 
75                         if ( index < 0 )
76                         {
77                                 // no index specified; copy the first result
78                                 strlcpy(ip_dest, (char*)inet_ntoa(a->sin_addr), dest_size);
79                                 index = 0;
80                         }
81                         else if ( index == ret )
82                         {
83                                 // copy the specified index
84                                 strlcpy(ip_dest, (char*)inet_ntoa(a->sin_addr), dest_size);
85                         }
86                 }
87 
88                 if ( index >= ret )
89                 {
90                         LOG(ELogLevel::Error) << fg_red 
91                                 << "The specified index '"
92                                 << index << "' is out of range ("
93                                 << ret << ")\n";
94                 }
95                 else
96                 {
97                         LOG(ELogLevel::Info) << fg_green 
98                                 << hostname << " resolved to "
99                                 << ip_dest << "\n";
100                 }
101         }
102 
103         if ( result != NULL )
104                 freeaddrinfo(result);
105 
106         // -1 on error
107         // 0 is abnormal (lookup succeeded, but no results)
108         // >=1 if 1 or more results
109         return ret;
110 }
.fi
.SS "\fBSBI_IRC_API\fP bool ipv4_to_host (const char *ipv4_address, char *host_dest, uint32_tdest_size)"
Performs a reverse lookup on the input ipv4_address\&.
.PP
e\&.g\&. 173\&.194\&.34\&.67 reverse lookup: lhr14s19-in-f3\&.1e100\&.net
.PP
\fBParameters:\fP
.RS 4
\fIipv4_address\fP The IPv4 address to reverse-lookup 
.br
\fIhost_dest\fP The destination buffer to copy the hostname to 
.br
\fIdest_size\fP The size of host_dest 
.RE
.PP
\fBReturns:\fP
.RS 4
The function returns true if the IP address is valid, and a lookup is performed\&. If the name could not be found, true is still returned; only on an error is false returned\&. 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBhost_to_ipv4\fP 
.RE
.PP

.PP
Definition at line 115 of file nethelper\&.cc\&.
.PP
.nf
120 {
121         struct addrinfo         hints = { 0 };
122         struct addrinfo*        result = NULL;
123         int32_t                 res;
124 
125         // IPv4 only
126         hints\&.ai_family          = AF_INET;
127 
128 
129         if (( res = getaddrinfo(ipv4_address, NULL, &hints, &result)) != 0 )
130         {
131                 LOG(ELogLevel::Error) << fg_red 
132                         << "Error " << res
133                         << " (" << gai_strerror(res)
134                         << ") looking up" << ipv4_address
135                         << "\n";
136                 return false;
137         }
138 
139         /* we don't want to fail if the name cannot be looked up, so supply no
140          * flags; if the lookup does not resolve,  */
141 
142         if (( res = getnameinfo(result->ai_addr, result->ai_addrlen, host_dest, dest_size, NULL, 0, 0)) != 0 )
143         {
144                 LOG(ELogLevel::Error) << fg_red 
145                         << "Error " << res
146                         << " (" << gai_strerror(res)
147                         << ") looking up" << ipv4_address
148                         << "\n";
149                 freeaddrinfo(result);
150                 return false;
151         }
152 
153 
154 
155         LOG(ELogLevel::Info) << ipv4_address << " resolved to " << host_dest << "\n";
156 
157         freeaddrinfo(result);
158         return true;
159 }
.fi
.SS "\fBSBI_IRC_API\fP bool is_ip_address (const char *data)"
Checks if the supplied string is an IPv4 or IPv6 address\&. Mostly used for determining if a server in the config is an IP address or hostname\&. 
.PP
Definition at line 164 of file nethelper\&.cc\&.
.PP
.nf
167 {
168         struct ip_address       ipaddr;
169 
170         // inet_pton returns 1 on success, -1 on error, or 0 if input is invalid
171         if ( inet_pton(AF_INET, data, &ipaddr\&.data) != 1 )
172         {
173                 if ( inet_pton(AF_INET6, data, &ipaddr\&.data) != 1 )
174                 {
175                         // not an IPv4 or IPv6 address
176                         return false;
177                 }
178         }
179 
180         // is an IPv4 or IPv6 address
181         return true;
182 }
.fi
.SS "\fBSBI_IRC_API\fP void net_cleanup ()"
Cleans up all aspects of networking loaded within the application\&. Should only ever be called before the application closes, as a chance to free any dynamically allocated memory not yet freed\&.
.PP
We use the opportunity to cleanup things that don't 'really' need to be called, such as WSACleanup and ERR_free_strings; but it's good practice to do so\&.
.PP
\fBSee Also:\fP
.RS 4
\fBnet_startup\fP 
.RE
.PP

.PP
Definition at line 187 of file nethelper\&.cc\&.
.PP
.nf
188 {
189         /* no error checking to be done, since we only call this when the app
190          * is closing, and needless reporting will slow it down */
191 
192 #if defined(USING_OPENSSL)
193         // free OpenSSLs loaded error strings
194         ERR_free_strings();
195 #endif
196 
197 #if defined(_WIN32)
198         // unload winsock
199         WSACleanup();
200 #endif
201 }
.fi
.SS "\fBSBI_IRC_API\fP bool net_startup (uint16_twinsock_version = \fC0\fP)"
Loads OpenSSL networking components (and non-SSL networking) - as Windows utilizes (and requires) WinSock, this will also call WSAStartup on Windows builds\&. winsock_version is ignored on non-Windows builds, and it can therefore be omitted\&.
.PP
\fBParameters:\fP
.RS 4
\fIwinsock_version\fP The version of Winsock to load and initialize 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true on success, false on failure 
.RE
.PP
\fBSee Also:\fP
.RS 4
\fBnet_cleanup\fP 
.RE
.PP

.PP
Definition at line 206 of file nethelper\&.cc\&.
.PP
.nf
209 {
210 #if defined(USING_OPENSSL)
211         // load the openssl components
213         SSL_library_init();
214         SSL_load_error_strings();
215         ERR_load_crypto_strings();
216         ERR_load_BIO_strings();
217         ERR_load_SSL_strings();
218         ERR_load_ERR_strings();
219         /* in case of an older version of OpenSSL being used; see man page */
220         OpenSSL_add_all_algorithms();
221 #endif
222 
223 #if defined(_WIN32)
224         struct WSAData  wsa;
225 
226         if ( WSAStartup(winsock_version, &wsa) != 0 )
227         {
228                 LOG(ELogLevel::Error) << fg_red 
229                         << "Could not startup Winsock; Win32 error "
230                         << GetLastError() << "\n";
231                 return false;
232         }
233 #endif
234         // cannot return false on non-Windows builds
235         return true;
236 }
.fi
.SS "\fBSBI_IRC_API\fP int32_t openssl_err_callback (const char *str, size_tlen, void *context)"
Receives OpenSSL errors, ready to be output as desired 
.SH "Author"
.PP 
Generated automatically by Doxygen for Social Bot Interface from the source code\&.
