.TH "Configuration" 3 "Mon Jun 23 2014" "Version 0.1" "Social Bot Interface" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Configuration \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Configuration\&.h>\fP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBproxy\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB~Configuration\fP ()"
.br
.ti -1c
.RI "void \fBDump\fP () const "
.br
.ti -1c
.RI "void \fBLoad\fP (const char *specific_path=nullptr)"
.br
.ti -1c
.RI "void \fBLoadUI\fP ()"
.br
.ti -1c
.RI "const char * \fBPath\fP () const "
.br
.ti -1c
.RI "void \fBSave\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "struct {"
.br
.ti -1c
.RI "   \fBproxy\fP< char > \fBcommand_prefix\fP"
.br
.ti -1c
.RI "   \fBproxy\fP< bool > \fBenable_gui\fP"
.br
.ti -1c
.RI "   \fBproxy\fP< bool > \fBno_terminal\fP"
.br
.ti -1c
.RI "   struct {"
.br
.ti -1c
.RI "      \fBproxy\fP< std::string > \fBfile_name\fP"
.br
.ti -1c
.RI "      \fBproxy\fP< std::string > \fBcfg_name\fP"
.br
.ti -1c
.RI "      \fBproxy\fP< HMODULE > \fBmodule\fP"
.br
.ti -1c
.RI "      int32_t(* \fBpfunc_destroy_interface\fP )()"
.br
.ti -1c
.RI "      int32_t(* \fBpfunc_process_interface\fP )()"
.br
.ti -1c
.RI "      int32_t(* \fBpfunc_spawn_interface\fP )()"
.br
.ti -1c
.RI "   } \fBlibrary\fP"
.br
.ti -1c
.RI "} \fBui\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBNO_CLASS_ASSIGNMENT\fP (\fBConfiguration\fP)"
.br
.ti -1c
.RI "\fBNO_CLASS_COPY\fP (\fBConfiguration\fP)"
.br
.ti -1c
.RI "bool \fBCreateDefault\fP ()"
.br
.ti -1c
.RI "\fBConfiguration\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::string \fB_path\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBRuntime\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 34 of file Configuration\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Configuration::Configuration ()\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 60 of file Configuration\&.h\&.
.PP
.nf
61         {
62                 _path = "sbi\&.exe\&.cfg";
63         }
.fi
.SS "Configuration::~Configuration ()\fC [inline]\fP"

.PP
Definition at line 66 of file Configuration\&.h\&.
.PP
.nf
66 {}
.fi
.SH "Member Function Documentation"
.PP 
.SS "bool Configuration::CreateDefault ()\fC [private]\fP"
Attempts to create a default configuration file\&.
.PP
Only called when an attempt to load the configuration file fails with 'file not found'\&.
.PP
\fBReturn values:\fP
.RS 4
\fItrue\fP when the file is created 
.br
\fIfalse\fP if the file could not be created 
.RE
.PP

.PP
Definition at line 49 of file Configuration\&.cc\&.
.PP
References fg_grey(), and fg_red()\&.
.PP
Referenced by Load()\&.
.PP
.nf
50 {
51         FILE*   default_config;
52 
53         std::cout << fg_grey << "Creating default config file\n";
54 
55 #if defined(_WIN32)
56         if ( (default_config = _fsopen(_path\&.c_str(), "w", _SH_DENYWR)) == nullptr )
57         {
58                 std::cerr << fg_red << "Could not open " << _path << " to apply the default configuration file\n";
59                 return false;
60         }
61 #else
62         int     fd;
63         if ( (fd = open(_path\&.c_str(), O_WRONLY | O_CREAT, O_NOATIME | S_IRWXU | S_IRGRP | S_IROTH)) == -1 )
64         {
65                 std::cerr << fg_red << "Could not open " << _path << " to apply the default configuration file; errno " << errno << "\n";
66                 return false;
67         }
68 
69         if ( (default_config = fdopen(fd, "w")) == nullptr )
70         {
71                 std::cerr << fg_red << "fdopen failed on the file descriptor for " << _path << "; errno " << errno << "\n";
72                 return false;
73         }
74 
75 #endif
76 
77         char*   config_array[] = {
78 #if defined(USING_LIBCONFIG)
79                 "ui =",
80                 "{",
81                 "       enable_gui = 1;",
82                 "       enable_terminal = 1;",
83                 "       command_prefix = \"/\";",
84                 "       library = {",
85                 "               // looks for 'libui-XXX\&.dll' ",
86                 "               name : \"qt5\";",
87                 "       };",
88                 "};",
89         };
90 #else
91         };
92 #       error "Need a configuration library to use and store defaults"
93 #endif
94 
95         uint32_t        config_array_size = sizeof(config_array) / sizeof(char*);
96 
97         for ( uint32_t i = 0; i < config_array_size; i++ )
98                 fprintf(default_config, "%s\n", config_array[i]);
99 
100         fclose(default_config);
101 
102         return true;
103 }
.fi
.SS "void Configuration::Dump () const"
Dumps the entire configuration, as-is, to the application log file\&. \fBELogLevel::Debug\fP does not need to be set, as it will be output directly, not checking the level\&. 
.PP
Definition at line 108 of file Configuration\&.cc\&.
.PP
References Log::Append(), Force, LOG, Runtime::Logger(), mb_to_utf8(), runtime, and ui\&.
.PP
.nf
109 {
110         // we want to start on a newline, logging will have the prefix data
111         LOG(ELogLevel::Force) << "\n\t==== Dumping Parsed Configuration ====\n";
112 
113         std::stringstream       log_str;
114         //uint32_t              i;
115 
116         log_str << "\t---- UI Settings ----\n"
117                 << "\t* ui\&.command_prefix = " << ui\&.command_prefix << "\n"
118                 << "\t* ui\&.enable_gui = " << ui\&.enable_gui << "\n"
119                 << "\t* ui\&.library = " << ui\&.library\&.file_name\&.data << "\n"
120                 << "\t* ui\&.no_terminal = " << ui\&.no_terminal << "\n";
121 
122         
123         log_str << "\t#### End Settings Dump ####\n";
124 
125 #if defined(_WIN32)
126         wchar_t         buf[8192];
127         mb_to_utf8(buf, log_str\&.str()\&.c_str(), _countof(buf));
128         runtime\&.Logger()->Append(buf);
129 #else
130         runtime\&.Logger()->Append(log_str\&.str());
131 #endif
132 }
.fi
.SS "void Configuration::Load (const char *specific_path = \fCnullptr\fP)"
Loads the core requirements of the application; enough to bring it up and let the user start doing whatever relevant tasks\&.
.PP
If you want to load something that doesn't need to be present until after we're already running, use LoadDelayed()\&.
.PP
\fBParameters:\fP
.RS 4
\fIspecific_path\fP Set this to a path, relative or full, of the configuration file to load\&. This enables a different configuration to be executed by default simply by setting it on the command line\&. 
.RE
.PP

.PP
Definition at line 137 of file Configuration\&.cc\&.
.PP
References _path, CreateDefault(), LoadUI(), MALLOC, mb_to_utf8(), path_exists(), and ui\&.
.PP
Referenced by app_init()\&.
.PP
.nf
140 {
141         if ( specific_path != nullptr )
142                 _path = specific_path;
143 
144 #if defined(USING_LIBCONFIG)
145         libconfig::Config       cfg;
146 
147 #       if defined(_WIN32)
148         wchar_t         w[MAX_PATH];
149         mb_to_utf8(w, _path\&.c_str(), _countof(w));
150         if ( !path_exists(w) )
151 #       else
152 #               error nix equivalent
153 #       endif
154         {
155                 CreateDefault();
156         }
157 
158         try
159         {
160                 cfg\&.readFile(_path\&.c_str());
161         }
162         catch ( libconfig::FileIOException& e )
163         {
164                 // error reading the file\&.
165                 throw;
166         }
167         catch ( libconfig::ParseException& e )
168         {
169                 // error parsing the file\&.
170                 throw;
171         }
172 
173         if ( !cfg\&.lookupValue("ui\&.library\&.name", ui\&.library\&.file_name\&.data) )
174         {
175         }
176         if ( !cfg\&.lookupValue("ui\&.enable_terminal", ui\&.no_terminal\&.data) )
177         {
178         }
179         if ( !cfg\&.lookupValue("ui\&.enable_gui", ui\&.enable_gui\&.data) )
180         {
181         }
182         if ( !cfg\&.lookupValue("ui\&.command_prefix", (int32_t&)ui\&.command_prefix\&.data) )
183         {
184         }
185 
186         LoadUI();
187 
188 #else
189         // holds the entire config file in memory, ready to parse
190         char*                   buffer;
191         uint32_t                alloc;
192         FILE*                   fp;
193 
194         if ( (fp = _fsopen(_path\&.c_str(), "r", _SH_DENYWR)) == nullptr )
195         {
196                 printf("Failed to open configuration file '%s'; errno %d\n", 
197                        _path\&.c_str(), errno);
198                 return;
199         }
200 
201         // move to file end
202         fseek(fp, 0, SEEK_END);
203         // obtain file size, and amount to allocate
204         alloc = ftell(fp);
205         // return to start of file
206         fseek(fp, 0, SEEK_SET);
207         // allocate the buffer
208         buffer = (char*)MALLOC(alloc);
209         // copy into memory
210         fread(buffer, alloc, 1, fp);
211         // done with the file, close it
212         fclose(fp);
213 
214         struct json_object*     json_root;
215         json_root = json_tokener_parse(buffer);
216 
217         LoadUI(json_root);
218 #endif
219 }
.fi
.SS "void Configuration::LoadUI ()"

.PP
Definition at line 263 of file Configuration\&.cc\&.
.PP
References BUILD_STRING, Debug, Info, LOG, mb_to_utf8(), module, str_format(), and ui\&.
.PP
Referenced by Load()\&.
.PP
.nf
264 {
265         char            mb[260];
266         uint32_t        func_num = 0;
267         char*           func_names[] = {
268                 "destroy_interface",
269                 "process_interface",
270                 "spawn_interface"
271         };
272         int32_t         (*pfunc[sizeof(func_names)])();
273         uint32_t        funcarray_size = sizeof(func_names) / sizeof(char*);
274 
275 #if defined(_WIN32)
276 
277         HMODULE         module;
278         wchar_t         w_file[MAX_PATH];
279 
280         str_format(mb, sizeof(mb),
281                    "libui-%s\&.dll",
282                    ui\&.library\&.file_name\&.data\&.c_str());
283 
284         mb_to_utf8(w_file, mb, _countof(w_file));
285 
286 
287         LOG(ELogLevel::Info) << "Loading Dynamic Library '" << CHARSTRINGTYPE(w_file) << "'\n";
288 
289         // load from the current directory
290         module = LoadLibrary(w_file);
291 
292         // error 126 means the libui file or one of its dependencies is missing
293         if ( module == nullptr )
294                 throw std::runtime_error("LoadLibrary failed - error code " + std::to_string(GetLastError()));
295 
296         for ( func_num = 0; func_num != funcarray_size; func_num++ )
297         {
298                 if ( (pfunc[func_num] = (int32_t(__cdecl*)())GetProcAddress(module, func_names[func_num])) == nullptr )
299                 {
300                         FreeLibrary(module);
301 
302                         throw std::runtime_error(BUILD_STRING("Failed to load ", mb, "; missing exported function '", func_names[--func_num], "'"));
303                 }
304         }
305 
306         ui\&.library\&.pfunc_destroy_interface = pfunc[0];
307         ui\&.library\&.pfunc_process_interface = pfunc[1];
308         ui\&.library\&.pfunc_spawn_interface = pfunc[2];
309         ui\&.library\&.module = module;
310 
311         LOG(ELogLevel::Debug) << "Library loaded successfully (" << ui\&.library\&.module << ")\&. Functions:\n"
312                 "\t* destroy_interface = " << ui\&.library\&.pfunc_destroy_interface << "\n"
313                 "\t* process_interface = " << ui\&.library\&.pfunc_process_interface << "\n"
314                 "\t* spawn_interface = " << ui\&.library\&.pfunc_spawn_interface << "\n";
315 
316 #else
317 
318 #endif  // _WIN32
319 
320 }
.fi
.SS "Configuration::NO_CLASS_ASSIGNMENT (\fBConfiguration\fP)\fC [private]\fP"

.SS "Configuration::NO_CLASS_COPY (\fBConfiguration\fP)\fC [private]\fP"

.SS "const char * Configuration::Path () const"
Retrieves the configuration file path; pointer remains valid as long as this class exists (which as long as it's in runtime, is after main returns)\&. 
.PP
Definition at line 325 of file Configuration\&.cc\&.
.PP
References _path\&.
.PP
Referenced by spawn_interface()\&.
.PP
.nf
326 {
327         return _path\&.c_str();
328 }
.fi
.SS "void Configuration::Save ()"
Saves the current configuration to the file previously loaded\&. 
.SH "Friends And Related Function Documentation"
.PP 
.SS "friend class \fBRuntime\fP\fC [friend]\fP"

.PP
Definition at line 37 of file Configuration\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "std::string Configuration::_path\fC [private]\fP"
the path to the configuration file 
.PP
Definition at line 44 of file Configuration\&.h\&.
.PP
Referenced by Load(), and Path()\&.
.SS "\fBproxy\fP<std::string> Configuration::cfg_name"

.PP
Definition at line 165 of file Configuration\&.h\&.
.SS "\fBproxy\fP<char> Configuration::command_prefix"

.PP
Definition at line 151 of file Configuration\&.h\&.
.SS "\fBproxy\fP<bool> Configuration::enable_gui"

.PP
Definition at line 153 of file Configuration\&.h\&.
.SS "\fBproxy\fP<std::string> Configuration::file_name"

.PP
Definition at line 160 of file Configuration\&.h\&.
.SS "struct { \&.\&.\&. }   Configuration::library"

.PP
Referenced by app_exec()\&.
.SS "\fBproxy\fP<HMODULE> Configuration::module"

.PP
Definition at line 168 of file Configuration\&.h\&.
.PP
Referenced by LoadUI()\&.
.SS "\fBproxy\fP<bool> Configuration::no_terminal"

.PP
Definition at line 154 of file Configuration\&.h\&.
.SS "int32_t(* Configuration::pfunc_destroy_interface)()"

.PP
Definition at line 174 of file Configuration\&.h\&.
.SS "int32_t(* Configuration::pfunc_process_interface)()"

.PP
Definition at line 175 of file Configuration\&.h\&.
.SS "int32_t(* Configuration::pfunc_spawn_interface)()"

.PP
Definition at line 176 of file Configuration\&.h\&.
.SS "struct { \&.\&.\&. }   Configuration::ui"

.PP
Referenced by app_exec(), Dump(), Load(), and LoadUI()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Social Bot Interface from the source code\&.
