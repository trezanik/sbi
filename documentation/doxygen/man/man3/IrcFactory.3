.TH "IrcFactory" 3 "Mon Jun 23 2014" "Version 0.1" "Social Bot Interface" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IrcFactory \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <IrcFactory\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB~IrcFactory\fP ()"
.br
.ti -1c
.RI "std::shared_ptr< \fBIrcChannel\fP > \fBCreateIrcChannel\fP (std::shared_ptr< \fBIrcConnection\fP > parent_connection, const char *channel_name)"
.br
.ti -1c
.RI "std::shared_ptr< \fBIrcConnection\fP > \fBCreateIrcConnection\fP (std::shared_ptr< \fBIrcNetwork\fP > parent_network)"
.br
.ti -1c
.RI "std::shared_ptr< \fBIrcNetwork\fP > \fBCreateIrcNetwork\fP (const char *group_name)"
.br
.ti -1c
.RI "std::shared_ptr< \fBIrcUser\fP > \fBCreateIrcUser\fP (std::shared_ptr< \fBIrcChannel\fP > channel, const char *nickname, const char *ident, const char *hostmask)"
.br
.ti -1c
.RI "\fB~IrcFactory\fP ()"
.br
.ti -1c
.RI "\fBIrcChannel\fP * \fBCreateIrcChannel\fP (\fBIrcConnection\fP *parent_connection, const char *channel_name)"
.br
.ti -1c
.RI "\fBIrcConnection\fP * \fBCreateIrcConnection\fP (\fBIrcNetwork\fP *parent_network)"
.br
.ti -1c
.RI "\fBIrcNetwork\fP * \fBCreateIrcNetwork\fP (const char *group_name)"
.br
.ti -1c
.RI "\fBIrcUser\fP * \fBCreateIrcUser\fP (\fBIrcChannel\fP *channel, const char *nickname, const char *ident, const char *hostmask)"
.br
.ti -1c
.RI "void \fBDeleteIrcObject\fP (\fBIrcObject\fP *object)"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBNO_CLASS_ASSIGNMENT\fP (\fBIrcFactory\fP)"
.br
.ti -1c
.RI "\fBNO_CLASS_COPY\fP (\fBIrcFactory\fP)"
.br
.ti -1c
.RI "\fBIrcFactory\fP (\fBIrcEngine\fP *engine)"
.br
.ti -1c
.RI "\fBNO_CLASS_ASSIGNMENT\fP (\fBIrcFactory\fP)"
.br
.ti -1c
.RI "\fBNO_CLASS_COPY\fP (\fBIrcFactory\fP)"
.br
.ti -1c
.RI "\fBIrcFactory\fP (\fBIrcEngine\fP *engine)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBIrcEngine\fP * \fB_engine\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBIrcEngine\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Plugins should have no need to create any of the objects we supply, so all the rules regarding referencing and deletion functions should only apply to our own internal code\&.
.PP
Our memory debugging macros make this classes function declarations look peculiar at best, definitely violating our own style guidelines - but it's the only way to get the functionality we desire without hardcoding, or adding huge duplicated 'if' preprocessor blocks\&. 
.PP
Definition at line 41 of file IrcFactory\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "IrcFactory::IrcFactory (\fBIrcEngine\fP *engine)\fC [private]\fP"

.PP
Definition at line 29 of file IrcFactory\&.cc\&.
.PP
.nf
32 : _engine(engine)
33 {
34 }
.fi
.SS "IrcFactory::~IrcFactory ()"

.PP
Definition at line 38 of file IrcFactory\&.cc\&.
.PP
.nf
39 {
40 }
.fi
.SS "IrcFactory::IrcFactory (\fBIrcEngine\fP *engine)\fC [private]\fP"

.SS "IrcFactory::~IrcFactory ()"

.SH "Member Function Documentation"
.PP 
.SS "\fBIrcChannel\fP * IrcFactory::CreateIrcChannel (\fBIrcConnection\fP *parent_connection, const char *channel_name)"
Creates and constructs a new \fBIrcChannel\fP\&.
.PP
The object is actually returned from a memory pool, and constructed via placement new\&.
.PP
The function arguments match those of the normal constructor\&. If memory debugging is enabled for the build, the debug info is also supplied in at the same time\&.
.PP
\fBWarning:\fP
.RS 4
Do not use standard deletion functions/macros to free the object; it must be passed into \fBDeleteIrcObject()\fP, which handles the freeing of the memory directly from its pool\&.
.PP
The object is referenced before it is returned, so do not call it manually\&. In turn, when you want to delete it, do not dereference it; just call \fBDeleteIrcObject()\fP
.RE
.PP
\fBSee Also:\fP
.RS 4
Pool::Get() 
.PP
\fBDeleteIrcObject()\fP 
.PP
\fBIrcChannel()\fP 
.RE
.PP

.PP
Definition at line 51 of file bak/IrcFactory\&.cc\&.
.PP
References _engine, ObjectPool< T >::Get(), IrcPool::IrcChannels(), IRCPOOL_GET_ARGS, and IrcEngine::Pools()\&.
.PP
.nf
55 {
56         // obtain an IrcChannel from the object pool
57         IrcChannel*     channel = _engine->Pools()->IrcChannels()->Get(IRCPOOL_GET_ARGS);
58         
59         // placement new with constructor arguments
60         channel = ::new (channel) IrcChannel(parent_connection, channel_name);
61 
62         /* the constructors for the Irc objects notify the IrcEngine of their
63          * creation, in turn referencing them\&. As such, we don't need to do so
64          * here\&. */
65 
66         return channel;
67 }
.fi
.SS "std::shared_ptr< \fBIrcChannel\fP > IrcFactory::CreateIrcChannel (std::shared_ptr< \fBIrcConnection\fP >parent_connection, const char *channel_name)"
Creates and constructs a new \fBIrcChannel\fP\&.
.PP
The object is actually returned from a memory pool, and constructed via placement new\&.
.PP
The function arguments match those of the normal constructor\&. If memory debugging is enabled for the build, the debug info is also supplied in at the same time\&.
.PP
\fBWarning:\fP
.RS 4
Do not use standard deletion functions/macros to free the object; it must be passed into \fBDeleteIrcObject()\fP, which handles the freeing of the memory directly from its pool\&.
.PP
The object is referenced before it is returned, so do not call it manually\&. In turn, when you want to delete it, do not dereference it; just call \fBDeleteIrcObject()\fP
.RE
.PP
\fBSee Also:\fP
.RS 4
Pool::Get() 
.PP
\fBDeleteIrcObject()\fP 
.PP
\fBIrcChannel()\fP 
.RE
.PP

.PP
Definition at line 51 of file IrcFactory\&.cc\&.
.PP
References _engine, ObjectPool< T >::GetObject(), IrcPool::IrcChannels(), IRCPOOL_GET_ARGS, and IrcEngine::Pools()\&.
.PP
Referenced by IrcConnection::AddChannel(), and IrcEngine::CreateChannel()\&.
.PP
.nf
55 {
56         // obtain an IrcChannel from the object pool
57         std::shared_ptr<IrcChannel>     channel = _engine->Pools()->IrcChannels()->GetObject(IRCPOOL_GET_ARGS);
58         // as we're dealing with a shared_ptr, we need the raw type for the next step
59         IrcChannel*                     c = channel\&.get();
60 
61         // placement new with constructor arguments, using raw type
62         c = ::new (c) IrcChannel(parent_connection, channel_name);
63         
64         // return the shared_ptr, internal object constructed
65         return channel;
66 }
.fi
.SS "\fBIrcConnection\fP * IrcFactory::CreateIrcConnection (\fBIrcNetwork\fP *parent_network)"
Creates and constructs a new \fBIrcConnection\fP\&.
.PP
The object is actually returned from a memory pool, and constructed via placement new\&.
.PP
The function arguments match those of the normal constructor\&. If memory debugging is enabled for the build, the debug info is also supplied in at the same time\&.
.PP
\fBWarning:\fP
.RS 4
Do not use standard deletion functions/macros to free the object; it must be passed into \fBDeleteIrcObject()\fP, which handles the freeing of the memory directly from its pool\&.
.PP
The object is referenced before it is returned, so do not call it manually\&. In turn, when you want to delete it, do not dereference it; just call \fBDeleteIrcObject()\fP
.RE
.PP
\fBSee Also:\fP
.RS 4
Pool::Get() 
.PP
\fBDeleteIrcObject()\fP 
.PP
\fBIrcConnection()\fP 
.RE
.PP

.PP
Definition at line 72 of file bak/IrcFactory\&.cc\&.
.PP
References _engine, ObjectPool< T >::Get(), IrcPool::IrcConnections(), IRCPOOL_GET_ARGS, and IrcEngine::Pools()\&.
.PP
.nf
75 {
76         IrcConnection*  connection = _engine->Pools()->IrcConnections()->Get(IRCPOOL_GET_ARGS);
77 
78         
79         connection = ::new (connection) IrcConnection(parent_network);
80 
81         return connection;
82 }
.fi
.SS "std::shared_ptr< \fBIrcConnection\fP > IrcFactory::CreateIrcConnection (std::shared_ptr< \fBIrcNetwork\fP >parent_network)"
Creates and constructs a new \fBIrcConnection\fP\&.
.PP
The object is actually returned from a memory pool, and constructed via placement new\&.
.PP
The function arguments match those of the normal constructor\&. If memory debugging is enabled for the build, the debug info is also supplied in at the same time\&.
.PP
\fBWarning:\fP
.RS 4
Do not use standard deletion functions/macros to free the object; it must be passed into \fBDeleteIrcObject()\fP, which handles the freeing of the memory directly from its pool\&.
.PP
The object is referenced before it is returned, so do not call it manually\&. In turn, when you want to delete it, do not dereference it; just call \fBDeleteIrcObject()\fP
.RE
.PP
\fBSee Also:\fP
.RS 4
Pool::Get() 
.PP
\fBDeleteIrcObject()\fP 
.PP
\fBIrcConnection()\fP 
.RE
.PP

.PP
Definition at line 71 of file IrcFactory\&.cc\&.
.PP
References _engine, ObjectPool< T >::GetObject(), IrcPool::IrcConnections(), IRCPOOL_GET_ARGS, and IrcEngine::Pools()\&.
.PP
Referenced by IrcEngine::CreateConnection()\&.
.PP
.nf
74 {
75         std::shared_ptr<IrcConnection>  connection = _engine->Pools()->IrcConnections()->GetObject(IRCPOOL_GET_ARGS);
76         IrcConnection*                  c = connection\&.get();
77 
78         c = ::new (c) IrcConnection(parent_network);
79 
80         return connection;
81 }
.fi
.SS "\fBIrcNetwork\fP* IrcFactory::CreateIrcNetwork (const char *group_name)"
Creates and constructs a new \fBIrcNetwork\fP\&.
.PP
The object is actually returned from a memory pool, and constructed via placement new\&.
.PP
The function arguments match those of the normal constructor\&. If memory debugging is enabled for the build, the debug info is also supplied in at the same time\&.
.PP
\fBWarning:\fP
.RS 4
Do not use standard deletion functions/macros to free the object; it must be passed into \fBDeleteIrcObject()\fP, which handles the freeing of the memory directly from its pool\&.
.PP
The object is referenced before it is returned, so do not call it manually\&. In turn, when you want to delete it, do not dereference it; just call \fBDeleteIrcObject()\fP
.RE
.PP
\fBSee Also:\fP
.RS 4
Pool::Get() 
.PP
\fBDeleteIrcObject()\fP 
.PP
\fBIrcNetwork()\fP 
.RE
.PP

.SS "\fBIrcNetwork\fP * IrcFactory::CreateIrcNetwork (const char *group_name)"
Creates and constructs a new \fBIrcNetwork\fP\&.
.PP
The object is actually returned from a memory pool, and constructed via placement new\&.
.PP
The function arguments match those of the normal constructor\&. If memory debugging is enabled for the build, the debug info is also supplied in at the same time\&.
.PP
\fBWarning:\fP
.RS 4
Do not use standard deletion functions/macros to free the object; it must be passed into \fBDeleteIrcObject()\fP, which handles the freeing of the memory directly from its pool\&.
.PP
The object is referenced before it is returned, so do not call it manually\&. In turn, when you want to delete it, do not dereference it; just call \fBDeleteIrcObject()\fP
.RE
.PP
\fBSee Also:\fP
.RS 4
Pool::Get() 
.PP
\fBDeleteIrcObject()\fP 
.PP
\fBIrcNetwork()\fP 
.RE
.PP

.PP
Definition at line 86 of file IrcFactory\&.cc\&.
.PP
References _engine, ObjectPool< T >::GetObject(), IrcPool::IrcNetworks(), IRCPOOL_GET_ARGS, and IrcEngine::Pools()\&.
.PP
Referenced by IrcEngine::CreateNetwork()\&.
.PP
.nf
89 {
90         std::shared_ptr<IrcNetwork>     network = _engine->Pools()->IrcNetworks()->GetObject(IRCPOOL_GET_ARGS);
91         IrcNetwork*                     n = network\&.get();
92 
93         n = ::new (n) IrcNetwork(group_name);
94 
95         return network;
96 }
.fi
.SS "\fBIrcUser\fP * IrcFactory::CreateIrcUser (\fBIrcChannel\fP *channel, const char *nickname, const char *ident, const char *hostmask)"
Creates and constructs a new \fBIrcUser\fP\&.
.PP
The object is actually returned from a memory pool, and constructed via placement new\&.
.PP
The function arguments match those of the normal constructor\&. If memory debugging is enabled for the build, the debug info is also supplied in at the same time\&.
.PP
\fBWarning:\fP
.RS 4
Do not use standard deletion functions/macros to free the object; it must be passed into \fBDeleteIrcObject()\fP, which handles the freeing of the memory directly from its pool\&.
.PP
The object is referenced before it is returned, so do not call it manually\&. In turn, when you want to delete it, do not dereference it; just call \fBDeleteIrcObject()\fP
.RE
.PP
\fBSee Also:\fP
.RS 4
Pool::Get() 
.PP
\fBDeleteIrcObject()\fP 
.PP
\fBIrcUser()\fP 
.RE
.PP

.PP
Definition at line 101 of file bak/IrcFactory\&.cc\&.
.PP
References _engine, ObjectPool< T >::Get(), IRCPOOL_GET_ARGS, IrcPool::IrcUsers(), and IrcEngine::Pools()\&.
.PP
.nf
107 {
108         IrcUser*        user = _engine->Pools()->IrcUsers()->Get(IRCPOOL_GET_ARGS);
109         
110         user = ::new (user) IrcUser(channel, nickname, ident, hostmask);
111 
112         return user;
113 }
.fi
.SS "std::shared_ptr< \fBIrcUser\fP > IrcFactory::CreateIrcUser (std::shared_ptr< \fBIrcChannel\fP >channel, const char *nickname, const char *ident, const char *hostmask)"
Creates and constructs a new \fBIrcUser\fP\&.
.PP
The object is actually returned from a memory pool, and constructed via placement new\&.
.PP
The function arguments match those of the normal constructor\&. If memory debugging is enabled for the build, the debug info is also supplied in at the same time\&.
.PP
\fBWarning:\fP
.RS 4
Do not use standard deletion functions/macros to free the object; it must be passed into \fBDeleteIrcObject()\fP, which handles the freeing of the memory directly from its pool\&.
.PP
The object is referenced before it is returned, so do not call it manually\&. In turn, when you want to delete it, do not dereference it; just call \fBDeleteIrcObject()\fP
.RE
.PP
\fBSee Also:\fP
.RS 4
Pool::Get() 
.PP
\fBDeleteIrcObject()\fP 
.PP
\fBIrcUser()\fP 
.RE
.PP

.PP
Definition at line 101 of file IrcFactory\&.cc\&.
.PP
References _engine, ObjectPool< T >::GetObject(), IRCPOOL_GET_ARGS, IrcPool::IrcUsers(), and IrcEngine::Pools()\&.
.PP
Referenced by IrcChannel::AddUser(), and IrcEngine::CreateUser()\&.
.PP
.nf
107 {
108         std::shared_ptr<IrcUser>        user = _engine->Pools()->IrcUsers()->GetObject(IRCPOOL_GET_ARGS);
109         IrcUser*                        u = user\&.get();
110 
111         u = ::new (u) IrcUser(channel, nickname, ident, hostmask);
112 
113         return user;
114 }
.fi
.SS "void IrcFactory::DeleteIrcObject (\fBIrcObject\fP *object)"
To be used for deleting an IRC object returned from this factorys methods\&.
.PP
Yes, we could have a separate function for each IRC object type; but they would all do the same thing as this, just with a little less runtime overhead, in return for less code duplication\&.
.PP
\fBParameters:\fP
.RS 4
\fIobject\fP The IRC object to return to its respective pool 
.RE
.PP

.PP
Definition at line 118 of file bak/IrcFactory\&.cc\&.
.PP
References _engine, fg_red(), ObjectPool< T >::Free(), IrcPool::IrcChannels(), IrcPool::IrcConnections(), IrcPool::IrcNetworks(), IrcPool::IrcUsers(), LOG, and IrcEngine::Pools()\&.
.PP
Referenced by IrcConnection::DeleteChannel(), and IrcChannel::DeleteUser()\&.
.PP
.nf
121 {
122         IrcChannel*     rtti_channel;
123         IrcConnection*  rtti_connection;
124         IrcNetwork*     rtti_network;
125         IrcUser*        rtti_user;
126 
127         // Pools' Free() executes a Dereference(), we don't need to
128 
129         if (( rtti_channel = dynamic_cast<IrcChannel*>(object)) != nullptr )
130         {
131                 _engine->Pools()->IrcChannels()->Free(rtti_channel);
132         }
133         else if (( rtti_connection = dynamic_cast<IrcConnection*>(object)) != nullptr )
134         {
135                 _engine->Pools()->IrcConnections()->Free(rtti_connection);
136         }
137         else if (( rtti_network = dynamic_cast<IrcNetwork*>(object)) != nullptr )
138         {
139                 _engine->Pools()->IrcNetworks()->Free(rtti_network);
140         }
141         else if (( rtti_user = dynamic_cast<IrcUser*>(object)) != nullptr )
142         {
143                 _engine->Pools()->IrcUsers()->Free(rtti_user);
144         }
145         else
146         {
147                 std::cerr << fg_red << "The object " << std::hex << object << " did not match an IRC type\n";
148                 LOG(LL_Error) << "The object " << std::hex << object << " did not match an IRC type\n";
149         }
150 
151 }
.fi
.SS "IrcFactory::NO_CLASS_ASSIGNMENT (\fBIrcFactory\fP)\fC [private]\fP"

.SS "IrcFactory::NO_CLASS_ASSIGNMENT (\fBIrcFactory\fP)\fC [private]\fP"

.SS "IrcFactory::NO_CLASS_COPY (\fBIrcFactory\fP)\fC [private]\fP"

.SS "IrcFactory::NO_CLASS_COPY (\fBIrcFactory\fP)\fC [private]\fP"

.SH "Friends And Related Function Documentation"
.PP 
.SS "\fBIrcEngine\fP\fC [friend]\fP"

.PP
Definition at line 44 of file IrcFactory\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "\fBIrcEngine\fP * IrcFactory::_engine\fC [private]\fP"
A pointer to the IRC engine; saves having to access it through the runtime constantly\&. Owns this class, so will always exist as long as this factory does\&. 
.PP
Definition at line 58 of file IrcFactory\&.h\&.
.PP
Referenced by CreateIrcChannel(), CreateIrcConnection(), CreateIrcNetwork(), CreateIrcUser(), and DeleteIrcObject()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Social Bot Interface from the source code\&.
