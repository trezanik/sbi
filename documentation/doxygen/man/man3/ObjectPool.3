.TH "ObjectPool< T >" 3 "Mon Jun 23 2014" "Version 0.1" "Social Bot Interface" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ObjectPool< T > \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <IrcPool\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBObjectPool\fP ()"
.br
.ti -1c
.RI "\fB~ObjectPool\fP ()"
.br
.ti -1c
.RI "std::vector< std::shared_ptr
.br
< T > > & \fBAllocated\fP ()"
.br
.ti -1c
.RI "bool \fBFreeObject\fP (std::shared_ptr< T > object)"
.br
.ti -1c
.RI "std::shared_ptr< T > \fBGetObject\fP (\fBIRCPOOL_GET_DECL\fP)"
.br
.ti -1c
.RI "bool \fBGrandAlloc\fP (uint32_t num_objects)"
.br
.ti -1c
.RI "void \fBTotalErase\fP ()"
.br
.ti -1c
.RI "\fBObjectPool\fP ()"
.br
.ti -1c
.RI "\fB~ObjectPool\fP ()"
.br
.ti -1c
.RI "bool \fBFree\fP (T *object)"
.br
.ti -1c
.RI "T * \fBGet\fP (\fBIRCPOOL_GET_DECL\fP)"
.br
.ti -1c
.RI "bool \fBGrandAlloc\fP (uint32_t num_objects)"
.br
.ti -1c
.RI "void \fBTotalErase\fP ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBNO_CLASS_ASSIGNMENT\fP (\fBObjectPool\fP)"
.br
.ti -1c
.RI "\fBNO_CLASS_COPY\fP (\fBObjectPool\fP)"
.br
.ti -1c
.RI "void \fBOutputMemoryInfo\fP (const char *out_filename)"
.br
.ti -1c
.RI "void \fBReallyFreeObject\fP (std::shared_ptr< T > object)"
.br
.ti -1c
.RI "\fBNO_CLASS_ASSIGNMENT\fP (\fBObjectPool\fP)"
.br
.ti -1c
.RI "\fBNO_CLASS_COPY\fP (\fBObjectPool\fP)"
.br
.ti -1c
.RI "void \fBOutputMemoryInfo\fP (char *file_name, bool destruction)"
.br
.ti -1c
.RI "void \fBReportReferencedObject\fP (T *object)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "void * \fB_pool\fP"
.br
.ti -1c
.RI "std::vector< std::shared_ptr< T > > \fB_objects\fP"
.br
.ti -1c
.RI "std::vector< std::shared_ptr< T > > \fB_delete_later\fP"
.br
.ti -1c
.RI "std::stack< T > \fB_used_list\fP"
.br
.ti -1c
.RI "std::stack< T > \fB_free_list\fP"
.br
.ti -1c
.RI "uint32_t \fB_get_count\fP"
.br
.ti -1c
.RI "uint32_t \fB_max_alive\fP"
.br
.ti -1c
.RI "std::mutex \fB_mutex\fP"
.br
.ti -1c
.RI "std::stack< T * > \fB_used_list\fP"
.br
.ti -1c
.RI "std::stack< T * > \fB_free_list\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class T>class ObjectPool< T >"
A simple memory pool 
.PP
Definition at line 81 of file IrcPool\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<class T> \fBObjectPool\fP< T >::\fBObjectPool\fP ()\fC [inline]\fP"

.PP
Definition at line 197 of file IrcPool\&.h\&.
.PP
.nf
197                      : _pool(nullptr), _get_count(0)
198         {
199         }
.fi
.SS "template<class T> \fBObjectPool\fP< T >::~\fBObjectPool\fP ()\fC [inline]\fP"

.PP
Definition at line 200 of file IrcPool\&.h\&.
.PP
.nf
201         {
202                 /* Mandatory output; allows us to see the amount of allocations
203                  * per object, useful for future optimization - such as a more
204                  * suitable amount for GrandAlloc */
205                 OutputMemoryInfo(BUILD_STRING(typeid(T)\&.name(), "\&.log")\&.c_str());
206                 // ensure we're not leaving anything allocated
207                 TotalErase();
208         }
.fi
.SS "template<class T> \fBObjectPool\fP< T >::\fBObjectPool\fP ()\fC [inline]\fP"

.PP
Definition at line 199 of file bak/IrcPool\&.h\&.
.PP
.nf
199                      : _pool(nullptr), _get_count(0)
200         {
201         }
.fi
.SS "template<class T> \fBObjectPool\fP< T >::~\fBObjectPool\fP ()\fC [inline]\fP"

.PP
Definition at line 202 of file bak/IrcPool\&.h\&.
.PP
.nf
203         {
204                 /* Mandatory output; allows us to see the amount of allocations
205                  * per object, useful for future optimization - such as a more
206                  * suitable amount for GrandAlloc */
207                 OutputMemoryInfo("object_pool\&.log", true);
208                 // ensure we're not leaving anything allocated
209                 TotalErase();
210         }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<class T> std::vector<std::shared_ptr<T> >& \fBObjectPool\fP< T >::Allocated ()\fC [inline]\fP"
Returns the list of allocated objects currently live 
.PP
Definition at line 215 of file IrcPool\&.h\&.
.PP
Referenced by IrcPool::GetChannel(), IrcPool::GetConnection(), IrcPool::GetNetwork(), IrcPool::GetUser(), IrcParser::HandleQuit(), and IrcParser::RunParser()\&.
.PP
.nf
216         {
217                 return _objects;
218         }
.fi
.SS "template<class T> bool \fBObjectPool\fP< T >::Free (T *object)\fC [inline]\fP"
Returns the supplied object to the pool, and calls the destructor\&. 
.PP
Definition at line 217 of file bak/IrcPool\&.h\&.
.PP
Referenced by IrcFactory::DeleteIrcObject()\&.
.PP
.nf
220         {
221                 // validate it came from our pool?
222 
223                 _mutex\&.lock();
224 
225                 /* Destructor is called by ourselves; this means that we must do
226                  * all checks before that point, which in this case, is reporting
227                  * if the object still has outstanding references\&. 
228                  * The objects notify the Engine of their creation and
229                  * deletion in its constructor/destructor respectively\&. As such,
230                  * when freeing the object in our code, this should be the only
231                  * remaining reference, since we can't check the reference count
232                  * AFTER we've deleted it\&. If it's still got more than 1, then
233                  * somethings wrong\&. */
234                 if ( object->RefCount() != 0 )
235                 {
236                         ReportReferencedObject(object);
237                 }
238 
239                 /* in order to call the destructor here, we must have a pointer
240                  * to the object type (is deemed non-trivial otherwise)\&.
241                  * We must call the destructor manually, as letting the Object
242                  * Dereference call do it will NOT invoke any derived destructors
243                  * at the same time\&. */
244                 T*      obj = object;
245                 obj->~T();
246 
247                 LOG(LL_Debug) << "Object " << object << " given back to the pool\n";
248 
249                 // add the address back to the free pool
250                 _free_list\&.push(static_cast<T*>(object));
251                 // pop it off the used list
252                 _used_list\&.pop();
253 
254 #if defined(USING_MEMORY_DEBUGGING)
255                 // auto fail!
256                 for ( std::vector<pool_object_meminfo>::iterator info = _infovect\&.begin();
257                         info != _infovect\&.end();
258                         info++ )
259                 {
260                         if ( (info)->object == (void*)object )
261                         {
262                                 _infovect\&.erase(info);
263                                 break;
264                         }
265                 }
266 #endif
267 
268                 _mutex\&.unlock();
269                 return true;
270         }
.fi
.SS "template<class T> bool \fBObjectPool\fP< T >::FreeObject (std::shared_ptr< T >object)\fC [inline]\fP"
Returns the supplied object to the pool, and calls the destructor\&. 
.PP
Definition at line 225 of file IrcPool\&.h\&.
.PP
Referenced by IrcConnection::DeleteChannel(), IrcChannel::DeleteUser(), IrcConnection::EraseChannelList(), and IrcChannel::EraseNameslist()\&.
.PP
.nf
228         {
229                 // validate it came from our pool?
230 
231                 _mutex\&.lock();
232 
233                 /* If the object is still referenced by more than just this
234                  * current function (and our _object list), we cannot add it 
235                  * back to the free list, as it could be reallocated and screw 
236                  * things up\&. 
237                  * At the same time, we can't keep checking references in caller
238                  * code or waiting for objects to die, so we add it to the 
239                  * 'delete-later' list, so it can be reclaimed later\&.
240                  */
241                 if ( object\&.use_count() > 2 )
242                 {
243                         // still referenced; reattempt delete later
244                         _delete_later\&.push_back(object);
245                         return true;
246                 }
247                 
248                 /* release the actual resources it's using and provide the
249                  * pointers back to the lists */
250                 ReallyFreeObject(object);
251 
252                 _mutex\&.unlock();
253 
254                 // IrcObject destructor called on this functions return!!
255                 return true;
256         }
.fi
.SS "template<class T> T* \fBObjectPool\fP< T >::Get (\fBIRCPOOL_GET_DECL\fP)\fC [inline]\fP"
Returns the next available pointer 
.PP
\fBTodo\fP
.RS 4
implement GrandAlloc dynamic expansion 
.RE
.PP

.PP
Definition at line 277 of file bak/IrcPool\&.h\&.
.PP
Referenced by IrcFactory::CreateIrcChannel(), IrcFactory::CreateIrcConnection(), and IrcFactory::CreateIrcUser()\&.
.PP
.nf
280         {
281                 _mutex\&.lock();
282 
283                 if ( _free_list\&.empty() )
284                 {
286                         /* argh\&.\&. we've breached our allocation limit - we need to do a
287                          * fresh set to bring us up - the policy is 50% of the current
288                          * max (i\&.e\&. GrandAlloc(10) means if we breach, an extra 5
289                          * elements will be added - a second breach adds 8, and so on) */
290                         //uint32_t      additional = _used_list\&.size() / 2;
291                 }
292                 
293                 T*      object = _free_list\&.top();
294 
295                 // remove one of the free elements from the stack
296                 _free_list\&.pop();
297 
298 #if defined(USING_MEMORY_DEBUGGING)
299                 pool_object_meminfo     info;
300 
301 #       if IS_DEBUG_BUILD && IS_VISUAL_STUDIO
302                 // we don't want the full path information that VS sets in debug mode
303                 file = (strrchr(file, PATH_CHAR) + 1);
304 #       endif
305 
306                 info\&.object      = object;
307                 info\&.line        = line;
308                 strlcpy(info\&.file, file, sizeof(info\&.file));
309                 strlcpy(info\&.function, function, sizeof(info\&.function));
310 
311                 _infovect\&.push_back(info);
312 #endif
313 
314 #if 0   // Code Removed: ObjectPool class performs placement new to support multiple parameters
315                 /* construct the object - no arguments! Achievable with some variadic 
316                  * templates, but good luck following and maintaining the code\&.\&.\&. */
317                 //new (object) T;
318 #endif
319 
320                 // push our created object onto the used elements
321                 _used_list\&.push(object);
322 
323                 // update stats
324                 _get_count++;
325                 if ( _used_list\&.size() > _max_alive )
326                         _max_alive = _used_list\&.size();
327 
328                 LOG(LL_Debug) << "Object " << object << " acquired from the pool\n";
329 
330                 _mutex\&.unlock();
331 
332                 return object;
333         }
.fi
.SS "template<class T> std::shared_ptr<T> \fBObjectPool\fP< T >::GetObject (\fBIRCPOOL_GET_DECL\fP)\fC [inline]\fP"
Returns the next available pointer 
.PP
\fBTodo\fP
.RS 4
implement GrandAlloc dynamic expansion 
.RE
.PP

.PP
Definition at line 263 of file IrcPool\&.h\&.
.PP
Referenced by IrcFactory::CreateIrcChannel(), IrcFactory::CreateIrcConnection(), IrcFactory::CreateIrcNetwork(), and IrcFactory::CreateIrcUser()\&.
.PP
.nf
266         {
267                 _mutex\&.lock();
268 
269                 /* seems an opportune time to check the delete_later
270                  * list and actually delete the old objects */
271                 {
272                 }
273 
274                 if ( _free_list\&.empty() )
275                 {
277                         /* argh\&.\&. we've breached our allocation limit - we need to do a
278                          * fresh set to bring us up - the policy is 50% of the current
279                          * max (i\&.e\&. GrandAlloc(10) means if we breach, an extra 5
280                          * elements will be added - a second breach adds 8, and so on) */
281                         //uint32_t      additional = _used_list\&.size() / 2;
282                 }
283                 
284                 T*      object = _free_list\&.top();
285 
286                 // remove one of the free elements from the stack
287                 _free_list\&.pop();
288 
289 #if 0   // Code Removed: no manual reference tracking done anymore, using std::shared_ptr
290 #if defined(USING_MEMORY_DEBUGGING)
291                 pool_object_meminfo     info;
292 
293 #       if IS_DEBUG_BUILD && IS_VISUAL_STUDIO
294                 // we don't want the full path information that VS sets in debug mode
295                 file = (strrchr(file, PATH_CHAR) + 1);
296 #       endif
297 
298                 info\&.object      = object;
299                 info\&.line        = line;
300                 strlcpy(info\&.file, file, sizeof(info\&.file));
301                 strlcpy(info\&.function, function, sizeof(info\&.function));
302 
303                 _infovect\&.push_back(info);
304 #endif
305 #endif
306 
307                 // push our created object onto the used elements
308                 _used_list\&.push(object);
309 
310                 // update stats
311                 _get_count++;
312                 if ( _used_list\&.size() > _max_alive )
313                         _max_alive = _used_list\&.size();
314 
315                 LOG(ELogLevel::Debug) << "Object " << object << " acquired from the pool\n";
316 
317                 std::shared_ptr<T>      ptr;
318                 /* assign the object pointer as shared; no constructors yet! The
319                  * caller, factory, will utilize placement new for this task */
320                 ptr\&.reset(object);
321                 /* store this pointer until requested to free it; by default,
322                  * nothing retains a pointer to one of these objects, so it will
323                  * hit a reference count of 0 upon scope exit where created */
324                 _objects\&.push_back(ptr);
325 
326                 _mutex\&.unlock();
327 
328                 return ptr;
329         }
.fi
.SS "template<class T> bool \fBObjectPool\fP< T >::GrandAlloc (uint32_tnum_objects)\fC [inline]\fP"
Allocates the requested number of objects\&.
.PP
The goal is not to call this at all, while the game is active; if the requested amount exceeds the current available, a large memory allocation will be performed, potentially causing contention\&.
.PP
Designed to be called once, based on the game specs and options, until the game finishes, where all objects are released\&.
.PP
If USING_MEMORY_DEBUGGING, space will be reserved at the end of each object (essentially no-mans land), which will store the details of the caller of \fBGet()\fP
.PP
\fBParameters:\fP
.RS 4
\fInum_objects\fP The number of Objects of type T to allocate 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true if all of the objects were allocated; if num_objects is 0, or allocation fails, the function returns false 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
throw nullptr or runtime_error on malloc failure? 
.RE
.PP

.PP
Definition at line 351 of file IrcPool\&.h\&.
.PP
.nf
354         {
355                 T*              offset;
356                 uint32_t        to_alloc = sizeof(T) * num_objects;
357 
358                 if ( num_objects == 0 )
359                         return false;
360 
361                 _mutex\&.lock();
362 
363 #if defined(USING_MEMORY_DEBUGGING)
364                 // since we know how many objects there will be
365                 _infovect\&.reserve(num_objects);
366 #endif
367 
368                 // one 'huge' heap allocation
369                 _pool = MALLOC(to_alloc);
370 
371                 if ( _pool == nullptr )
372                 {
374                         _mutex\&.unlock();
375                         return false;
376                 }
377 
378                 offset = static_cast<T*>(_pool);
379 
380                 for ( uint32_t i = 0; i < num_objects; i++ )
381                 {
382                         // push each object offset into the free list
383                         _free_list\&.push(offset);
384                         offset++;
385                 }
386 
387                 _mutex\&.unlock();
388                 return true;
389         }
.fi
.SS "template<class T> bool \fBObjectPool\fP< T >::GrandAlloc (uint32_tnum_objects)\fC [inline]\fP"
Allocates the requested number of objects\&.
.PP
The goal is not to call this at all, while the game is active; if the requested amount exceeds the current available, a large memory allocation will be performed, potentially causing contention\&.
.PP
Designed to be called once, based on the game specs and options, until the game finishes, where all objects are released\&.
.PP
If USING_MEMORY_DEBUGGING, space will be reserved at the end of each object (essentially no-mans land), which will store the details of the caller of \fBGet()\fP
.PP
\fBParameters:\fP
.RS 4
\fInum_objects\fP The number of Objects of type T to allocate 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true if all of the objects were allocated; if num_objects is 0, or allocation fails, the function returns false 
.RE
.PP

.PP
\fBTodo\fP
.RS 4
throw nullptr or runtime_error on malloc failure? 
.RE
.PP

.PP
Definition at line 355 of file bak/IrcPool\&.h\&.
.PP
.nf
358         {
359                 T*              offset;
360                 uint32_t        to_alloc = sizeof(T) * num_objects;
361 
362                 if ( num_objects == 0 )
363                         return false;
364 
365                 _mutex\&.lock();
366 
367 #if defined(USING_MEMORY_DEBUGGING)
368                 // since we know how many objects there will be
369                 _infovect\&.reserve(num_objects);
370 #endif
371 
372                 // one 'huge' heap allocation
373                 _pool = MALLOC(to_alloc);
374 
375                 if ( _pool == nullptr )
376                 {
378                         _mutex\&.unlock();
379                         return false;
380                 }
381 
382                 offset = static_cast<T*>(_pool);
383 
384                 for ( uint32_t i = 0; i < num_objects; i++ )
385                 {
386                         // push each object offset into the free list
387                         _free_list\&.push(offset);
388                         offset++;
389                 }
390 
391                 _mutex\&.unlock();
392                 return true;
393         }
.fi
.SS "template<class T> \fBObjectPool\fP< T >::NO_CLASS_ASSIGNMENT (\fBObjectPool\fP< T >)\fC [private]\fP"

.SS "template<class T> \fBObjectPool\fP< T >::NO_CLASS_ASSIGNMENT (\fBObjectPool\fP< T >)\fC [private]\fP"

.SS "template<class T> \fBObjectPool\fP< T >::NO_CLASS_COPY (\fBObjectPool\fP< T >)\fC [private]\fP"

.SS "template<class T> \fBObjectPool\fP< T >::NO_CLASS_COPY (\fBObjectPool\fP< T >)\fC [private]\fP"

.SS "template<class T> void \fBObjectPool\fP< T >::OutputMemoryInfo (char *file_name, booldestruction)\fC [inline]\fP, \fC [private]\fP"
Same style as the \fBOutputMemoryInfo()\fP from Allocator, where this was adapted from originally\&. 
.PP
Definition at line 112 of file bak/IrcPool\&.h\&.
.PP
.nf
116         {
117                 FILE*   leak_file;
118                 bool    close_file = true;
119 
120                 if ( (leak_file = _fsopen(file_name, "wb", _SH_DENYWR)) == nullptr )
121                 {
122                         leak_file = stdout;
123                         close_file = false;
124                 }
125                 
126                 if ( destruction )
127                 {
128                         fprintf(leak_file, "\n[Pool Destruction]\n");
129                 }
130 
131                 _mutex\&.lock();
132 
133                 fprintf(leak_file,
134                         "# Details\n"
135                         "Object Type\&.\&.\&.: %s\n"
136                         "Object Size\&.\&.\&.: %lu\n"
137                         "\n"
138                         "# Code Stats\n"
139                         "Created\&.\&.\&.\&.\&.\&.\&.: %lu\n"
140                         "Requested\&.\&.\&.\&.\&.: %lu\n"
141                         "Released\&.\&.\&.\&.\&.\&.: %lu\n"
142                         "Unreleased\&.\&.\&.\&.: %lu\n"
143                         "\n"
144                         "##################\n",
145                         typeid(T)\&.name(),
146                         sizeof(T),
147                         // free_list size is valid only if there's no leaks!
148                         (_used_list\&.size() + _free_list\&.size()),
149                         _get_count,
150                         (_get_count - _used_list\&.size()),
151                         _used_list\&.size()
152                 );
153 
154 #if defined(USING_MEMORY_DEBUGGING)
155                 for ( auto meminfo : _infovect )
156                 {
157                         fprintf(leak_file, "%s object at " PRINT_POINTER " (%s @ %s:%u, %u bytes)\n",
158                                 destruction ? "Unfreed" : "Allocated",
159                                 (uintptr_t)meminfo\&.object,
160                                 meminfo\&.function,
161                                 meminfo\&.file,
162                                 meminfo\&.line,
163                                 sizeof(T));
164                 }
165 #endif  // USING_MEMORY_DEBUGGING
166 
167                 _mutex\&.unlock();
168 
169                 if ( close_file )
170                         fclose(leak_file);
171         }
.fi
.SS "template<class T> void \fBObjectPool\fP< T >::OutputMemoryInfo (const char *out_filename)\fC [inline]\fP, \fC [private]\fP"
Same style as the \fBOutputMemoryInfo()\fP from Allocator, where this was adapted from originally\&. 
.PP
Definition at line 116 of file IrcPool\&.h\&.
.PP
.nf
119         {
120                         FILE*   out_file;
121                         bool    close_file = true;
122 
123                         if (( out_file = _fsopen(out_filename, "wb", _SH_DENYWR)) == nullptr )
124                         {
125                                 out_file = stdout;
126                                 close_file = false;
127                         }
128 
129                         _mutex\&.lock();
130 
131                         fprintf(out_file,
132                                 "# Details\n"
133                                 "Object Type\&.\&.\&.: %s\n"
134                                 "Object Size\&.\&.\&.: %lu\n"
135                                 "\n"
136                                 "# Code Stats\n"
137                                 "Created\&.\&.\&.\&.\&.\&.\&.: %lu\n"
138                                 "Requested\&.\&.\&.\&.\&.: %u\n"
139                                 "Released\&.\&.\&.\&.\&.\&.: %lu\n"
140                                 "Unreleased\&.\&.\&.\&.: %lu\n"
141                                 "Most Alive\&.\&.\&.\&.: %u\n"
142                                 "\n"
143                                 "##################\n",
144                                 typeid(T)\&.name(),
145                                 sizeof(T),
146                                 // free_list size is valid only if there's no leaks!
147                                 (_used_list\&.size() + _free_list\&.size()),
148                                 _get_count,
149                                 (_get_count - _used_list\&.size()),
150                                 _used_list\&.size(),
151                                 _max_alive
152                                 );
153 
154 #if 0   // Code Removed: no manual reference tracking done anymore, using std::shared_ptr
155 #if defined(USING_MEMORY_DEBUGGING)
156                         for ( auto meminfo : _infovect )
157                         {
158                                 fprintf(out_file, "%s object at " PRINT_POINTER " (%s @ %s:%u, %lu bytes)\n",
159                                         destruction ? "Unfreed" : "Allocated",
160                                         (uintptr_t)meminfo\&.object,
161                                         meminfo\&.function,
162                                         meminfo\&.file,
163                                         meminfo\&.line,
164                                         sizeof(T));
165                         }
166 #endif  // USING_MEMORY_DEBUGGING
167 #endif
168 
169                 _mutex\&.unlock();
170 
171                 if ( close_file )
172                 {
173                         fclose(out_file);
174                 }
175         }
.fi
.SS "template<class T> void \fBObjectPool\fP< T >::ReallyFreeObject (std::shared_ptr< T >object)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 180 of file IrcPool\&.h\&.
.PP
.nf
183         {
184                 LOG(ELogLevel::Debug) << "Object " << object << " given back to the pool\n";
185 
186                 // add the address back to the free pool
187                 _free_list\&.push(object);
188                 // pop it off the used list
189                 _used_list\&.pop();
190                 // and remove our reference to it
191                 _objects\&.erase(std::find(_objects\&.begin(), _objects\&.end(), object));
192         }
.fi
.SS "template<class T> void \fBObjectPool\fP< T >::ReportReferencedObject (T *object)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 177 of file bak/IrcPool\&.h\&.
.PP
.nf
180         {
181                 char    buffer[MAX_LEN_GENERIC];
182 
183                 str_format(buffer, sizeof(buffer), 
184                            "Referenced Object Freed\n\n"
185                            "Object:\t\t " PRINT_POINTER "\n"
186                            "Type:\t\t %s\n"
187                            "References:\t %lu\n\n"
188                            "Further accesses to this object will cause a crash",
189                         (uintptr_t)object,
190                         typeid(T)\&.name(),
191                         object->RefCount()
192                 );
193 
194                 runtime\&.Report(buffer, "Error");
195         }
.fi
.SS "template<class T> void \fBObjectPool\fP< T >::TotalErase ()\fC [inline]\fP"
Used for wiping out any existing pool items (which yes, will cause a crash if these are still referenced and valid objects); generally shouldn't be called out of the destructor, but this leaves the option open for cleanup functions\&. 
.PP
Definition at line 400 of file IrcPool\&.h\&.
.PP
.nf
401         {
402                 /* recursive mutex, so we can have the same thread locking
403                  * multiple times without a problem */
404                 _mutex\&.lock();
405 
406                 while ( !_used_list\&.empty() )
407                 {
408                         FreeObject(_used_list\&.top());
409                 }
410 
411                 // wait until all shared pointers are actually destroyed
412                 while ( !_delete_later\&.empty() )
413                 {
414                         SLEEP_MILLISECONDS(100);
415                 }
416 
417 
418                 if ( !_objects\&.empty() )
419                 {
420                         throw std::runtime_error("Objects still exist on pool deletion");
421                 }
422 
423 
424                 if ( _pool != nullptr )
425                 {
426                         FREE(_pool);
427                         _pool = nullptr;
428                 }
429 
430                 _mutex\&.unlock();
431         }
.fi
.SS "template<class T> void \fBObjectPool\fP< T >::TotalErase ()\fC [inline]\fP"
Used for wiping out any existing pool items (which yes, will cause a crash if these are still referenced and valid objects); generally shouldn't be called out of the destructor, but this leaves the option open for cleanup functions\&. 
.PP
Definition at line 403 of file bak/IrcPool\&.h\&.
.PP
.nf
404         {
405                 /* recursive mutex, so we can have the same thread locking
406                  * multiple times without a problem */
407                 _mutex\&.lock();
408 
409                 while ( !_used_list\&.empty() )
410                 {
411                         Free(_used_list\&.top());
412                 }
413 
414 
415 
416                 if ( _pool != nullptr )
417                 {
418                         FREE(_pool);
419                         _pool = nullptr;
420                 }
421 
422 #if defined(USING_MEMORY_DEBUGGING)
423                 _infovect\&.clear();
424 #endif
425                 _mutex\&.unlock();
426         }
.fi
.SH "Member Data Documentation"
.PP 
.SS "template<class T> std::vector<std::shared_ptr<T> > \fBObjectPool\fP< T >::_delete_later\fC [private]\fP"

.PP
Definition at line 93 of file IrcPool\&.h\&.
.SS "template<class T> std::stack<T*> \fBObjectPool\fP< T >::_free_list\fC [private]\fP"
A stack of addresses available to use from the _pool 
.PP
Definition at line 87 of file bak/IrcPool\&.h\&.
.SS "template<class T> std::stack<T> \fBObjectPool\fP< T >::_free_list\fC [private]\fP"
A stack of addresses available to use from the _pool 
.PP
Definition at line 98 of file IrcPool\&.h\&.
.SS "template<class T> uint32_t \fBObjectPool\fP< T >::_get_count\fC [private]\fP"
Stats; the number of objects requested via \fBGet()\fP in total 
.PP
Definition at line 101 of file IrcPool\&.h\&.
.SS "template<class T> uint32_t \fBObjectPool\fP< T >::_max_alive\fC [private]\fP"
Stats; the maximum number of objects requested and still used via \fBGet()\fP at a single point in time 
.PP
Definition at line 104 of file IrcPool\&.h\&.
.SS "template<class T> std::mutex \fBObjectPool\fP< T >::_mutex\fC [private]\fP"
The lock for making modifications per pool 
.PP
Definition at line 107 of file IrcPool\&.h\&.
.SS "template<class T> std::vector<std::shared_ptr<T> > \fBObjectPool\fP< T >::_objects\fC [private]\fP"

.PP
Definition at line 91 of file IrcPool\&.h\&.
.SS "template<class T> void * \fBObjectPool\fP< T >::_pool\fC [private]\fP"
The address of the allocated memory 
.PP
Definition at line 88 of file IrcPool\&.h\&.
.SS "template<class T> std::stack<T*> \fBObjectPool\fP< T >::_used_list\fC [private]\fP"
A stack of addresses used from the _pool 
.PP
Definition at line 85 of file bak/IrcPool\&.h\&.
.SS "template<class T> std::stack<T> \fBObjectPool\fP< T >::_used_list\fC [private]\fP"
A stack of addresses used from the _pool 
.PP
Definition at line 96 of file IrcPool\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Social Bot Interface from the source code\&.
